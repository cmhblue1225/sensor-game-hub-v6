/**
 * 🔧 SessionSDK v6.0
 * 
 * 완벽한 게임별 독립 세션 관리를 위한 통합 SDK
 * - 게임에서 즉시 세션 생성
 * - 실시간 센서 데이터 처리
 * - 자동 연결 관리 및 복구
 */

class SessionSDK extends EventTarget {
    constructor(options = {}) {
        super();
        
        // 설정값
        this.config = {\n            serverUrl: options.serverUrl || window.location.origin,\n            gameId: options.gameId || 'unknown-game',\n            gameType: options.gameType || 'solo', // 'solo', 'dual', 'multi'\n            autoReconnect: options.autoReconnect !== false,\n            reconnectInterval: options.reconnectInterval || 3000,\n            maxReconnectAttempts: options.maxReconnectAttempts || 5,\n            debug: options.debug || false\n        };\n        \n        // 상태 관리\n        this.state = {\n            connected: false,\n            session: null,\n            reconnectAttempts: 0,\n            lastPing: 0\n        };\n        \n        // Socket.IO 연결\n        this.socket = null;\n        \n        // 이벤트 핸들러 저장소\n        this.eventHandlers = new Map();\n        \n        this.log('🔧 SessionSDK v6.0 초기화', this.config);\n        \n        // 자동 연결 시작\n        this.connect();\n    }\n    \n    /**\n     * 서버 연결\n     */\n    async connect() {\n        try {\n            this.log('🔌 서버 연결 중...');\n            \n            // Socket.IO 연결\n            this.socket = io(this.config.serverUrl, {\n                transports: ['websocket', 'polling'],\n                timeout: 10000\n            });\n            \n            this.setupSocketEvents();\n            \n            // 연결 대기\n            await this.waitForConnection();\n            \n            this.log('✅ 서버 연결 성공');\n            this.emit('connected');\n            \n        } catch (error) {\n            this.log('❌ 서버 연결 실패:', error.message);\n            this.emit('connection-error', { error: error.message });\n            \n            if (this.config.autoReconnect) {\n                this.scheduleReconnect();\n            }\n        }\n    }\n    \n    /**\n     * Socket.IO 이벤트 설정\n     */\n    setupSocketEvents() {\n        this.socket.on('connect', () => {\n            this.state.connected = true;\n            this.state.reconnectAttempts = 0;\n            this.log('✅ Socket 연결됨');\n        });\n        \n        this.socket.on('disconnect', (reason) => {\n            this.state.connected = false;\n            this.log('❌ Socket 연결 해제:', reason);\n            this.emit('disconnected', { reason });\n            \n            if (this.config.autoReconnect && reason !== 'io client disconnect') {\n                this.scheduleReconnect();\n            }\n        });\n        \n        this.socket.on('connect_error', (error) => {\n            this.log('❌ 연결 오류:', error.message);\n            this.emit('connection-error', { error: error.message });\n        });\n        \n        // 게임별 이벤트 핸들러\n        this.socket.on('sensor-connected', (data) => {\n            this.log('📱 센서 연결됨:', data);\n            this.emit('sensor-connected', data);\n        });\n        \n        this.socket.on('sensor-disconnected', (data) => {\n            this.log('📱 센서 연결 해제:', data);\n            this.emit('sensor-disconnected', data);\n        });\n        \n        this.socket.on('sensor-update', (data) => {\n            this.emit('sensor-data', data);\n        });\n        \n        this.socket.on('game-ready', (data) => {\n            this.log('🎮 게임 준비 완료:', data);\n            this.emit('game-ready', data);\n        });\n        \n        this.socket.on('game-started', (data) => {\n            this.log('🎮 게임 시작:', data);\n            this.emit('game-started', data);\n        });\n        \n        this.socket.on('host-disconnected', (data) => {\n            this.log('🖥️ 호스트 연결 해제:', data);\n            this.emit('host-disconnected', data);\n        });\n        \n        this.socket.on('sensor-error', (data) => {\n            this.log('❌ 센서 오류:', data);\n            this.emit('sensor-error', data);\n        });\n    }\n    \n    /**\n     * 게임 세션 생성 (게임에서 호출)\n     */\n    async createSession() {\n        if (!this.state.connected) {\n            throw new Error('서버에 연결되지 않았습니다.');\n        }\n        \n        this.log('🎮 세션 생성 중...', {\n            gameId: this.config.gameId,\n            gameType: this.config.gameType\n        });\n        \n        return new Promise((resolve, reject) => {\n            this.socket.emit('create-session', {\n                gameId: this.config.gameId,\n                gameType: this.config.gameType\n            }, (response) => {\n                if (response.success) {\n                    this.state.session = response.session;\n                    this.log('✅ 세션 생성 성공:', response.session);\n                    this.emit('session-created', response.session);\n                    resolve(response.session);\n                } else {\n                    this.log('❌ 세션 생성 실패:', response.error);\n                    reject(new Error(response.error));\n                }\n            });\n        });\n    }\n    \n    /**\n     * 센서 연결 (모바일에서 호출)\n     */\n    async connectSensor(sessionCode, deviceInfo = {}) {\n        if (!this.state.connected) {\n            throw new Error('서버에 연결되지 않았습니다.');\n        }\n        \n        this.log('📱 센서 연결 중...', { sessionCode, deviceInfo });\n        \n        return new Promise((resolve, reject) => {\n            this.socket.emit('connect-sensor', {\n                sessionCode,\n                deviceInfo: {\n                    userAgent: navigator.userAgent,\n                    platform: navigator.platform,\n                    screenSize: `${screen.width}x${screen.height}`,\n                    timestamp: Date.now(),\n                    ...deviceInfo\n                }\n            }, (response) => {\n                if (response.success) {\n                    this.state.connection = response.connection;\n                    this.log('✅ 센서 연결 성공:', response.connection);\n                    this.emit('sensor-connection-success', response.connection);\n                    resolve(response.connection);\n                } else {\n                    this.log('❌ 센서 연결 실패:', response.error);\n                    reject(new Error(response.error));\n                }\n            });\n        });\n    }\n    \n    /**\n     * 센서 데이터 전송 (모바일에서 호출)\n     */\n    sendSensorData(sensorData) {\n        if (!this.state.connected || !this.state.connection) {\n            this.log('❌ 센서 데이터 전송 실패: 연결되지 않음');\n            return false;\n        }\n        \n        this.socket.emit('sensor-data', {\n            sessionCode: this.state.connection.sessionId.split('_')[1], // Extract session code\n            sensorId: this.state.connection.sensorId,\n            sensorData: {\n                ...sensorData,\n                timestamp: Date.now()\n            }\n        });\n        \n        return true;\n    }\n    \n    /**\n     * 게임 시작 (게임에서 호출)\n     */\n    async startGame() {\n        if (!this.state.connected || !this.state.session) {\n            throw new Error('세션이 생성되지 않았습니다.');\n        }\n        \n        this.log('🎮 게임 시작 요청...');\n        \n        return new Promise((resolve, reject) => {\n            this.socket.emit('start-game', {\n                sessionId: this.state.session.sessionId\n            }, (response) => {\n                if (response.success) {\n                    this.log('✅ 게임 시작 성공:', response.game);\n                    this.emit('game-start-success', response.game);\n                    resolve(response.game);\n                } else {\n                    this.log('❌ 게임 시작 실패:', response.error);\n                    reject(new Error(response.error));\n                }\n            });\n        });\n    }\n    \n    /**\n     * 세션 정보 조회\n     */\n    getSession() {\n        return this.state.session;\n    }\n    \n    /**\n     * 연결 상태 조회\n     */\n    isConnected() {\n        return this.state.connected;\n    }\n    \n    /**\n     * 센서 연결 정보 조회\n     */\n    getSensorConnection() {\n        return this.state.connection;\n    }\n    \n    /**\n     * 핑 테스트\n     */\n    async ping() {\n        if (!this.state.connected) {\n            return null;\n        }\n        \n        const startTime = Date.now();\n        \n        return new Promise((resolve) => {\n            this.socket.emit('ping', (response) => {\n                const latency = Date.now() - startTime;\n                this.state.lastPing = latency;\n                resolve(latency);\n            });\n        });\n    }\n    \n    /**\n     * 연결 해제\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        \n        this.state.connected = false;\n        this.state.session = null;\n        this.state.connection = null;\n        \n        this.log('🔌 연결 해제됨');\n    }\n    \n    /**\n     * 연결 대기\n     */\n    waitForConnection(timeout = 10000) {\n        return new Promise((resolve, reject) => {\n            if (this.socket.connected) {\n                resolve();\n                return;\n            }\n            \n            const timer = setTimeout(() => {\n                reject(new Error('연결 타임아웃'));\n            }, timeout);\n            \n            this.socket.once('connect', () => {\n                clearTimeout(timer);\n                resolve();\n            });\n            \n            this.socket.once('connect_error', (error) => {\n                clearTimeout(timer);\n                reject(error);\n            });\n        });\n    }\n    \n    /**\n     * 재연결 스케줄링\n     */\n    scheduleReconnect() {\n        if (this.state.reconnectAttempts >= this.config.maxReconnectAttempts) {\n            this.log('❌ 최대 재연결 시도 횟수 초과');\n            this.emit('max-reconnect-attempts-reached');\n            return;\n        }\n        \n        this.state.reconnectAttempts++;\n        \n        this.log(`🔄 재연결 시도 ${this.state.reconnectAttempts}/${this.config.maxReconnectAttempts} (${this.config.reconnectInterval}ms 후)`);\n        \n        setTimeout(() => {\n            this.connect();\n        }, this.config.reconnectInterval);\n    }\n    \n    /**\n     * 이벤트 리스너 추가 (편의 메서드)\n     */\n    on(eventName, handler) {\n        this.addEventListener(eventName, handler);\n        \n        // 핸들러 저장 (제거를 위해)\n        if (!this.eventHandlers.has(eventName)) {\n            this.eventHandlers.set(eventName, new Set());\n        }\n        this.eventHandlers.get(eventName).add(handler);\n    }\n    \n    /**\n     * 이벤트 리스너 제거 (편의 메서드)\n     */\n    off(eventName, handler) {\n        this.removeEventListener(eventName, handler);\n        \n        if (this.eventHandlers.has(eventName)) {\n            this.eventHandlers.get(eventName).delete(handler);\n        }\n    }\n    \n    /**\n     * 이벤트 발생 (편의 메서드)\n     */\n    emit(eventName, data = {}) {\n        const event = new CustomEvent(eventName, { detail: data });\n        this.dispatchEvent(event);\n    }\n    \n    /**\n     * 디버그 로그\n     */\n    log(...args) {\n        if (this.config.debug) {\n            console.log(`[SessionSDK]`, ...args);\n        }\n    }\n    \n    /**\n     * SDK 정리\n     */\n    destroy() {\n        this.disconnect();\n        \n        // 모든 이벤트 리스너 제거\n        for (const [eventName, handlers] of this.eventHandlers) {\n            for (const handler of handlers) {\n                this.removeEventListener(eventName, handler);\n            }\n        }\n        \n        this.eventHandlers.clear();\n        \n        this.log('🗑️ SessionSDK 정리됨');\n    }\n}\n\n// QR 코드 생성 유틸리티\nclass QRCodeGenerator {\n    static async generate(text, size = 200) {\n        if (typeof QRCode !== 'undefined') {\n            // QRCode 라이브러리가 있는 경우\n            const canvas = document.createElement('canvas');\n            await QRCode.toCanvas(canvas, text, { width: size, height: size });\n            return canvas.toDataURL();\n        } else {\n            // 폴백: QR 코드 서비스 사용\n            return `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(text)}`;\n        }\n    }\n    \n    static async generateElement(text, size = 200) {\n        const container = document.createElement('div');\n        container.className = 'qr-code-container';\n        container.style.textAlign = 'center';\n        \n        try {\n            if (typeof QRCode !== 'undefined') {\n                await QRCode.toCanvas(container, text, { \n                    width: size, \n                    height: size,\n                    color: {\n                        dark: '#3b82f6',\n                        light: '#ffffff'\n                    }\n                });\n            } else {\n                const img = document.createElement('img');\n                img.src = await this.generate(text, size);\n                img.alt = 'QR Code';\n                img.style.maxWidth = '100%';\n                container.appendChild(img);\n            }\n        } catch (error) {\n            console.error('QR 코드 생성 실패:', error);\n            container.innerHTML = `<p>QR 코드 생성 실패: ${text}</p>`;\n        }\n        \n        return container;\n    }\n}\n\n// 센서 데이터 수집 유틸리티\nclass SensorCollector {\n    constructor(options = {}) {\n        this.options = {\n            throttle: options.throttle || 50, // 50ms 간격\n            sensitivity: options.sensitivity || 1,\n            ...options\n        };\n        \n        this.isActive = false;\n        this.lastUpdate = 0;\n        this.handlers = new Set();\n        \n        this.sensorData = {\n            acceleration: { x: 0, y: 0, z: 0 },\n            rotationRate: { alpha: 0, beta: 0, gamma: 0 },\n            orientation: { alpha: 0, beta: 0, gamma: 0 }\n        };\n    }\n    \n    async start() {\n        if (!this.checkSensorSupport()) {\n            throw new Error('이 기기는 센서를 지원하지 않습니다.');\n        }\n        \n        // 권한 요청 (iOS 13+)\n        if (typeof DeviceMotionEvent.requestPermission === 'function') {\n            const permission = await DeviceMotionEvent.requestPermission();\n            if (permission !== 'granted') {\n                throw new Error('센서 권한이 거부되었습니다.');\n            }\n        }\n        \n        this.isActive = true;\n        \n        // Device Motion 이벤트\n        window.addEventListener('devicemotion', this.handleDeviceMotion.bind(this));\n        \n        // Device Orientation 이벤트\n        window.addEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));\n        \n        console.log('📱 센서 수집 시작');\n    }\n    \n    stop() {\n        this.isActive = false;\n        \n        window.removeEventListener('devicemotion', this.handleDeviceMotion.bind(this));\n        window.removeEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));\n        \n        console.log('📱 센서 수집 중지');\n    }\n    \n    handleDeviceMotion(event) {\n        if (!this.isActive) return;\n        \n        const now = Date.now();\n        if (now - this.lastUpdate < this.options.throttle) return;\n        \n        if (event.acceleration) {\n            this.sensorData.acceleration = {\n                x: (event.acceleration.x || 0) * this.options.sensitivity,\n                y: (event.acceleration.y || 0) * this.options.sensitivity,\n                z: (event.acceleration.z || 0) * this.options.sensitivity\n            };\n        }\n        \n        if (event.rotationRate) {\n            this.sensorData.rotationRate = {\n                alpha: (event.rotationRate.alpha || 0) * this.options.sensitivity,\n                beta: (event.rotationRate.beta || 0) * this.options.sensitivity,\n                gamma: (event.rotationRate.gamma || 0) * this.options.sensitivity\n            };\n        }\n        \n        this.lastUpdate = now;\n        this.notifyHandlers();\n    }\n    \n    handleDeviceOrientation(event) {\n        if (!this.isActive) return;\n        \n        this.sensorData.orientation = {\n            alpha: event.alpha || 0,\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        };\n    }\n    \n    checkSensorSupport() {\n        return 'DeviceMotionEvent' in window && 'DeviceOrientationEvent' in window;\n    }\n    \n    onData(handler) {\n        this.handlers.add(handler);\n    }\n    \n    offData(handler) {\n        this.handlers.delete(handler);\n    }\n    \n    notifyHandlers() {\n        const data = { ...this.sensorData };\n        this.handlers.forEach(handler => handler(data));\n    }\n    \n    getCurrentData() {\n        return { ...this.sensorData };\n    }\n}\n\n// 전역 노출\nif (typeof window !== 'undefined') {\n    window.SessionSDK = SessionSDK;\n    window.QRCodeGenerator = QRCodeGenerator;\n    window.SensorCollector = SensorCollector;\n}\n\n// 모듈 노출\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { SessionSDK, QRCodeGenerator, SensorCollector };\n}