/**
 * ğŸ”§ SessionSDK v6.0
 * 
 * ì™„ë²½í•œ ê²Œì„ë³„ ë…ë¦½ ì„¸ì…˜ ê´€ë¦¬ë¥¼ ìœ„í•œ í†µí•© SDK
 * - ê²Œì„ì—ì„œ ì¦‰ì‹œ ì„¸ì…˜ ìƒì„±
 * - ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬
 * - ìë™ ì—°ê²° ê´€ë¦¬ ë° ë³µêµ¬
 */

class SessionSDK extends EventTarget {
    constructor(options = {}) {
        super();
        
        // ì„¤ì •ê°’
        this.config = {\n            serverUrl: options.serverUrl || window.location.origin,\n            gameId: options.gameId || 'unknown-game',\n            gameType: options.gameType || 'solo', // 'solo', 'dual', 'multi'\n            autoReconnect: options.autoReconnect !== false,\n            reconnectInterval: options.reconnectInterval || 3000,\n            maxReconnectAttempts: options.maxReconnectAttempts || 5,\n            debug: options.debug || false\n        };\n        \n        // ìƒíƒœ ê´€ë¦¬\n        this.state = {\n            connected: false,\n            session: null,\n            reconnectAttempts: 0,\n            lastPing: 0\n        };\n        \n        // Socket.IO ì—°ê²°\n        this.socket = null;\n        \n        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì €ì¥ì†Œ\n        this.eventHandlers = new Map();\n        \n        this.log('ğŸ”§ SessionSDK v6.0 ì´ˆê¸°í™”', this.config);\n        \n        // ìë™ ì—°ê²° ì‹œì‘\n        this.connect();\n    }\n    \n    /**\n     * ì„œë²„ ì—°ê²°\n     */\n    async connect() {\n        try {\n            this.log('ğŸ”Œ ì„œë²„ ì—°ê²° ì¤‘...');\n            \n            // Socket.IO ì—°ê²°\n            this.socket = io(this.config.serverUrl, {\n                transports: ['websocket', 'polling'],\n                timeout: 10000\n            });\n            \n            this.setupSocketEvents();\n            \n            // ì—°ê²° ëŒ€ê¸°\n            await this.waitForConnection();\n            \n            this.log('âœ… ì„œë²„ ì—°ê²° ì„±ê³µ');\n            this.emit('connected');\n            \n        } catch (error) {\n            this.log('âŒ ì„œë²„ ì—°ê²° ì‹¤íŒ¨:', error.message);\n            this.emit('connection-error', { error: error.message });\n            \n            if (this.config.autoReconnect) {\n                this.scheduleReconnect();\n            }\n        }\n    }\n    \n    /**\n     * Socket.IO ì´ë²¤íŠ¸ ì„¤ì •\n     */\n    setupSocketEvents() {\n        this.socket.on('connect', () => {\n            this.state.connected = true;\n            this.state.reconnectAttempts = 0;\n            this.log('âœ… Socket ì—°ê²°ë¨');\n        });\n        \n        this.socket.on('disconnect', (reason) => {\n            this.state.connected = false;\n            this.log('âŒ Socket ì—°ê²° í•´ì œ:', reason);\n            this.emit('disconnected', { reason });\n            \n            if (this.config.autoReconnect && reason !== 'io client disconnect') {\n                this.scheduleReconnect();\n            }\n        });\n        \n        this.socket.on('connect_error', (error) => {\n            this.log('âŒ ì—°ê²° ì˜¤ë¥˜:', error.message);\n            this.emit('connection-error', { error: error.message });\n        });\n        \n        // ê²Œì„ë³„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬\n        this.socket.on('sensor-connected', (data) => {\n            this.log('ğŸ“± ì„¼ì„œ ì—°ê²°ë¨:', data);\n            this.emit('sensor-connected', data);\n        });\n        \n        this.socket.on('sensor-disconnected', (data) => {\n            this.log('ğŸ“± ì„¼ì„œ ì—°ê²° í•´ì œ:', data);\n            this.emit('sensor-disconnected', data);\n        });\n        \n        this.socket.on('sensor-update', (data) => {\n            this.emit('sensor-data', data);\n        });\n        \n        this.socket.on('game-ready', (data) => {\n            this.log('ğŸ® ê²Œì„ ì¤€ë¹„ ì™„ë£Œ:', data);\n            this.emit('game-ready', data);\n        });\n        \n        this.socket.on('game-started', (data) => {\n            this.log('ğŸ® ê²Œì„ ì‹œì‘:', data);\n            this.emit('game-started', data);\n        });\n        \n        this.socket.on('host-disconnected', (data) => {\n            this.log('ğŸ–¥ï¸ í˜¸ìŠ¤íŠ¸ ì—°ê²° í•´ì œ:', data);\n            this.emit('host-disconnected', data);\n        });\n        \n        this.socket.on('sensor-error', (data) => {\n            this.log('âŒ ì„¼ì„œ ì˜¤ë¥˜:', data);\n            this.emit('sensor-error', data);\n        });\n    }\n    \n    /**\n     * ê²Œì„ ì„¸ì…˜ ìƒì„± (ê²Œì„ì—ì„œ í˜¸ì¶œ)\n     */\n    async createSession() {\n        if (!this.state.connected) {\n            throw new Error('ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');\n        }\n        \n        this.log('ğŸ® ì„¸ì…˜ ìƒì„± ì¤‘...', {\n            gameId: this.config.gameId,\n            gameType: this.config.gameType\n        });\n        \n        return new Promise((resolve, reject) => {\n            this.socket.emit('create-session', {\n                gameId: this.config.gameId,\n                gameType: this.config.gameType\n            }, (response) => {\n                if (response.success) {\n                    this.state.session = response.session;\n                    this.log('âœ… ì„¸ì…˜ ìƒì„± ì„±ê³µ:', response.session);\n                    this.emit('session-created', response.session);\n                    resolve(response.session);\n                } else {\n                    this.log('âŒ ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨:', response.error);\n                    reject(new Error(response.error));\n                }\n            });\n        });\n    }\n    \n    /**\n     * ì„¼ì„œ ì—°ê²° (ëª¨ë°”ì¼ì—ì„œ í˜¸ì¶œ)\n     */\n    async connectSensor(sessionCode, deviceInfo = {}) {\n        if (!this.state.connected) {\n            throw new Error('ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');\n        }\n        \n        this.log('ğŸ“± ì„¼ì„œ ì—°ê²° ì¤‘...', { sessionCode, deviceInfo });\n        \n        return new Promise((resolve, reject) => {\n            this.socket.emit('connect-sensor', {\n                sessionCode,\n                deviceInfo: {\n                    userAgent: navigator.userAgent,\n                    platform: navigator.platform,\n                    screenSize: `${screen.width}x${screen.height}`,\n                    timestamp: Date.now(),\n                    ...deviceInfo\n                }\n            }, (response) => {\n                if (response.success) {\n                    this.state.connection = response.connection;\n                    this.log('âœ… ì„¼ì„œ ì—°ê²° ì„±ê³µ:', response.connection);\n                    this.emit('sensor-connection-success', response.connection);\n                    resolve(response.connection);\n                } else {\n                    this.log('âŒ ì„¼ì„œ ì—°ê²° ì‹¤íŒ¨:', response.error);\n                    reject(new Error(response.error));\n                }\n            });\n        });\n    }\n    \n    /**\n     * ì„¼ì„œ ë°ì´í„° ì „ì†¡ (ëª¨ë°”ì¼ì—ì„œ í˜¸ì¶œ)\n     */\n    sendSensorData(sensorData) {\n        if (!this.state.connected || !this.state.connection) {\n            this.log('âŒ ì„¼ì„œ ë°ì´í„° ì „ì†¡ ì‹¤íŒ¨: ì—°ê²°ë˜ì§€ ì•ŠìŒ');\n            return false;\n        }\n        \n        this.socket.emit('sensor-data', {\n            sessionCode: this.state.connection.sessionId.split('_')[1], // Extract session code\n            sensorId: this.state.connection.sensorId,\n            sensorData: {\n                ...sensorData,\n                timestamp: Date.now()\n            }\n        });\n        \n        return true;\n    }\n    \n    /**\n     * ê²Œì„ ì‹œì‘ (ê²Œì„ì—ì„œ í˜¸ì¶œ)\n     */\n    async startGame() {\n        if (!this.state.connected || !this.state.session) {\n            throw new Error('ì„¸ì…˜ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');\n        }\n        \n        this.log('ğŸ® ê²Œì„ ì‹œì‘ ìš”ì²­...');\n        \n        return new Promise((resolve, reject) => {\n            this.socket.emit('start-game', {\n                sessionId: this.state.session.sessionId\n            }, (response) => {\n                if (response.success) {\n                    this.log('âœ… ê²Œì„ ì‹œì‘ ì„±ê³µ:', response.game);\n                    this.emit('game-start-success', response.game);\n                    resolve(response.game);\n                } else {\n                    this.log('âŒ ê²Œì„ ì‹œì‘ ì‹¤íŒ¨:', response.error);\n                    reject(new Error(response.error));\n                }\n            });\n        });\n    }\n    \n    /**\n     * ì„¸ì…˜ ì •ë³´ ì¡°íšŒ\n     */\n    getSession() {\n        return this.state.session;\n    }\n    \n    /**\n     * ì—°ê²° ìƒíƒœ ì¡°íšŒ\n     */\n    isConnected() {\n        return this.state.connected;\n    }\n    \n    /**\n     * ì„¼ì„œ ì—°ê²° ì •ë³´ ì¡°íšŒ\n     */\n    getSensorConnection() {\n        return this.state.connection;\n    }\n    \n    /**\n     * í•‘ í…ŒìŠ¤íŠ¸\n     */\n    async ping() {\n        if (!this.state.connected) {\n            return null;\n        }\n        \n        const startTime = Date.now();\n        \n        return new Promise((resolve) => {\n            this.socket.emit('ping', (response) => {\n                const latency = Date.now() - startTime;\n                this.state.lastPing = latency;\n                resolve(latency);\n            });\n        });\n    }\n    \n    /**\n     * ì—°ê²° í•´ì œ\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        \n        this.state.connected = false;\n        this.state.session = null;\n        this.state.connection = null;\n        \n        this.log('ğŸ”Œ ì—°ê²° í•´ì œë¨');\n    }\n    \n    /**\n     * ì—°ê²° ëŒ€ê¸°\n     */\n    waitForConnection(timeout = 10000) {\n        return new Promise((resolve, reject) => {\n            if (this.socket.connected) {\n                resolve();\n                return;\n            }\n            \n            const timer = setTimeout(() => {\n                reject(new Error('ì—°ê²° íƒ€ì„ì•„ì›ƒ'));\n            }, timeout);\n            \n            this.socket.once('connect', () => {\n                clearTimeout(timer);\n                resolve();\n            });\n            \n            this.socket.once('connect_error', (error) => {\n                clearTimeout(timer);\n                reject(error);\n            });\n        });\n    }\n    \n    /**\n     * ì¬ì—°ê²° ìŠ¤ì¼€ì¤„ë§\n     */\n    scheduleReconnect() {\n        if (this.state.reconnectAttempts >= this.config.maxReconnectAttempts) {\n            this.log('âŒ ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼');\n            this.emit('max-reconnect-attempts-reached');\n            return;\n        }\n        \n        this.state.reconnectAttempts++;\n        \n        this.log(`ğŸ”„ ì¬ì—°ê²° ì‹œë„ ${this.state.reconnectAttempts}/${this.config.maxReconnectAttempts} (${this.config.reconnectInterval}ms í›„)`);\n        \n        setTimeout(() => {\n            this.connect();\n        }, this.config.reconnectInterval);\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (í¸ì˜ ë©”ì„œë“œ)\n     */\n    on(eventName, handler) {\n        this.addEventListener(eventName, handler);\n        \n        // í•¸ë“¤ëŸ¬ ì €ì¥ (ì œê±°ë¥¼ ìœ„í•´)\n        if (!this.eventHandlers.has(eventName)) {\n            this.eventHandlers.set(eventName, new Set());\n        }\n        this.eventHandlers.get(eventName).add(handler);\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (í¸ì˜ ë©”ì„œë“œ)\n     */\n    off(eventName, handler) {\n        this.removeEventListener(eventName, handler);\n        \n        if (this.eventHandlers.has(eventName)) {\n            this.eventHandlers.get(eventName).delete(handler);\n        }\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë°œìƒ (í¸ì˜ ë©”ì„œë“œ)\n     */\n    emit(eventName, data = {}) {\n        const event = new CustomEvent(eventName, { detail: data });\n        this.dispatchEvent(event);\n    }\n    \n    /**\n     * ë””ë²„ê·¸ ë¡œê·¸\n     */\n    log(...args) {\n        if (this.config.debug) {\n            console.log(`[SessionSDK]`, ...args);\n        }\n    }\n    \n    /**\n     * SDK ì •ë¦¬\n     */\n    destroy() {\n        this.disconnect();\n        \n        // ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°\n        for (const [eventName, handlers] of this.eventHandlers) {\n            for (const handler of handlers) {\n                this.removeEventListener(eventName, handler);\n            }\n        }\n        \n        this.eventHandlers.clear();\n        \n        this.log('ğŸ—‘ï¸ SessionSDK ì •ë¦¬ë¨');\n    }\n}\n\n// QR ì½”ë“œ ìƒì„± ìœ í‹¸ë¦¬í‹°\nclass QRCodeGenerator {\n    static async generate(text, size = 200) {\n        if (typeof QRCode !== 'undefined') {\n            // QRCode ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ìˆëŠ” ê²½ìš°\n            const canvas = document.createElement('canvas');\n            await QRCode.toCanvas(canvas, text, { width: size, height: size });\n            return canvas.toDataURL();\n        } else {\n            // í´ë°±: QR ì½”ë“œ ì„œë¹„ìŠ¤ ì‚¬ìš©\n            return `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(text)}`;\n        }\n    }\n    \n    static async generateElement(text, size = 200) {\n        const container = document.createElement('div');\n        container.className = 'qr-code-container';\n        container.style.textAlign = 'center';\n        \n        try {\n            if (typeof QRCode !== 'undefined') {\n                await QRCode.toCanvas(container, text, { \n                    width: size, \n                    height: size,\n                    color: {\n                        dark: '#3b82f6',\n                        light: '#ffffff'\n                    }\n                });\n            } else {\n                const img = document.createElement('img');\n                img.src = await this.generate(text, size);\n                img.alt = 'QR Code';\n                img.style.maxWidth = '100%';\n                container.appendChild(img);\n            }\n        } catch (error) {\n            console.error('QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨:', error);\n            container.innerHTML = `<p>QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨: ${text}</p>`;\n        }\n        \n        return container;\n    }\n}\n\n// ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘ ìœ í‹¸ë¦¬í‹°\nclass SensorCollector {\n    constructor(options = {}) {\n        this.options = {\n            throttle: options.throttle || 50, // 50ms ê°„ê²©\n            sensitivity: options.sensitivity || 1,\n            ...options\n        };\n        \n        this.isActive = false;\n        this.lastUpdate = 0;\n        this.handlers = new Set();\n        \n        this.sensorData = {\n            acceleration: { x: 0, y: 0, z: 0 },\n            rotationRate: { alpha: 0, beta: 0, gamma: 0 },\n            orientation: { alpha: 0, beta: 0, gamma: 0 }\n        };\n    }\n    \n    async start() {\n        if (!this.checkSensorSupport()) {\n            throw new Error('ì´ ê¸°ê¸°ëŠ” ì„¼ì„œë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');\n        }\n        \n        // ê¶Œí•œ ìš”ì²­ (iOS 13+)\n        if (typeof DeviceMotionEvent.requestPermission === 'function') {\n            const permission = await DeviceMotionEvent.requestPermission();\n            if (permission !== 'granted') {\n                throw new Error('ì„¼ì„œ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.');\n            }\n        }\n        \n        this.isActive = true;\n        \n        // Device Motion ì´ë²¤íŠ¸\n        window.addEventListener('devicemotion', this.handleDeviceMotion.bind(this));\n        \n        // Device Orientation ì´ë²¤íŠ¸\n        window.addEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));\n        \n        console.log('ğŸ“± ì„¼ì„œ ìˆ˜ì§‘ ì‹œì‘');\n    }\n    \n    stop() {\n        this.isActive = false;\n        \n        window.removeEventListener('devicemotion', this.handleDeviceMotion.bind(this));\n        window.removeEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));\n        \n        console.log('ğŸ“± ì„¼ì„œ ìˆ˜ì§‘ ì¤‘ì§€');\n    }\n    \n    handleDeviceMotion(event) {\n        if (!this.isActive) return;\n        \n        const now = Date.now();\n        if (now - this.lastUpdate < this.options.throttle) return;\n        \n        if (event.acceleration) {\n            this.sensorData.acceleration = {\n                x: (event.acceleration.x || 0) * this.options.sensitivity,\n                y: (event.acceleration.y || 0) * this.options.sensitivity,\n                z: (event.acceleration.z || 0) * this.options.sensitivity\n            };\n        }\n        \n        if (event.rotationRate) {\n            this.sensorData.rotationRate = {\n                alpha: (event.rotationRate.alpha || 0) * this.options.sensitivity,\n                beta: (event.rotationRate.beta || 0) * this.options.sensitivity,\n                gamma: (event.rotationRate.gamma || 0) * this.options.sensitivity\n            };\n        }\n        \n        this.lastUpdate = now;\n        this.notifyHandlers();\n    }\n    \n    handleDeviceOrientation(event) {\n        if (!this.isActive) return;\n        \n        this.sensorData.orientation = {\n            alpha: event.alpha || 0,\n            beta: event.beta || 0,\n            gamma: event.gamma || 0\n        };\n    }\n    \n    checkSensorSupport() {\n        return 'DeviceMotionEvent' in window && 'DeviceOrientationEvent' in window;\n    }\n    \n    onData(handler) {\n        this.handlers.add(handler);\n    }\n    \n    offData(handler) {\n        this.handlers.delete(handler);\n    }\n    \n    notifyHandlers() {\n        const data = { ...this.sensorData };\n        this.handlers.forEach(handler => handler(data));\n    }\n    \n    getCurrentData() {\n        return { ...this.sensorData };\n    }\n}\n\n// ì „ì—­ ë…¸ì¶œ\nif (typeof window !== 'undefined') {\n    window.SessionSDK = SessionSDK;\n    window.QRCodeGenerator = QRCodeGenerator;\n    window.SensorCollector = SensorCollector;\n}\n\n// ëª¨ë“ˆ ë…¸ì¶œ\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { SessionSDK, QRCodeGenerator, SensorCollector };\n}