/**
 * ë©€í‹°í”Œë ˆì´ì–´ ë°¸ëŸ°ì‹± ì‹œìŠ¤í…œ
 * 4ì¸ í˜‘ë™ ëª¨ë“œì—ì„œ í”Œë ˆì´ì–´ ìˆ˜ì— ë”°ë¥¸ ë™ì  ë‚œì´ë„ ì¡°ì ˆê³¼ í˜‘ë™ í”Œë ˆì´ ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•©ë‹ˆë‹¤.
 */
class MultiplayerBalancingSystem {
    constructor() {
        // í”Œë ˆì´ì–´ ì„¤ì •
        this.maxPlayers = 4;
        this.minPlayers = 1;
        this.currentPlayerCount = 0;
        
        // í”Œë ˆì´ì–´ ë°ì´í„°
        this.players = new Map(); // playerId -> playerData
        
        // ë°¸ëŸ°ì‹± ì„¤ì •
        this.balancingConfig = {
            // í”Œë ˆì´ì–´ ìˆ˜ë³„ ë‚œì´ë„ ì¡°ì ˆ
            playerCountMultipliers: {
                1: { difficulty: 1.0, cooperation: 0.0, timeLimit: 1.0, cakeStability: 1.0 },
                2: { difficulty: 1.2, cooperation: 0.3, timeLimit: 1.1, cakeStability: 0.9 },
                3: { difficulty: 1.4, cooperation: 0.5, timeLimit: 1.2, cakeStability: 0.8 },
                4: { difficulty: 1.6, cooperation: 0.7, timeLimit: 1.3, cakeStability: 0.7 }
            },
            
            // í˜‘ë™ ë©”ì»¤ë‹ˆì¦˜ ì„¤ì •
            cooperationMechanics: {
                sharedCakeControl: true,    // ê³µìœ  ì¼€ì´í¬ ì œì–´
                balanceAssistance: true,    // ê· í˜• ë³´ì¡°
                communicationBonus: true,   // ì†Œí†µ ë³´ë„ˆìŠ¤
                reviveSystem: true,         // ë¶€í™œ ì‹œìŠ¤í…œ
                sharedLives: false          // ê³µìœ  ìƒëª…ë ¥
            },
            
            // ì—­í•  ë¶„ë‹´ ì‹œìŠ¤í…œ
            roleSystem: {
                enabled: true,
                roles: ['leader', 'supporter', 'stabilizer', 'navigator'],
                autoAssign: true,
                roleRotation: true
            },
            
            // ì ìˆ˜ ì‹œìŠ¤í…œ
            scoreSystem: {
                individualScore: true,      // ê°œì¸ ì ìˆ˜
                teamScore: true,           // íŒ€ ì ìˆ˜
                cooperationBonus: 0.2,     // í˜‘ë™ ë³´ë„ˆìŠ¤ (20%)
                leadershipBonus: 0.1,      // ë¦¬ë”ì‹­ ë³´ë„ˆìŠ¤ (10%)
                consistencyBonus: 0.15     // ì¼ê´€ì„± ë³´ë„ˆìŠ¤ (15%)
            }
        };
        
        // ê²Œì„ ìƒíƒœ
        this.gameState = {
            isMultiplayer: false,
            gameMode: 'solo', // 'solo', 'coop', 'competitive'
            currentRound: 1,
            totalRounds: 3,
            teamScore: 0,
            cooperationLevel: 0.0, // 0-1 ë²”ìœ„ì˜ í˜‘ë™ ìˆ˜ì¤€
            communicationScore: 0.0,
            balanceHistory: []
        };
        
        // í˜‘ë™ ë©”íŠ¸ë¦­
        this.cooperationMetrics = {
            synchronizedActions: 0,     // ë™ê¸°í™”ëœ í–‰ë™ íšŸìˆ˜
            mutualAssistance: 0,        // ìƒí˜¸ ì§€ì› íšŸìˆ˜
            communicationEvents: 0,     // ì†Œí†µ ì´ë²¤íŠ¸ íšŸìˆ˜
            balanceRecoveries: 0,       // ê· í˜• ë³µêµ¬ íšŸìˆ˜
            sharedDecisions: 0          // ê³µìœ  ê²°ì • íšŸìˆ˜
        };
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        this.eventListeners = {
            onPlayerJoin: [],
            onPlayerLeave: [],
            onRoleAssign: [],
            onCooperationEvent: [],
            onBalanceChange: []
        };
        
        this.init();
    }
    
    /**
     * ì‹œìŠ¤í…œ ì´ˆê¸°í™”
     */
    init() {
        console.log('âœ… ë©€í‹°í”Œë ˆì´ì–´ ë°¸ëŸ°ì‹± ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
    }
    
    /**
     * í”Œë ˆì´ì–´ ì¶”ê°€
     */\n    addPlayer(playerId, playerData = {}) {\n        if (this.players.size >= this.maxPlayers) {\n            console.warn(`ìµœëŒ€ í”Œë ˆì´ì–´ ìˆ˜ ì´ˆê³¼: ${this.maxPlayers}`);\n            return false;\n        }\n        \n        const player = {\n            id: playerId,\n            name: playerData.name || `Player ${this.players.size + 1}`,\n            joinTime: Date.now(),\n            role: null,\n            score: 0,\n            contributions: {\n                balanceAssists: 0,\n                communicationEvents: 0,\n                leadershipActions: 0,\n                supportActions: 0\n            },\n            performance: {\n                accuracy: 0.5,\n                consistency: 0.5,\n                cooperation: 0.5,\n                leadership: 0.5\n            },\n            status: 'active', // 'active', 'inactive', 'disconnected'\n            lastActivity: Date.now()\n        };\n        \n        this.players.set(playerId, player);\n        this.currentPlayerCount = this.players.size;\n        \n        // ê²Œì„ ëª¨ë“œ ì—…ë°ì´íŠ¸\n        this.updateGameMode();\n        \n        // ì—­í•  í• ë‹¹\n        if (this.balancingConfig.roleSystem.enabled && this.balancingConfig.roleSystem.autoAssign) {\n            this.assignRole(playerId);\n        }\n        \n        // ë°¸ëŸ°ì‹± ì¬ê³„ì‚°\n        this.recalculateBalance();\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.triggerEvent('onPlayerJoin', { playerId, player, playerCount: this.currentPlayerCount });\n        \n        console.log(`ğŸ‘¥ í”Œë ˆì´ì–´ ì¶”ê°€: ${player.name} (ì´ ${this.currentPlayerCount}ëª…)`);\n        return true;\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ ì œê±°\n     */\n    removePlayer(playerId) {\n        const player = this.players.get(playerId);\n        if (!player) {\n            console.warn(`ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í”Œë ˆì´ì–´: ${playerId}`);\n            return false;\n        }\n        \n        this.players.delete(playerId);\n        this.currentPlayerCount = this.players.size;\n        \n        // ê²Œì„ ëª¨ë“œ ì—…ë°ì´íŠ¸\n        this.updateGameMode();\n        \n        // ì—­í•  ì¬í• ë‹¹\n        if (this.balancingConfig.roleSystem.enabled) {\n            this.reassignRoles();\n        }\n        \n        // ë°¸ëŸ°ì‹± ì¬ê³„ì‚°\n        this.recalculateBalance();\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.triggerEvent('onPlayerLeave', { playerId, player, playerCount: this.currentPlayerCount });\n        \n        console.log(`ğŸ‘¥ í”Œë ˆì´ì–´ ì œê±°: ${player.name} (ì´ ${this.currentPlayerCount}ëª…)`);\n        return true;\n    }\n    \n    /**\n     * ê²Œì„ ëª¨ë“œ ì—…ë°ì´íŠ¸\n     */\n    updateGameMode() {\n        if (this.currentPlayerCount <= 1) {\n            this.gameState.gameMode = 'solo';\n            this.gameState.isMultiplayer = false;\n        } else {\n            this.gameState.gameMode = 'coop';\n            this.gameState.isMultiplayer = true;\n        }\n    }\n    \n    /**\n     * ì—­í•  í• ë‹¹\n     */\n    assignRole(playerId) {\n        const player = this.players.get(playerId);\n        if (!player) return false;\n        \n        const availableRoles = this.getAvailableRoles();\n        if (availableRoles.length === 0) {\n            console.warn('í• ë‹¹ ê°€ëŠ¥í•œ ì—­í• ì´ ì—†ìŠµë‹ˆë‹¤.');\n            return false;\n        }\n        \n        // í”Œë ˆì´ì–´ ì„±í–¥ì— ë”°ë¥¸ ì—­í•  ì„ íƒ\n        const bestRole = this.selectBestRole(player, availableRoles);\n        player.role = bestRole;\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.triggerEvent('onRoleAssign', { playerId, role: bestRole, player });\n        \n        console.log(`ğŸ­ ì—­í•  í• ë‹¹: ${player.name} â†’ ${bestRole}`);\n        return true;\n    }\n    \n    /**\n     * ì‚¬ìš© ê°€ëŠ¥í•œ ì—­í•  ëª©ë¡ ê°€ì ¸ì˜¤ê¸°\n     */\n    getAvailableRoles() {\n        const allRoles = this.balancingConfig.roleSystem.roles;\n        const assignedRoles = Array.from(this.players.values()).map(p => p.role).filter(r => r);\n        \n        return allRoles.filter(role => !assignedRoles.includes(role));\n    }\n    \n    /**\n     * ìµœì  ì—­í•  ì„ íƒ\n     */\n    selectBestRole(player, availableRoles) {\n        // í”Œë ˆì´ì–´ ì„±ê³¼ì— ë”°ë¥¸ ì—­í•  ì ìˆ˜ ê³„ì‚°\n        const roleScores = {};\n        \n        availableRoles.forEach(role => {\n            switch (role) {\n                case 'leader':\n                    roleScores[role] = player.performance.leadership * 0.6 + \n                                      player.performance.cooperation * 0.4;\n                    break;\n                case 'supporter':\n                    roleScores[role] = player.performance.cooperation * 0.7 + \n                                      player.performance.consistency * 0.3;\n                    break;\n                case 'stabilizer':\n                    roleScores[role] = player.performance.consistency * 0.6 + \n                                      player.performance.accuracy * 0.4;\n                    break;\n                case 'navigator':\n                    roleScores[role] = player.performance.accuracy * 0.6 + \n                                      player.performance.leadership * 0.4;\n                    break;\n                default:\n                    roleScores[role] = 0.5;\n            }\n        });\n        \n        // ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ ì—­í•  ì„ íƒ\n        return Object.keys(roleScores).reduce((a, b) => roleScores[a] > roleScores[b] ? a : b);\n    }\n    \n    /**\n     * ì—­í•  ì¬í• ë‹¹\n     */\n    reassignRoles() {\n        // ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì—­í•  ì´ˆê¸°í™”\n        this.players.forEach(player => {\n            player.role = null;\n        });\n        \n        // ì—­í•  ì¬í• ë‹¹\n        this.players.forEach((player, playerId) => {\n            this.assignRole(playerId);\n        });\n    }\n    \n    /**\n     * ë°¸ëŸ°ì‹± ì¬ê³„ì‚°\n     */\n    recalculateBalance() {\n        const playerCount = this.currentPlayerCount;\n        const multipliers = this.balancingConfig.playerCountMultipliers[playerCount] || \n                           this.balancingConfig.playerCountMultipliers[1];\n        \n        // ë°¸ëŸ°ì‹± ì„¤ì • ì—…ë°ì´íŠ¸\n        this.currentBalance = {\n            difficultyMultiplier: multipliers.difficulty,\n            cooperationLevel: multipliers.cooperation,\n            timeLimitMultiplier: multipliers.timeLimit,\n            cakeStabilityMultiplier: multipliers.cakeStability,\n            playerCount: playerCount\n        };\n        \n        // ë°¸ëŸ°ì‹± íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸\n        this.gameState.balanceHistory.push({\n            timestamp: Date.now(),\n            playerCount: playerCount,\n            balance: { ...this.currentBalance }\n        });\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.triggerEvent('onBalanceChange', { \n            playerCount, \n            balance: this.currentBalance \n        });\n        \n        console.log(`âš–ï¸ ë°¸ëŸ°ì‹± ì¬ê³„ì‚° ì™„ë£Œ (${playerCount}ëª…): ë‚œì´ë„ ${multipliers.difficulty}x`);\n    }\n    \n    /**\n     * í˜‘ë™ ì´ë²¤íŠ¸ ê¸°ë¡\n     */\n    recordCooperationEvent(eventType, playerId, data = {}) {\n        const player = this.players.get(playerId);\n        if (!player) return;\n        \n        // í˜‘ë™ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸\n        switch (eventType) {\n            case 'synchronized_action':\n                this.cooperationMetrics.synchronizedActions++;\n                player.contributions.supportActions++;\n                break;\n            case 'mutual_assistance':\n                this.cooperationMetrics.mutualAssistance++;\n                player.contributions.balanceAssists++;\n                break;\n            case 'communication':\n                this.cooperationMetrics.communicationEvents++;\n                player.contributions.communicationEvents++;\n                break;\n            case 'balance_recovery':\n                this.cooperationMetrics.balanceRecoveries++;\n                player.contributions.balanceAssists++;\n                break;\n            case 'shared_decision':\n                this.cooperationMetrics.sharedDecisions++;\n                player.contributions.leadershipActions++;\n                break;\n        }\n        \n        // í˜‘ë™ ìˆ˜ì¤€ ê³„ì‚°\n        this.calculateCooperationLevel();\n        \n        // í”Œë ˆì´ì–´ ì„±ê³¼ ì—…ë°ì´íŠ¸\n        this.updatePlayerPerformance(playerId, eventType, data);\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.triggerEvent('onCooperationEvent', {\n            eventType,\n            playerId,\n            player,\n            data,\n            cooperationLevel: this.gameState.cooperationLevel\n        });\n        \n        console.log(`ğŸ¤ í˜‘ë™ ì´ë²¤íŠ¸: ${eventType} by ${player.name}`);\n    }\n    \n    /**\n     * í˜‘ë™ ìˆ˜ì¤€ ê³„ì‚°\n     */\n    calculateCooperationLevel() {\n        if (this.currentPlayerCount <= 1) {\n            this.gameState.cooperationLevel = 0.0;\n            return;\n        }\n        \n        const totalEvents = Object.values(this.cooperationMetrics).reduce((sum, count) => sum + count, 0);\n        const expectedEvents = this.currentPlayerCount * 10; // í”Œë ˆì´ì–´ë‹¹ ì˜ˆìƒ ì´ë²¤íŠ¸ ìˆ˜\n        \n        // í˜‘ë™ ìˆ˜ì¤€ ê³„ì‚° (0-1 ë²”ìœ„)\n        this.gameState.cooperationLevel = Math.min(1.0, totalEvents / expectedEvents);\n        \n        // ì†Œí†µ ì ìˆ˜ ê³„ì‚°\n        this.gameState.communicationScore = Math.min(1.0, \n            this.cooperationMetrics.communicationEvents / (this.currentPlayerCount * 5)\n        );\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ ì„±ê³¼ ì—…ë°ì´íŠ¸\n     */\n    updatePlayerPerformance(playerId, eventType, data) {\n        const player = this.players.get(playerId);\n        if (!player) return;\n        \n        const performanceUpdate = 0.05; // ì„±ê³¼ ì—…ë°ì´íŠ¸ í¬ê¸°\n        \n        switch (eventType) {\n            case 'synchronized_action':\n                player.performance.cooperation = Math.min(1.0, \n                    player.performance.cooperation + performanceUpdate);\n                break;\n            case 'mutual_assistance':\n                player.performance.cooperation = Math.min(1.0, \n                    player.performance.cooperation + performanceUpdate);\n                player.performance.leadership = Math.min(1.0, \n                    player.performance.leadership + performanceUpdate * 0.5);\n                break;\n            case 'communication':\n                player.performance.cooperation = Math.min(1.0, \n                    player.performance.cooperation + performanceUpdate);\n                break;\n            case 'balance_recovery':\n                player.performance.accuracy = Math.min(1.0, \n                    player.performance.accuracy + performanceUpdate);\n                player.performance.consistency = Math.min(1.0, \n                    player.performance.consistency + performanceUpdate * 0.5);\n                break;\n            case 'shared_decision':\n                player.performance.leadership = Math.min(1.0, \n                    player.performance.leadership + performanceUpdate);\n                break;\n        }\n        \n        player.lastActivity = Date.now();\n    }\n    \n    /**\n     * íŒ€ ì ìˆ˜ ê³„ì‚°\n     */\n    calculateTeamScore() {\n        let teamScore = 0;\n        let individualScores = 0;\n        \n        // ê°œì¸ ì ìˆ˜ í•©ê³„\n        this.players.forEach(player => {\n            individualScores += player.score;\n        });\n        \n        teamScore = individualScores;\n        \n        // í˜‘ë™ ë³´ë„ˆìŠ¤\n        if (this.balancingConfig.scoreSystem.cooperationBonus > 0) {\n            const cooperationBonus = individualScores * \n                this.balancingConfig.scoreSystem.cooperationBonus * \n                this.gameState.cooperationLevel;\n            teamScore += cooperationBonus;\n        }\n        \n        // ë¦¬ë”ì‹­ ë³´ë„ˆìŠ¤\n        if (this.balancingConfig.scoreSystem.leadershipBonus > 0) {\n            const leaderPlayer = Array.from(this.players.values()).find(p => p.role === 'leader');\n            if (leaderPlayer) {\n                const leadershipBonus = individualScores * \n                    this.balancingConfig.scoreSystem.leadershipBonus * \n                    leaderPlayer.performance.leadership;\n                teamScore += leadershipBonus;\n            }\n        }\n        \n        // ì¼ê´€ì„± ë³´ë„ˆìŠ¤\n        if (this.balancingConfig.scoreSystem.consistencyBonus > 0) {\n            const avgConsistency = Array.from(this.players.values())\n                .reduce((sum, p) => sum + p.performance.consistency, 0) / this.players.size;\n            const consistencyBonus = individualScores * \n                this.balancingConfig.scoreSystem.consistencyBonus * \n                avgConsistency;\n            teamScore += consistencyBonus;\n        }\n        \n        this.gameState.teamScore = Math.round(teamScore);\n        return this.gameState.teamScore;\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ ì ìˆ˜ ì—…ë°ì´íŠ¸\n     */\n    updatePlayerScore(playerId, scoreChange) {\n        const player = this.players.get(playerId);\n        if (!player) return false;\n        \n        player.score += scoreChange;\n        player.score = Math.max(0, player.score);\n        \n        // íŒ€ ì ìˆ˜ ì¬ê³„ì‚°\n        this.calculateTeamScore();\n        \n        return true;\n    }\n    \n    /**\n     * í˜„ì¬ ë°¸ëŸ°ì‹± ì„¤ì • ê°€ì ¸ì˜¤ê¸°\n     */\n    getCurrentBalance() {\n        return {\n            ...this.currentBalance,\n            cooperationLevel: this.gameState.cooperationLevel,\n            communicationScore: this.gameState.communicationScore,\n            teamScore: this.gameState.teamScore\n        };\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°\n     */\n    getPlayers() {\n        return Array.from(this.players.values());\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ ì •ë³´ ê°€ì ¸ì˜¤ê¸°\n     */\n    getPlayer(playerId) {\n        return this.players.get(playerId);\n    }\n    \n    /**\n     * ê²Œì„ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°\n     */\n    getGameState() {\n        return {\n            ...this.gameState,\n            playerCount: this.currentPlayerCount,\n            players: this.getPlayers()\n        };\n    }\n    \n    /**\n     * í˜‘ë™ ë©”íŠ¸ë¦­ ê°€ì ¸ì˜¤ê¸°\n     */\n    getCooperationMetrics() {\n        return {\n            ...this.cooperationMetrics,\n            cooperationLevel: this.gameState.cooperationLevel,\n            communicationScore: this.gameState.communicationScore\n        };\n    }\n    \n    /**\n     * ë¼ìš´ë“œ ì‹œì‘\n     */\n    startRound(roundNumber) {\n        this.gameState.currentRound = roundNumber;\n        \n        // í˜‘ë™ ë©”íŠ¸ë¦­ ì´ˆê¸°í™”\n        this.cooperationMetrics = {\n            synchronizedActions: 0,\n            mutualAssistance: 0,\n            communicationEvents: 0,\n            balanceRecoveries: 0,\n            sharedDecisions: 0\n        };\n        \n        // í”Œë ˆì´ì–´ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸\n        this.players.forEach(player => {\n            player.lastActivity = Date.now();\n        });\n        \n        console.log(`ğŸ® ë¼ìš´ë“œ ${roundNumber} ì‹œì‘ (${this.currentPlayerCount}ëª…)`);\n    }\n    \n    /**\n     * ë¼ìš´ë“œ ì¢…ë£Œ\n     */\n    endRound() {\n        // íŒ€ ì ìˆ˜ ê³„ì‚°\n        this.calculateTeamScore();\n        \n        // ì—­í•  ìˆœí™˜ (ì„¤ì •ëœ ê²½ìš°)\n        if (this.balancingConfig.roleSystem.roleRotation && this.currentPlayerCount > 1) {\n            this.rotateRoles();\n        }\n        \n        console.log(`ğŸ ë¼ìš´ë“œ ${this.gameState.currentRound} ì¢…ë£Œ - íŒ€ ì ìˆ˜: ${this.gameState.teamScore}`);\n    }\n    \n    /**\n     * ì—­í•  ìˆœí™˜\n     */\n    rotateRoles() {\n        const players = Array.from(this.players.values());\n        const roles = players.map(p => p.role).filter(r => r);\n        \n        if (roles.length <= 1) return;\n        \n        // ì—­í•  ìˆœí™˜\n        const rotatedRoles = [roles[roles.length - 1], ...roles.slice(0, -1)];\n        \n        players.forEach((player, index) => {\n            if (index < rotatedRoles.length) {\n                player.role = rotatedRoles[index];\n                this.triggerEvent('onRoleAssign', { \n                    playerId: player.id, \n                    role: player.role, \n                    player \n                });\n            }\n        });\n        \n        console.log('ğŸ”„ ì—­í•  ìˆœí™˜ ì™„ë£Œ');\n    }\n    \n    /**\n     * í”Œë ˆì´ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸\n     */\n    updatePlayerStatus(playerId, status) {\n        const player = this.players.get(playerId);\n        if (!player) return false;\n        \n        player.status = status;\n        player.lastActivity = Date.now();\n        \n        // ë¹„í™œì„± í”Œë ˆì´ì–´ ì²˜ë¦¬\n        if (status === 'inactive' || status === 'disconnected') {\n            this.handleInactivePlayer(playerId);\n        }\n        \n        return true;\n    }\n    \n    /**\n     * ë¹„í™œì„± í”Œë ˆì´ì–´ ì²˜ë¦¬\n     */\n    handleInactivePlayer(playerId) {\n        const player = this.players.get(playerId);\n        if (!player) return;\n        \n        console.log(`âš ï¸ ë¹„í™œì„± í”Œë ˆì´ì–´: ${player.name}`);\n        \n        // ì—­í•  ì¬í• ë‹¹ (í•„ìš”í•œ ê²½ìš°)\n        if (player.role && this.balancingConfig.roleSystem.enabled) {\n            player.role = null;\n            this.reassignRoles();\n        }\n        \n        // ë°¸ëŸ°ì‹± ì¬ê³„ì‚° (í”Œë ˆì´ì–´ê°€ ì™„ì „íˆ ì œê±°ë˜ì§€ ì•Šì€ ê²½ìš°)\n        if (player.status !== 'disconnected') {\n            this.recalculateBalance();\n        }\n    }\n    \n    /**\n     * ì„¤ì • ì—…ë°ì´íŠ¸\n     */\n    updateConfig(newConfig) {\n        this.balancingConfig = { ...this.balancingConfig, ...newConfig };\n        \n        // ì„¤ì • ë³€ê²½ì— ë”°ë¥¸ ì¬ê³„ì‚°\n        this.recalculateBalance();\n        \n        if (this.balancingConfig.roleSystem.enabled) {\n            this.reassignRoles();\n        }\n        \n        console.log('âš™ï¸ ë©€í‹°í”Œë ˆì´ì–´ ë°¸ëŸ°ì‹± ì„¤ì • ì—…ë°ì´íŠ¸');\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡\n     */\n    addEventListener(eventType, callback) {\n        if (this.eventListeners[eventType] && typeof callback === 'function') {\n            this.eventListeners[eventType].push(callback);\n        }\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°\n     */\n    removeEventListener(eventType, callback) {\n        if (this.eventListeners[eventType]) {\n            this.eventListeners[eventType] = this.eventListeners[eventType]\n                .filter(listener => listener !== callback);\n        }\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë°œìƒ\n     */\n    triggerEvent(eventType, data) {\n        if (this.eventListeners[eventType]) {\n            this.eventListeners[eventType].forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì‹¤í–‰ ì˜¤ë¥˜ (${eventType}):`, error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * ì‹œìŠ¤í…œ ë¦¬ì…‹\n     */\n    reset() {\n        this.players.clear();\n        this.currentPlayerCount = 0;\n        \n        this.gameState = {\n            isMultiplayer: false,\n            gameMode: 'solo',\n            currentRound: 1,\n            totalRounds: 3,\n            teamScore: 0,\n            cooperationLevel: 0.0,\n            communicationScore: 0.0,\n            balanceHistory: []\n        };\n        \n        this.cooperationMetrics = {\n            synchronizedActions: 0,\n            mutualAssistance: 0,\n            communicationEvents: 0,\n            balanceRecoveries: 0,\n            sharedDecisions: 0\n        };\n        \n        this.updateGameMode();\n        this.recalculateBalance();\n        \n        console.log('ğŸ”„ ë©€í‹°í”Œë ˆì´ì–´ ë°¸ëŸ°ì‹± ì‹œìŠ¤í…œ ë¦¬ì…‹ ì™„ë£Œ');\n    }\n    \n    /**\n     * ì‹œìŠ¤í…œ ì •ë¦¬\n     */\n    dispose() {\n        this.reset();\n        \n        this.eventListeners = {\n            onPlayerJoin: [],\n            onPlayerLeave: [],\n            onRoleAssign: [],\n            onCooperationEvent: [],\n            onBalanceChange: []\n        };\n        \n        console.log('ğŸ§¹ ë©€í‹°í”Œë ˆì´ì–´ ë°¸ëŸ°ì‹± ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ');\n    }\n}