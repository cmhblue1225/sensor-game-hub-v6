/**
 * 브라우저 호환성 및 접근성 테스트
 * 다양한 브라우저와 접근성 기능을 테스트합니다.
 */

// 브라우저 호환성 테스트
describe('브라우저 호환성 테스트', () => {
    let userAgent;
    let browserInfo;
    
    beforeEach(() => {
        userAgent = navigator.userAgent;
        browserInfo = {
            isChrome: /Chrome/.test(userAgent),
            isFirefox: /Firefox/.test(userAgent),
            isSafari: /Safari/.test(userAgent) && !/Chrome/.test(userAgent),
            isEdge: /Edge/.test(userAgent),
            isMobile: /Mobile|Android|iPhone|iPad/.test(userAgent),
            isIOS: /iPhone|iPad/.test(userAgent),
            isAndroid: /Android/.test(userAgent)
        };
        
        console.log('브라우저 정보:', browserInfo);
    });
    
    it('필수 웹 API가 지원되어야 함', () => {
        // WebGL 지원 확인\n        const canvas = document.createElement('canvas');\n        const webglContext = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n        expect(webglContext).toBeTruthy();\n        \n        // Web Audio API 지원 확인\n        expect(window.AudioContext || window.webkitAudioContext).toBeDefined();\n        \n        // DeviceOrientationEvent 지원 확인\n        expect(window.DeviceOrientationEvent).toBeDefined();\n        \n        // DeviceMotionEvent 지원 확인\n        expect(window.DeviceMotionEvent).toBeDefined();\n        \n        // requestAnimationFrame 지원 확인\n        expect(window.requestAnimationFrame).toBeDefined();\n        \n        // localStorage 지원 확인\n        expect(window.localStorage).toBeDefined();\n        \n        console.log('✅ 모든 필수 웹 API가 지원됩니다.');\n    });\n    \n    it('Three.js가 정상적으로 로드되어야 함', () => {\n        expect(window.THREE).toBeDefined();\n        expect(THREE.WebGLRenderer).toBeDefined();\n        expect(THREE.Scene).toBeDefined();\n        expect(THREE.PerspectiveCamera).toBeDefined();\n        expect(THREE.Mesh).toBeDefined();\n        \n        console.log('✅ Three.js가 정상적으로 로드되었습니다.');\n    });\n    \n    it('Cannon.js가 정상적으로 로드되어야 함', () => {\n        expect(window.CANNON).toBeDefined();\n        expect(CANNON.World).toBeDefined();\n        expect(CANNON.Body).toBeDefined();\n        expect(CANNON.Shape).toBeDefined();\n        \n        console.log('✅ Cannon.js가 정상적으로 로드되었습니다.');\n    });\n    \n    it('모바일 브라우저에서 센서 API가 작동해야 함', async () => {\n        if (!browserInfo.isMobile) {\n            console.log('⏭️ 데스크톱 환경에서는 센서 테스트를 건너뜁니다.');\n            return;\n        }\n        \n        // iOS에서 권한 요청이 필요한지 확인\n        if (browserInfo.isIOS && typeof DeviceOrientationEvent.requestPermission === 'function') {\n            try {\n                const permission = await DeviceOrientationEvent.requestPermission();\n                expect(permission).toBe('granted');\n            } catch (error) {\n                console.warn('센서 권한 요청 실패:', error);\n                // 권한이 거부되어도 테스트는 계속 진행\n            }\n        }\n        \n        // 센서 이벤트 리스너 등록 테스트\n        let orientationEventFired = false;\n        let motionEventFired = false;\n        \n        const orientationHandler = () => {\n            orientationEventFired = true;\n        };\n        \n        const motionHandler = () => {\n            motionEventFired = true;\n        };\n        \n        window.addEventListener('deviceorientation', orientationHandler);\n        window.addEventListener('devicemotion', motionHandler);\n        \n        // 이벤트 리스너가 등록되었는지 확인\n        expect(orientationHandler).toBeDefined();\n        expect(motionHandler).toBeDefined();\n        \n        // 정리\n        window.removeEventListener('deviceorientation', orientationHandler);\n        window.removeEventListener('devicemotion', motionHandler);\n        \n        console.log('✅ 모바일 센서 API 호환성 확인 완료');\n    });\n    \n    it('터치 이벤트가 지원되어야 함', () => {\n        if (!browserInfo.isMobile) {\n            console.log('⏭️ 데스크톱 환경에서는 터치 테스트를 건너뜁니다.');\n            return;\n        }\n        \n        // 터치 이벤트 지원 확인\n        expect('ontouchstart' in window).toBeTruthy();\n        expect('ontouchmove' in window).toBeTruthy();\n        expect('ontouchend' in window).toBeTruthy();\n        \n        // Touch 생성자 확인\n        expect(window.Touch).toBeDefined();\n        expect(window.TouchEvent).toBeDefined();\n        \n        console.log('✅ 터치 이벤트가 지원됩니다.');\n    });\n    \n    it('CSS 기능이 지원되어야 함', () => {\n        const testElement = document.createElement('div');\n        const style = testElement.style;\n        \n        // CSS Transform 지원 확인\n        const transformProperties = ['transform', 'webkitTransform', 'mozTransform', 'msTransform'];\n        const supportsTransform = transformProperties.some(prop => prop in style);\n        expect(supportsTransform).toBeTruthy();\n        \n        // CSS Transition 지원 확인\n        const transitionProperties = ['transition', 'webkitTransition', 'mozTransition', 'msTransition'];\n        const supportsTransition = transitionProperties.some(prop => prop in style);\n        expect(supportsTransition).toBeTruthy();\n        \n        // Flexbox 지원 확인\n        const flexProperties = ['flex', 'webkitFlex', 'mozFlex', 'msFlex'];\n        const supportsFlex = flexProperties.some(prop => prop in style);\n        expect(supportsFlex).toBeTruthy();\n        \n        console.log('✅ 필수 CSS 기능이 지원됩니다.');\n    });\n    \n    it('성능 API가 지원되어야 함', () => {\n        // Performance API 지원 확인\n        expect(window.performance).toBeDefined();\n        expect(performance.now).toBeDefined();\n        \n        // Performance Observer 지원 확인 (선택적)\n        if (window.PerformanceObserver) {\n            console.log('✅ Performance Observer가 지원됩니다.');\n        } else {\n            console.log('⚠️ Performance Observer가 지원되지 않습니다.');\n        }\n        \n        // Memory API 지원 확인 (선택적)\n        if (performance.memory) {\n            console.log('✅ Memory API가 지원됩니다.');\n        } else {\n            console.log('⚠️ Memory API가 지원되지 않습니다.');\n        }\n        \n        console.log('✅ 기본 성능 API가 지원됩니다.');\n    });\n});\n\n// 접근성 테스트\ndescribe('접근성 기능 테스트', () => {\n    let accessibilitySystem;\n    let testContainer;\n    \n    beforeEach(() => {\n        accessibilitySystem = new AccessibilitySystem();\n        \n        // 테스트용 컨테이너 생성\n        testContainer = document.createElement('div');\n        testContainer.id = 'accessibility-test-container';\n        document.body.appendChild(testContainer);\n    });\n    \n    afterEach(() => {\n        if (testContainer && testContainer.parentNode) {\n            testContainer.parentNode.removeChild(testContainer);\n        }\n        \n        if (accessibilitySystem) {\n            accessibilitySystem.cleanup();\n        }\n    });\n    \n    it('고대비 모드가 작동해야 함', async () => {\n        await accessibilitySystem.init(testContainer);\n        \n        // 고대비 모드 활성화\n        accessibilitySystem.enableHighContrast();\n        \n        // 고대비 클래스가 추가되었는지 확인\n        expect(testContainer.classList.contains('high-contrast')).toBeTruthy();\n        \n        // 고대비 모드 비활성화\n        accessibilitySystem.disableHighContrast();\n        \n        // 고대비 클래스가 제거되었는지 확인\n        expect(testContainer.classList.contains('high-contrast')).toBeFalsy();\n        \n        console.log('✅ 고대비 모드 테스트 통과');\n    });\n    \n    it('색맹 지원 기능이 작동해야 함', async () => {\n        await accessibilitySystem.init(testContainer);\n        \n        // 색맹 필터 적용\n        const colorBlindTypes = ['protanopia', 'deuteranopia', 'tritanopia'];\n        \n        for (const type of colorBlindTypes) {\n            accessibilitySystem.applyColorBlindFilter(type);\n            \n            // 필터 클래스가 적용되었는지 확인\n            expect(testContainer.classList.contains(`colorblind-${type}`)).toBeTruthy();\n            \n            // 필터 제거\n            accessibilitySystem.removeColorBlindFilter();\n            expect(testContainer.classList.contains(`colorblind-${type}`)).toBeFalsy();\n        }\n        \n        console.log('✅ 색맹 지원 기능 테스트 통과');\n    });\n    \n    it('키보드 내비게이션이 작동해야 함', async () => {\n        await accessibilitySystem.init(testContainer);\n        \n        // 포커스 가능한 요소들 생성\n        const button1 = document.createElement('button');\n        button1.textContent = '버튼 1';\n        button1.tabIndex = 0;\n        \n        const button2 = document.createElement('button');\n        button2.textContent = '버튼 2';\n        button2.tabIndex = 0;\n        \n        testContainer.appendChild(button1);\n        testContainer.appendChild(button2);\n        \n        // 키보드 내비게이션 활성화\n        accessibilitySystem.enableKeyboardNavigation();\n        \n        // Tab 키 이벤트 시뮬레이션\n        const tabEvent = new KeyboardEvent('keydown', {\n            key: 'Tab',\n            code: 'Tab',\n            keyCode: 9\n        });\n        \n        document.dispatchEvent(tabEvent);\n        \n        // 포커스 관리가 작동하는지 확인\n        expect(accessibilitySystem.isKeyboardNavigationEnabled()).toBeTruthy();\n        \n        console.log('✅ 키보드 내비게이션 테스트 통과');\n    });\n    \n    it('스크린 리더 지원이 작동해야 함', async () => {\n        await accessibilitySystem.init(testContainer);\n        \n        // ARIA 레이블 테스트\n        const gameArea = document.createElement('div');\n        gameArea.setAttribute('role', 'application');\n        gameArea.setAttribute('aria-label', '케이크 배달 게임');\n        testContainer.appendChild(gameArea);\n        \n        // 라이브 리전 테스트\n        const liveRegion = document.createElement('div');\n        liveRegion.setAttribute('aria-live', 'polite');\n        liveRegion.setAttribute('aria-atomic', 'true');\n        testContainer.appendChild(liveRegion);\n        \n        // 스크린 리더 알림 테스트\n        accessibilitySystem.announceToScreenReader('게임이 시작되었습니다.');\n        \n        // ARIA 속성이 올바르게 설정되었는지 확인\n        expect(gameArea.getAttribute('role')).toBe('application');\n        expect(gameArea.getAttribute('aria-label')).toBe('케이크 배달 게임');\n        expect(liveRegion.getAttribute('aria-live')).toBe('polite');\n        \n        console.log('✅ 스크린 리더 지원 테스트 통과');\n    });\n    \n    it('폰트 크기 조절이 작동해야 함', async () => {\n        await accessibilitySystem.init(testContainer);\n        \n        // 테스트 텍스트 요소 생성\n        const textElement = document.createElement('p');\n        textElement.textContent = '테스트 텍스트';\n        testContainer.appendChild(textElement);\n        \n        // 초기 폰트 크기 확인\n        const initialFontSize = window.getComputedStyle(textElement).fontSize;\n        \n        // 폰트 크기 증가\n        accessibilitySystem.increaseFontSize();\n        const increasedFontSize = window.getComputedStyle(textElement).fontSize;\n        \n        // 폰트 크기가 증가했는지 확인\n        expect(parseFloat(increasedFontSize)).toBeGreaterThan(parseFloat(initialFontSize));\n        \n        // 폰트 크기 감소\n        accessibilitySystem.decreaseFontSize();\n        const decreasedFontSize = window.getComputedStyle(textElement).fontSize;\n        \n        // 폰트 크기가 원래대로 돌아왔는지 확인\n        expect(parseFloat(decreasedFontSize)).toBeCloseTo(parseFloat(initialFontSize), 1);\n        \n        console.log('✅ 폰트 크기 조절 테스트 통과');\n    });\n    \n    it('햅틱 피드백이 지원되어야 함', async () => {\n        if (!navigator.vibrate) {\n            console.log('⏭️ 햅틱 피드백이 지원되지 않는 환경입니다.');\n            return;\n        }\n        \n        await accessibilitySystem.init(testContainer);\n        \n        // 햅틱 피드백 테스트\n        const vibrationSupported = accessibilitySystem.testHapticFeedback();\n        expect(vibrationSupported).toBeTruthy();\n        \n        // 다양한 햅틱 패턴 테스트\n        const patterns = {\n            success: [100, 50, 100],\n            error: [200, 100, 200, 100, 200],\n            warning: [150]\n        };\n        \n        for (const [type, pattern] of Object.entries(patterns)) {\n            const result = accessibilitySystem.triggerHapticFeedback(type, pattern);\n            expect(result).toBeTruthy();\n        }\n        \n        console.log('✅ 햅틱 피드백 테스트 통과');\n    });\n});\n\n// 네트워크 및 연결성 테스트\ndescribe('네트워크 연결성 테스트', () => {\n    it('온라인/오프라인 상태를 감지해야 함', () => {\n        // Navigator.onLine 지원 확인\n        expect(navigator.onLine).toBeDefined();\n        \n        // 온라인 이벤트 리스너 테스트\n        let onlineEventFired = false;\n        let offlineEventFired = false;\n        \n        const onlineHandler = () => {\n            onlineEventFired = true;\n        };\n        \n        const offlineHandler = () => {\n            offlineEventFired = true;\n        };\n        \n        window.addEventListener('online', onlineHandler);\n        window.addEventListener('offline', offlineHandler);\n        \n        // 이벤트 리스너가 등록되었는지 확인\n        expect(onlineHandler).toBeDefined();\n        expect(offlineHandler).toBeDefined();\n        \n        // 정리\n        window.removeEventListener('online', onlineHandler);\n        window.removeEventListener('offline', offlineHandler);\n        \n        console.log('✅ 네트워크 상태 감지 테스트 통과');\n    });\n    \n    it('WebSocket 연결이 지원되어야 함', () => {\n        // WebSocket 지원 확인\n        expect(window.WebSocket).toBeDefined();\n        \n        // WebSocket 생성 테스트 (실제 연결은 하지 않음)\n        try {\n            const testSocket = new WebSocket('ws://localhost:3000');\n            expect(testSocket).toBeDefined();\n            testSocket.close();\n        } catch (error) {\n            // 연결 실패는 예상되는 상황 (테스트 환경)\n            console.log('WebSocket 생성자는 사용 가능하지만 연결은 실패했습니다.');\n        }\n        \n        console.log('✅ WebSocket 지원 테스트 통과');\n    });\n});