/**
 * 충돌 감지 시스템
 * 고급 충돌 감지, 분석 및 반응 처리
 */
class CollisionDetectionSystem {
    constructor(physicsManager) {
        this.physicsManager = physicsManager;
        
        // 충돌 이벤트 저장소
        this.collisionEvents = [];
        
        // 충돌 통계
        this.collisionStats = {
            totalCollisions: 0,
            cakeCollisions: 0,
            characterCollisions: 0,
            environmentCollisions: 0,
            averageImpactForce: 0
        };
        
        // 충돌 임계값
        this.thresholds = {
            minImpactVelocity: 0.5,
            damageThreshold: 2.0,
            soundThreshold: 1.0,
            particleThreshold: 1.5,
            shakeThreshold: 3.0
        };
        
        // 충돌 효과 설정
        this.effects = {
            sound: {
                enabled: true,
                volume: 0.7,
                pitchVariation: 0.2
            },
            particles: {
                enabled: true,
                intensity: 1.0,
                duration: 2.0
            },
            camera: {
                shakeEnabled: true,
                shakeIntensity: 0.3,
                shakeDuration: 0.5
            },
            haptic: {
                enabled: true,
                intensity: 0.8,
                duration: 100
            }
        };
        
        // 충돌 타입별 처리기
        this.collisionHandlers = new Map();
        
        // 이벤트 리스너
        this.eventListeners = new Map();
        
        // 초기화
        this.init();
        
        console.log('💥 충돌 감지 시스템 초기화 완료');
    }
    
    /**
     * 초기화
     */
    init() {
        // 기본 충돌 처리기 등록
        this.registerCollisionHandlers();
        
        // 물리 월드 이벤트 리스너 설정
        this.setupPhysicsEventListeners();
        
        console.log('✅ 충돌 감지 시스템 초기화 완료');
    }
    
    /**
     * 기본 충돌 처리기 등록
     */
    registerCollisionHandlers() {\n        // 케이크-바닥 충돌\n        this.registerHandler('cake-ground', (collision) => {\n            this.handleCakeGroundCollision(collision);\n        });\n        \n        // 케이크-벽 충돌\n        this.registerHandler('cake-wall', (collision) => {\n            this.handleCakeWallCollision(collision);\n        });\n        \n        // 케이크-케이크 충돌\n        this.registerHandler('cake-cake', (collision) => {\n            this.handleCakeCakeCollision(collision);\n        });\n        \n        // 캐릭터-바닥 충돌\n        this.registerHandler('character-ground', (collision) => {\n            this.handleCharacterGroundCollision(collision);\n        });\n        \n        // 캐릭터-케이크 충돌\n        this.registerHandler('character-cake', (collision) => {\n            this.handleCharacterCakeCollision(collision);\n        });\n        \n        // 환경 오브젝트 충돌\n        this.registerHandler('environment', (collision) => {\n            this.handleEnvironmentCollision(collision);\n        });\n        \n        console.log('🎯 충돌 처리기 등록 완료');\n    }\n    \n    /**\n     * 물리 월드 이벤트 리스너 설정\n     */\n    setupPhysicsEventListeners() {\n        if (!this.physicsManager || !this.physicsManager.world) return;\n        \n        // 충돌 시작 이벤트\n        this.physicsManager.world.addEventListener('beginContact', (event) => {\n            this.handleCollisionBegin(event);\n        });\n        \n        // 충돌 종료 이벤트\n        this.physicsManager.world.addEventListener('endContact', (event) => {\n            this.handleCollisionEnd(event);\n        });\n        \n        // 충돌 중 이벤트\n        this.physicsManager.world.addEventListener('impact', (event) => {\n            this.handleImpact(event);\n        });\n    }\n    \n    /**\n     * 충돌 처리기 등록\n     * @param {string} collisionType - 충돌 타입\n     * @param {Function} handler - 처리 함수\n     */\n    registerHandler(collisionType, handler) {\n        if (!this.collisionHandlers.has(collisionType)) {\n            this.collisionHandlers.set(collisionType, []);\n        }\n        this.collisionHandlers.get(collisionType).push(handler);\n    }\n    \n    /**\n     * 충돌 시작 처리\n     * @param {Object} event - 충돌 이벤트\n     */\n    handleCollisionBegin(event) {\n        const collision = this.analyzeCollision(event);\n        \n        if (collision.impactVelocity < this.thresholds.minImpactVelocity) {\n            return; // 너무 약한 충돌은 무시\n        }\n        \n        // 충돌 이벤트 저장\n        this.collisionEvents.push({\n            ...collision,\n            timestamp: Date.now(),\n            type: 'begin'\n        });\n        \n        // 통계 업데이트\n        this.updateCollisionStats(collision);\n        \n        // 충돌 타입별 처리\n        this.processCollision(collision);\n        \n        // 이벤트 발생\n        this.dispatchEvent('collisionBegin', collision);\n        \n        console.log(`💥 충돌 시작: ${collision.typeA} ↔ ${collision.typeB} (강도: ${collision.impactVelocity.toFixed(2)})`);\n    }\n    \n    /**\n     * 충돌 종료 처리\n     * @param {Object} event - 충돌 이벤트\n     */\n    handleCollisionEnd(event) {\n        const collision = this.analyzeCollision(event);\n        \n        // 충돌 이벤트 저장\n        this.collisionEvents.push({\n            ...collision,\n            timestamp: Date.now(),\n            type: 'end'\n        });\n        \n        // 이벤트 발생\n        this.dispatchEvent('collisionEnd', collision);\n    }\n    \n    /**\n     * 충격 처리\n     * @param {Object} event - 충격 이벤트\n     */\n    handleImpact(event) {\n        const collision = this.analyzeCollision(event);\n        \n        // 강한 충격만 처리\n        if (collision.impactVelocity > this.thresholds.damageThreshold) {\n            this.processHighImpactCollision(collision);\n        }\n    }\n    \n    /**\n     * 충돌 분석\n     * @param {Object} event - 충돌 이벤트\n     * @returns {Object} 분석된 충돌 정보\n     */\n    analyzeCollision(event) {\n        const contact = event.contact;\n        const bodyA = contact.bi;\n        const bodyB = contact.bj;\n        \n        // 바디 정보 추출\n        const infoA = this.extractBodyInfo(bodyA);\n        const infoB = this.extractBodyInfo(bodyB);\n        \n        // 충돌 지점 계산\n        const contactPoint = contact.ri.vadd(bodyA.position);\n        \n        // 충돌 법선 벡터\n        const normal = contact.ni.clone();\n        \n        // 상대 속도 계산\n        const relativeVelocity = bodyA.velocity.vsub(bodyB.velocity);\n        const impactVelocity = Math.abs(relativeVelocity.dot(normal));\n        \n        // 충돌 타입 결정\n        const collisionType = this.determineCollisionType(infoA.type, infoB.type);\n        \n        return {\n            bodyA,\n            bodyB,\n            infoA,\n            infoB,\n            typeA: infoA.type,\n            typeB: infoB.type,\n            collisionType,\n            contactPoint: {\n                x: contactPoint.x,\n                y: contactPoint.y,\n                z: contactPoint.z\n            },\n            normal: {\n                x: normal.x,\n                y: normal.y,\n                z: normal.z\n            },\n            impactVelocity,\n            relativeVelocity: {\n                x: relativeVelocity.x,\n                y: relativeVelocity.y,\n                z: relativeVelocity.z\n            }\n        };\n    }\n    \n    /**\n     * 바디 정보 추출\n     * @param {CANNON.Body} body - 물리 바디\n     * @returns {Object} 바디 정보\n     */\n    extractBodyInfo(body) {\n        const userData = body.userData || {};\n        \n        return {\n            name: userData.name || 'unknown',\n            type: userData.type || 'unknown',\n            mass: body.mass,\n            velocity: body.velocity.length(),\n            position: {\n                x: body.position.x,\n                y: body.position.y,\n                z: body.position.z\n            },\n            userData\n        };\n    }\n    \n    /**\n     * 충돌 타입 결정\n     * @param {string} typeA - 바디 A 타입\n     * @param {string} typeB - 바디 B 타입\n     * @returns {string} 충돌 타입\n     */\n    determineCollisionType(typeA, typeB) {\n        const types = [typeA, typeB].sort();\n        \n        // 특정 조합 확인\n        if (types.includes('cake') && types.includes('ground')) {\n            return 'cake-ground';\n        }\n        if (types.includes('cake') && types.includes('wall')) {\n            return 'cake-wall';\n        }\n        if (types[0] === 'cake' && types[1] === 'cake') {\n            return 'cake-cake';\n        }\n        if (types.includes('character') && types.includes('ground')) {\n            return 'character-ground';\n        }\n        if (types.includes('character') && types.includes('cake')) {\n            return 'character-cake';\n        }\n        \n        return 'environment';\n    }\n    \n    /**\n     * 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    processCollision(collision) {\n        // 충돌 타입별 처리기 실행\n        const handlers = this.collisionHandlers.get(collision.collisionType);\n        if (handlers) {\n            handlers.forEach(handler => {\n                try {\n                    handler(collision);\n                } catch (error) {\n                    console.error('충돌 처리기 오류:', error);\n                }\n            });\n        }\n        \n        // 공통 효과 처리\n        this.processCollisionEffects(collision);\n    }\n    \n    /**\n     * 충돌 효과 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    processCollisionEffects(collision) {\n        const { impactVelocity, contactPoint } = collision;\n        \n        // 사운드 효과\n        if (this.effects.sound.enabled && impactVelocity > this.thresholds.soundThreshold) {\n            this.playCollisionSound(collision);\n        }\n        \n        // 파티클 효과\n        if (this.effects.particles.enabled && impactVelocity > this.thresholds.particleThreshold) {\n            this.createCollisionParticles(collision);\n        }\n        \n        // 카메라 흔들림\n        if (this.effects.camera.shakeEnabled && impactVelocity > this.thresholds.shakeThreshold) {\n            this.triggerCameraShake(collision);\n        }\n        \n        // 햅틱 피드백\n        if (this.effects.haptic.enabled && impactVelocity > this.thresholds.soundThreshold) {\n            this.triggerHapticFeedback(collision);\n        }\n    }\n    \n    /**\n     * 케이크-바닥 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    handleCakeGroundCollision(collision) {\n        const { impactVelocity, bodyA, bodyB } = collision;\n        const cakeBody = bodyA.userData?.name?.includes('cake') ? bodyA : bodyB;\n        \n        if (impactVelocity > this.thresholds.damageThreshold) {\n            // 케이크 손상 처리\n            const damage = Math.floor(impactVelocity / 2);\n            if (cakeBody.userData) {\n                cakeBody.userData.damage = (cakeBody.userData.damage || 0) + damage;\n                \n                console.log(`🎂💥 케이크 바닥 충돌 손상: ${damage}`);\n                \n                // 손상 이벤트 발생\n                this.dispatchEvent('cakeDamage', {\n                    body: cakeBody,\n                    damage,\n                    totalDamage: cakeBody.userData.damage,\n                    cause: 'ground_impact'\n                });\n            }\n        }\n        \n        // 바운스 효과 감소 (케이크가 바닥에서 너무 많이 튀지 않도록)\n        cakeBody.velocity.y *= 0.3;\n    }\n    \n    /**\n     * 케이크-벽 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    handleCakeWallCollision(collision) {\n        const { impactVelocity, bodyA, bodyB, normal } = collision;\n        const cakeBody = bodyA.userData?.name?.includes('cake') ? bodyA : bodyB;\n        \n        // 벽 반사 효과\n        const reflectionForce = new CANNON.Vec3(\n            normal.x * impactVelocity * 0.5,\n            0,\n            normal.z * impactVelocity * 0.5\n        );\n        \n        cakeBody.applyImpulse(reflectionForce, cakeBody.position);\n        \n        // 강한 충돌 시 손상\n        if (impactVelocity > this.thresholds.damageThreshold * 1.5) {\n            const damage = Math.floor(impactVelocity / 3);\n            if (cakeBody.userData) {\n                cakeBody.userData.damage = (cakeBody.userData.damage || 0) + damage;\n                \n                console.log(`🎂🧱 케이크 벽 충돌 손상: ${damage}`);\n            }\n        }\n    }\n    \n    /**\n     * 케이크-케이크 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    handleCakeCakeCollision(collision) {\n        const { impactVelocity, bodyA, bodyB } = collision;\n        \n        // 두 케이크 모두 약간의 손상\n        if (impactVelocity > this.thresholds.damageThreshold) {\n            const damage = Math.floor(impactVelocity / 4);\n            \n            [bodyA, bodyB].forEach(body => {\n                if (body.userData?.name?.includes('cake')) {\n                    body.userData.damage = (body.userData.damage || 0) + damage;\n                }\n            });\n            \n            console.log(`🎂🎂 케이크 간 충돌 손상: ${damage}`);\n        }\n        \n        // 케이크들이 서로 밀어내는 효과\n        const pushForce = impactVelocity * 0.3;\n        const direction = bodyA.position.vsub(bodyB.position).unit();\n        \n        bodyA.applyImpulse(direction.scale(pushForce), bodyA.position);\n        bodyB.applyImpulse(direction.scale(-pushForce), bodyB.position);\n    }\n    \n    /**\n     * 캐릭터-바닥 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    handleCharacterGroundCollision(collision) {\n        const { bodyA, bodyB } = collision;\n        const characterBody = bodyA.userData?.name?.includes('character') ? bodyA : bodyB;\n        \n        // 캐릭터 착지 상태 설정\n        if (characterBody.userData) {\n            characterBody.userData.isGrounded = true;\n            characterBody.userData.lastGroundContact = Date.now();\n        }\n        \n        // 착지 사운드 (약한 충돌)\n        if (collision.impactVelocity > 0.5) {\n            this.dispatchEvent('characterLanded', {\n                body: characterBody,\n                impactVelocity: collision.impactVelocity\n            });\n        }\n    }\n    \n    /**\n     * 캐릭터-케이크 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    handleCharacterCakeCollision(collision) {\n        const { impactVelocity, bodyA, bodyB } = collision;\n        const characterBody = bodyA.userData?.name?.includes('character') ? bodyA : bodyB;\n        const cakeBody = characterBody === bodyA ? bodyB : bodyA;\n        \n        // 캐릭터가 케이크를 밀거나 당기는 상호작용\n        this.dispatchEvent('characterCakeInteraction', {\n            characterBody,\n            cakeBody,\n            impactVelocity,\n            interactionType: impactVelocity > 1.0 ? 'push' : 'touch'\n        });\n        \n        console.log(`👤🎂 캐릭터-케이크 상호작용: ${impactVelocity.toFixed(2)}`);\n    }\n    \n    /**\n     * 환경 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    handleEnvironmentCollision(collision) {\n        // 일반적인 환경 오브젝트 충돌 처리\n        const { impactVelocity } = collision;\n        \n        if (impactVelocity > this.thresholds.soundThreshold) {\n            // 환경 충돌음\n            this.dispatchEvent('environmentCollision', collision);\n        }\n    }\n    \n    /**\n     * 강한 충격 충돌 처리\n     * @param {Object} collision - 충돌 정보\n     */\n    processHighImpactCollision(collision) {\n        const { impactVelocity, contactPoint } = collision;\n        \n        console.log(`💥💥 강한 충격 충돌: ${impactVelocity.toFixed(2)}`);\n        \n        // 강한 파티클 효과\n        this.createHighImpactParticles(collision);\n        \n        // 강한 카메라 흔들림\n        this.triggerStrongCameraShake(collision);\n        \n        // 강한 햅틱 피드백\n        this.triggerStrongHapticFeedback(collision);\n        \n        // 이벤트 발생\n        this.dispatchEvent('highImpactCollision', collision);\n    }\n    \n    /**\n     * 충돌 사운드 재생\n     * @param {Object} collision - 충돌 정보\n     */\n    playCollisionSound(collision) {\n        // 사운드 시스템이 있다면 재생\n        this.dispatchEvent('playCollisionSound', {\n            collisionType: collision.collisionType,\n            intensity: collision.impactVelocity,\n            position: collision.contactPoint\n        });\n    }\n    \n    /**\n     * 충돌 파티클 생성\n     * @param {Object} collision - 충돌 정보\n     */\n    createCollisionParticles(collision) {\n        this.dispatchEvent('createCollisionParticles', {\n            position: collision.contactPoint,\n            intensity: collision.impactVelocity,\n            collisionType: collision.collisionType\n        });\n    }\n    \n    /**\n     * 강한 충격 파티클 생성\n     * @param {Object} collision - 충돌 정보\n     */\n    createHighImpactParticles(collision) {\n        this.dispatchEvent('createHighImpactParticles', {\n            position: collision.contactPoint,\n            intensity: collision.impactVelocity * 2,\n            collisionType: collision.collisionType\n        });\n    }\n    \n    /**\n     * 카메라 흔들림 트리거\n     * @param {Object} collision - 충돌 정보\n     */\n    triggerCameraShake(collision) {\n        const intensity = Math.min(collision.impactVelocity * 0.1, 1.0);\n        \n        this.dispatchEvent('cameraShake', {\n            intensity: intensity * this.effects.camera.shakeIntensity,\n            duration: this.effects.camera.shakeDuration\n        });\n    }\n    \n    /**\n     * 강한 카메라 흔들림 트리거\n     * @param {Object} collision - 충돌 정보\n     */\n    triggerStrongCameraShake(collision) {\n        const intensity = Math.min(collision.impactVelocity * 0.2, 2.0);\n        \n        this.dispatchEvent('cameraShake', {\n            intensity: intensity * this.effects.camera.shakeIntensity,\n            duration: this.effects.camera.shakeDuration * 1.5\n        });\n    }\n    \n    /**\n     * 햅틱 피드백 트리거\n     * @param {Object} collision - 충돌 정보\n     */\n    triggerHapticFeedback(collision) {\n        if ('vibrate' in navigator) {\n            const duration = Math.min(collision.impactVelocity * 20, this.effects.haptic.duration);\n            navigator.vibrate(duration);\n        }\n    }\n    \n    /**\n     * 강한 햅틱 피드백 트리거\n     * @param {Object} collision - 충돌 정보\n     */\n    triggerStrongHapticFeedback(collision) {\n        if ('vibrate' in navigator) {\n            const pattern = [100, 50, 100, 50, 200];\n            navigator.vibrate(pattern);\n        }\n    }\n    \n    /**\n     * 충돌 통계 업데이트\n     * @param {Object} collision - 충돌 정보\n     */\n    updateCollisionStats(collision) {\n        this.collisionStats.totalCollisions++;\n        \n        // 타입별 통계\n        if (collision.collisionType.includes('cake')) {\n            this.collisionStats.cakeCollisions++;\n        }\n        if (collision.collisionType.includes('character')) {\n            this.collisionStats.characterCollisions++;\n        }\n        if (collision.collisionType === 'environment') {\n            this.collisionStats.environmentCollisions++;\n        }\n        \n        // 평균 충격력 계산\n        const totalImpact = this.collisionStats.averageImpactForce * (this.collisionStats.totalCollisions - 1);\n        this.collisionStats.averageImpactForce = (totalImpact + collision.impactVelocity) / this.collisionStats.totalCollisions;\n    }\n    \n    /**\n     * 이벤트 리스너 추가\n     * @param {string} eventType - 이벤트 타입\n     * @param {Function} callback - 콜백 함수\n     */\n    addEventListener(eventType, callback) {\n        if (!this.eventListeners.has(eventType)) {\n            this.eventListeners.set(eventType, []);\n        }\n        this.eventListeners.get(eventType).push(callback);\n    }\n    \n    /**\n     * 이벤트 발생\n     * @param {string} eventType - 이벤트 타입\n     * @param {Object} data - 이벤트 데이터\n     */\n    dispatchEvent(eventType, data) {\n        const listeners = this.eventListeners.get(eventType);\n        if (listeners) {\n            listeners.forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`충돌 이벤트 처리 오류 (${eventType}):`, error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * 충돌 임계값 설정\n     * @param {Object} thresholds - 새로운 임계값\n     */\n    setThresholds(thresholds) {\n        Object.assign(this.thresholds, thresholds);\n        console.log('🎯 충돌 임계값 업데이트:', thresholds);\n    }\n    \n    /**\n     * 효과 설정\n     * @param {Object} effects - 새로운 효과 설정\n     */\n    setEffects(effects) {\n        Object.assign(this.effects, effects);\n        console.log('✨ 충돌 효과 설정 업데이트:', effects);\n    }\n    \n    /**\n     * 충돌 통계 반환\n     * @returns {Object}\n     */\n    getCollisionStats() {\n        return { ...this.collisionStats };\n    }\n    \n    /**\n     * 최근 충돌 이벤트 반환\n     * @param {number} count - 반환할 이벤트 수\n     * @returns {Array}\n     */\n    getRecentCollisions(count = 10) {\n        return this.collisionEvents.slice(-count);\n    }\n    \n    /**\n     * 충돌 통계 초기화\n     */\n    resetStats() {\n        this.collisionStats = {\n            totalCollisions: 0,\n            cakeCollisions: 0,\n            characterCollisions: 0,\n            environmentCollisions: 0,\n            averageImpactForce: 0\n        };\n        \n        this.collisionEvents = [];\n        \n        console.log('📊 충돌 통계 초기화');\n    }\n    \n    /**\n     * 정리\n     */\n    cleanup() {\n        console.log('🧹 충돌 감지 시스템 정리 시작...');\n        \n        // 이벤트 리스너 정리\n        this.eventListeners.clear();\n        \n        // 충돌 처리기 정리\n        this.collisionHandlers.clear();\n        \n        // 충돌 이벤트 정리\n        this.collisionEvents = [];\n        \n        console.log('✅ 충돌 감지 시스템 정리 완료');\n    }\n    \n    /**\n     * 디버그 정보 반환\n     * @returns {Object}\n     */\n    getDebugInfo() {\n        return {\n            collisionStats: this.collisionStats,\n            recentCollisions: this.getRecentCollisions(5),\n            thresholds: this.thresholds,\n            effects: this.effects,\n            handlerCount: this.collisionHandlers.size,\n            listenerCount: this.eventListeners.size\n        };\n    }\n}"