/**
 * ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ
 * ê³ ê¸‰ ì¶©ëŒ ê°ì§€, ë¶„ì„ ë° ë°˜ì‘ ì²˜ë¦¬
 */
class CollisionDetectionSystem {
    constructor(physicsManager) {
        this.physicsManager = physicsManager;
        
        // ì¶©ëŒ ì´ë²¤íŠ¸ ì €ì¥ì†Œ
        this.collisionEvents = [];
        
        // ì¶©ëŒ í†µê³„
        this.collisionStats = {
            totalCollisions: 0,
            cakeCollisions: 0,
            characterCollisions: 0,
            environmentCollisions: 0,
            averageImpactForce: 0
        };
        
        // ì¶©ëŒ ì„ê³„ê°’
        this.thresholds = {
            minImpactVelocity: 0.5,
            damageThreshold: 2.0,
            soundThreshold: 1.0,
            particleThreshold: 1.5,
            shakeThreshold: 3.0
        };
        
        // ì¶©ëŒ íš¨ê³¼ ì„¤ì •
        this.effects = {
            sound: {
                enabled: true,
                volume: 0.7,
                pitchVariation: 0.2
            },
            particles: {
                enabled: true,
                intensity: 1.0,
                duration: 2.0
            },
            camera: {
                shakeEnabled: true,
                shakeIntensity: 0.3,
                shakeDuration: 0.5
            },
            haptic: {
                enabled: true,
                intensity: 0.8,
                duration: 100
            }
        };
        
        // ì¶©ëŒ íƒ€ì…ë³„ ì²˜ë¦¬ê¸°
        this.collisionHandlers = new Map();
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        this.eventListeners = new Map();
        
        // ì´ˆê¸°í™”
        this.init();
        
        console.log('ğŸ’¥ ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
    }
    
    /**
     * ì´ˆê¸°í™”
     */
    init() {
        // ê¸°ë³¸ ì¶©ëŒ ì²˜ë¦¬ê¸° ë“±ë¡
        this.registerCollisionHandlers();
        
        // ë¬¼ë¦¬ ì›”ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        this.setupPhysicsEventListeners();
        
        console.log('âœ… ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
    }
    
    /**
     * ê¸°ë³¸ ì¶©ëŒ ì²˜ë¦¬ê¸° ë“±ë¡
     */
    registerCollisionHandlers() {\n        // ì¼€ì´í¬-ë°”ë‹¥ ì¶©ëŒ\n        this.registerHandler('cake-ground', (collision) => {\n            this.handleCakeGroundCollision(collision);\n        });\n        \n        // ì¼€ì´í¬-ë²½ ì¶©ëŒ\n        this.registerHandler('cake-wall', (collision) => {\n            this.handleCakeWallCollision(collision);\n        });\n        \n        // ì¼€ì´í¬-ì¼€ì´í¬ ì¶©ëŒ\n        this.registerHandler('cake-cake', (collision) => {\n            this.handleCakeCakeCollision(collision);\n        });\n        \n        // ìºë¦­í„°-ë°”ë‹¥ ì¶©ëŒ\n        this.registerHandler('character-ground', (collision) => {\n            this.handleCharacterGroundCollision(collision);\n        });\n        \n        // ìºë¦­í„°-ì¼€ì´í¬ ì¶©ëŒ\n        this.registerHandler('character-cake', (collision) => {\n            this.handleCharacterCakeCollision(collision);\n        });\n        \n        // í™˜ê²½ ì˜¤ë¸Œì íŠ¸ ì¶©ëŒ\n        this.registerHandler('environment', (collision) => {\n            this.handleEnvironmentCollision(collision);\n        });\n        \n        console.log('ğŸ¯ ì¶©ëŒ ì²˜ë¦¬ê¸° ë“±ë¡ ì™„ë£Œ');\n    }\n    \n    /**\n     * ë¬¼ë¦¬ ì›”ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •\n     */\n    setupPhysicsEventListeners() {\n        if (!this.physicsManager || !this.physicsManager.world) return;\n        \n        // ì¶©ëŒ ì‹œì‘ ì´ë²¤íŠ¸\n        this.physicsManager.world.addEventListener('beginContact', (event) => {\n            this.handleCollisionBegin(event);\n        });\n        \n        // ì¶©ëŒ ì¢…ë£Œ ì´ë²¤íŠ¸\n        this.physicsManager.world.addEventListener('endContact', (event) => {\n            this.handleCollisionEnd(event);\n        });\n        \n        // ì¶©ëŒ ì¤‘ ì´ë²¤íŠ¸\n        this.physicsManager.world.addEventListener('impact', (event) => {\n            this.handleImpact(event);\n        });\n    }\n    \n    /**\n     * ì¶©ëŒ ì²˜ë¦¬ê¸° ë“±ë¡\n     * @param {string} collisionType - ì¶©ëŒ íƒ€ì…\n     * @param {Function} handler - ì²˜ë¦¬ í•¨ìˆ˜\n     */\n    registerHandler(collisionType, handler) {\n        if (!this.collisionHandlers.has(collisionType)) {\n            this.collisionHandlers.set(collisionType, []);\n        }\n        this.collisionHandlers.get(collisionType).push(handler);\n    }\n    \n    /**\n     * ì¶©ëŒ ì‹œì‘ ì²˜ë¦¬\n     * @param {Object} event - ì¶©ëŒ ì´ë²¤íŠ¸\n     */\n    handleCollisionBegin(event) {\n        const collision = this.analyzeCollision(event);\n        \n        if (collision.impactVelocity < this.thresholds.minImpactVelocity) {\n            return; // ë„ˆë¬´ ì•½í•œ ì¶©ëŒì€ ë¬´ì‹œ\n        }\n        \n        // ì¶©ëŒ ì´ë²¤íŠ¸ ì €ì¥\n        this.collisionEvents.push({\n            ...collision,\n            timestamp: Date.now(),\n            type: 'begin'\n        });\n        \n        // í†µê³„ ì—…ë°ì´íŠ¸\n        this.updateCollisionStats(collision);\n        \n        // ì¶©ëŒ íƒ€ì…ë³„ ì²˜ë¦¬\n        this.processCollision(collision);\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.dispatchEvent('collisionBegin', collision);\n        \n        console.log(`ğŸ’¥ ì¶©ëŒ ì‹œì‘: ${collision.typeA} â†” ${collision.typeB} (ê°•ë„: ${collision.impactVelocity.toFixed(2)})`);\n    }\n    \n    /**\n     * ì¶©ëŒ ì¢…ë£Œ ì²˜ë¦¬\n     * @param {Object} event - ì¶©ëŒ ì´ë²¤íŠ¸\n     */\n    handleCollisionEnd(event) {\n        const collision = this.analyzeCollision(event);\n        \n        // ì¶©ëŒ ì´ë²¤íŠ¸ ì €ì¥\n        this.collisionEvents.push({\n            ...collision,\n            timestamp: Date.now(),\n            type: 'end'\n        });\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.dispatchEvent('collisionEnd', collision);\n    }\n    \n    /**\n     * ì¶©ê²© ì²˜ë¦¬\n     * @param {Object} event - ì¶©ê²© ì´ë²¤íŠ¸\n     */\n    handleImpact(event) {\n        const collision = this.analyzeCollision(event);\n        \n        // ê°•í•œ ì¶©ê²©ë§Œ ì²˜ë¦¬\n        if (collision.impactVelocity > this.thresholds.damageThreshold) {\n            this.processHighImpactCollision(collision);\n        }\n    }\n    \n    /**\n     * ì¶©ëŒ ë¶„ì„\n     * @param {Object} event - ì¶©ëŒ ì´ë²¤íŠ¸\n     * @returns {Object} ë¶„ì„ëœ ì¶©ëŒ ì •ë³´\n     */\n    analyzeCollision(event) {\n        const contact = event.contact;\n        const bodyA = contact.bi;\n        const bodyB = contact.bj;\n        \n        // ë°”ë”” ì •ë³´ ì¶”ì¶œ\n        const infoA = this.extractBodyInfo(bodyA);\n        const infoB = this.extractBodyInfo(bodyB);\n        \n        // ì¶©ëŒ ì§€ì  ê³„ì‚°\n        const contactPoint = contact.ri.vadd(bodyA.position);\n        \n        // ì¶©ëŒ ë²•ì„  ë²¡í„°\n        const normal = contact.ni.clone();\n        \n        // ìƒëŒ€ ì†ë„ ê³„ì‚°\n        const relativeVelocity = bodyA.velocity.vsub(bodyB.velocity);\n        const impactVelocity = Math.abs(relativeVelocity.dot(normal));\n        \n        // ì¶©ëŒ íƒ€ì… ê²°ì •\n        const collisionType = this.determineCollisionType(infoA.type, infoB.type);\n        \n        return {\n            bodyA,\n            bodyB,\n            infoA,\n            infoB,\n            typeA: infoA.type,\n            typeB: infoB.type,\n            collisionType,\n            contactPoint: {\n                x: contactPoint.x,\n                y: contactPoint.y,\n                z: contactPoint.z\n            },\n            normal: {\n                x: normal.x,\n                y: normal.y,\n                z: normal.z\n            },\n            impactVelocity,\n            relativeVelocity: {\n                x: relativeVelocity.x,\n                y: relativeVelocity.y,\n                z: relativeVelocity.z\n            }\n        };\n    }\n    \n    /**\n     * ë°”ë”” ì •ë³´ ì¶”ì¶œ\n     * @param {CANNON.Body} body - ë¬¼ë¦¬ ë°”ë””\n     * @returns {Object} ë°”ë”” ì •ë³´\n     */\n    extractBodyInfo(body) {\n        const userData = body.userData || {};\n        \n        return {\n            name: userData.name || 'unknown',\n            type: userData.type || 'unknown',\n            mass: body.mass,\n            velocity: body.velocity.length(),\n            position: {\n                x: body.position.x,\n                y: body.position.y,\n                z: body.position.z\n            },\n            userData\n        };\n    }\n    \n    /**\n     * ì¶©ëŒ íƒ€ì… ê²°ì •\n     * @param {string} typeA - ë°”ë”” A íƒ€ì…\n     * @param {string} typeB - ë°”ë”” B íƒ€ì…\n     * @returns {string} ì¶©ëŒ íƒ€ì…\n     */\n    determineCollisionType(typeA, typeB) {\n        const types = [typeA, typeB].sort();\n        \n        // íŠ¹ì • ì¡°í•© í™•ì¸\n        if (types.includes('cake') && types.includes('ground')) {\n            return 'cake-ground';\n        }\n        if (types.includes('cake') && types.includes('wall')) {\n            return 'cake-wall';\n        }\n        if (types[0] === 'cake' && types[1] === 'cake') {\n            return 'cake-cake';\n        }\n        if (types.includes('character') && types.includes('ground')) {\n            return 'character-ground';\n        }\n        if (types.includes('character') && types.includes('cake')) {\n            return 'character-cake';\n        }\n        \n        return 'environment';\n    }\n    \n    /**\n     * ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    processCollision(collision) {\n        // ì¶©ëŒ íƒ€ì…ë³„ ì²˜ë¦¬ê¸° ì‹¤í–‰\n        const handlers = this.collisionHandlers.get(collision.collisionType);\n        if (handlers) {\n            handlers.forEach(handler => {\n                try {\n                    handler(collision);\n                } catch (error) {\n                    console.error('ì¶©ëŒ ì²˜ë¦¬ê¸° ì˜¤ë¥˜:', error);\n                }\n            });\n        }\n        \n        // ê³µí†µ íš¨ê³¼ ì²˜ë¦¬\n        this.processCollisionEffects(collision);\n    }\n    \n    /**\n     * ì¶©ëŒ íš¨ê³¼ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    processCollisionEffects(collision) {\n        const { impactVelocity, contactPoint } = collision;\n        \n        // ì‚¬ìš´ë“œ íš¨ê³¼\n        if (this.effects.sound.enabled && impactVelocity > this.thresholds.soundThreshold) {\n            this.playCollisionSound(collision);\n        }\n        \n        // íŒŒí‹°í´ íš¨ê³¼\n        if (this.effects.particles.enabled && impactVelocity > this.thresholds.particleThreshold) {\n            this.createCollisionParticles(collision);\n        }\n        \n        // ì¹´ë©”ë¼ í”ë“¤ë¦¼\n        if (this.effects.camera.shakeEnabled && impactVelocity > this.thresholds.shakeThreshold) {\n            this.triggerCameraShake(collision);\n        }\n        \n        // í–…í‹± í”¼ë“œë°±\n        if (this.effects.haptic.enabled && impactVelocity > this.thresholds.soundThreshold) {\n            this.triggerHapticFeedback(collision);\n        }\n    }\n    \n    /**\n     * ì¼€ì´í¬-ë°”ë‹¥ ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    handleCakeGroundCollision(collision) {\n        const { impactVelocity, bodyA, bodyB } = collision;\n        const cakeBody = bodyA.userData?.name?.includes('cake') ? bodyA : bodyB;\n        \n        if (impactVelocity > this.thresholds.damageThreshold) {\n            // ì¼€ì´í¬ ì†ìƒ ì²˜ë¦¬\n            const damage = Math.floor(impactVelocity / 2);\n            if (cakeBody.userData) {\n                cakeBody.userData.damage = (cakeBody.userData.damage || 0) + damage;\n                \n                console.log(`ğŸ‚ğŸ’¥ ì¼€ì´í¬ ë°”ë‹¥ ì¶©ëŒ ì†ìƒ: ${damage}`);\n                \n                // ì†ìƒ ì´ë²¤íŠ¸ ë°œìƒ\n                this.dispatchEvent('cakeDamage', {\n                    body: cakeBody,\n                    damage,\n                    totalDamage: cakeBody.userData.damage,\n                    cause: 'ground_impact'\n                });\n            }\n        }\n        \n        // ë°”ìš´ìŠ¤ íš¨ê³¼ ê°ì†Œ (ì¼€ì´í¬ê°€ ë°”ë‹¥ì—ì„œ ë„ˆë¬´ ë§ì´ íŠ€ì§€ ì•Šë„ë¡)\n        cakeBody.velocity.y *= 0.3;\n    }\n    \n    /**\n     * ì¼€ì´í¬-ë²½ ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    handleCakeWallCollision(collision) {\n        const { impactVelocity, bodyA, bodyB, normal } = collision;\n        const cakeBody = bodyA.userData?.name?.includes('cake') ? bodyA : bodyB;\n        \n        // ë²½ ë°˜ì‚¬ íš¨ê³¼\n        const reflectionForce = new CANNON.Vec3(\n            normal.x * impactVelocity * 0.5,\n            0,\n            normal.z * impactVelocity * 0.5\n        );\n        \n        cakeBody.applyImpulse(reflectionForce, cakeBody.position);\n        \n        // ê°•í•œ ì¶©ëŒ ì‹œ ì†ìƒ\n        if (impactVelocity > this.thresholds.damageThreshold * 1.5) {\n            const damage = Math.floor(impactVelocity / 3);\n            if (cakeBody.userData) {\n                cakeBody.userData.damage = (cakeBody.userData.damage || 0) + damage;\n                \n                console.log(`ğŸ‚ğŸ§± ì¼€ì´í¬ ë²½ ì¶©ëŒ ì†ìƒ: ${damage}`);\n            }\n        }\n    }\n    \n    /**\n     * ì¼€ì´í¬-ì¼€ì´í¬ ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    handleCakeCakeCollision(collision) {\n        const { impactVelocity, bodyA, bodyB } = collision;\n        \n        // ë‘ ì¼€ì´í¬ ëª¨ë‘ ì•½ê°„ì˜ ì†ìƒ\n        if (impactVelocity > this.thresholds.damageThreshold) {\n            const damage = Math.floor(impactVelocity / 4);\n            \n            [bodyA, bodyB].forEach(body => {\n                if (body.userData?.name?.includes('cake')) {\n                    body.userData.damage = (body.userData.damage || 0) + damage;\n                }\n            });\n            \n            console.log(`ğŸ‚ğŸ‚ ì¼€ì´í¬ ê°„ ì¶©ëŒ ì†ìƒ: ${damage}`);\n        }\n        \n        // ì¼€ì´í¬ë“¤ì´ ì„œë¡œ ë°€ì–´ë‚´ëŠ” íš¨ê³¼\n        const pushForce = impactVelocity * 0.3;\n        const direction = bodyA.position.vsub(bodyB.position).unit();\n        \n        bodyA.applyImpulse(direction.scale(pushForce), bodyA.position);\n        bodyB.applyImpulse(direction.scale(-pushForce), bodyB.position);\n    }\n    \n    /**\n     * ìºë¦­í„°-ë°”ë‹¥ ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    handleCharacterGroundCollision(collision) {\n        const { bodyA, bodyB } = collision;\n        const characterBody = bodyA.userData?.name?.includes('character') ? bodyA : bodyB;\n        \n        // ìºë¦­í„° ì°©ì§€ ìƒíƒœ ì„¤ì •\n        if (characterBody.userData) {\n            characterBody.userData.isGrounded = true;\n            characterBody.userData.lastGroundContact = Date.now();\n        }\n        \n        // ì°©ì§€ ì‚¬ìš´ë“œ (ì•½í•œ ì¶©ëŒ)\n        if (collision.impactVelocity > 0.5) {\n            this.dispatchEvent('characterLanded', {\n                body: characterBody,\n                impactVelocity: collision.impactVelocity\n            });\n        }\n    }\n    \n    /**\n     * ìºë¦­í„°-ì¼€ì´í¬ ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    handleCharacterCakeCollision(collision) {\n        const { impactVelocity, bodyA, bodyB } = collision;\n        const characterBody = bodyA.userData?.name?.includes('character') ? bodyA : bodyB;\n        const cakeBody = characterBody === bodyA ? bodyB : bodyA;\n        \n        // ìºë¦­í„°ê°€ ì¼€ì´í¬ë¥¼ ë°€ê±°ë‚˜ ë‹¹ê¸°ëŠ” ìƒí˜¸ì‘ìš©\n        this.dispatchEvent('characterCakeInteraction', {\n            characterBody,\n            cakeBody,\n            impactVelocity,\n            interactionType: impactVelocity > 1.0 ? 'push' : 'touch'\n        });\n        \n        console.log(`ğŸ‘¤ğŸ‚ ìºë¦­í„°-ì¼€ì´í¬ ìƒí˜¸ì‘ìš©: ${impactVelocity.toFixed(2)}`);\n    }\n    \n    /**\n     * í™˜ê²½ ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    handleEnvironmentCollision(collision) {\n        // ì¼ë°˜ì ì¸ í™˜ê²½ ì˜¤ë¸Œì íŠ¸ ì¶©ëŒ ì²˜ë¦¬\n        const { impactVelocity } = collision;\n        \n        if (impactVelocity > this.thresholds.soundThreshold) {\n            // í™˜ê²½ ì¶©ëŒìŒ\n            this.dispatchEvent('environmentCollision', collision);\n        }\n    }\n    \n    /**\n     * ê°•í•œ ì¶©ê²© ì¶©ëŒ ì²˜ë¦¬\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    processHighImpactCollision(collision) {\n        const { impactVelocity, contactPoint } = collision;\n        \n        console.log(`ğŸ’¥ğŸ’¥ ê°•í•œ ì¶©ê²© ì¶©ëŒ: ${impactVelocity.toFixed(2)}`);\n        \n        // ê°•í•œ íŒŒí‹°í´ íš¨ê³¼\n        this.createHighImpactParticles(collision);\n        \n        // ê°•í•œ ì¹´ë©”ë¼ í”ë“¤ë¦¼\n        this.triggerStrongCameraShake(collision);\n        \n        // ê°•í•œ í–…í‹± í”¼ë“œë°±\n        this.triggerStrongHapticFeedback(collision);\n        \n        // ì´ë²¤íŠ¸ ë°œìƒ\n        this.dispatchEvent('highImpactCollision', collision);\n    }\n    \n    /**\n     * ì¶©ëŒ ì‚¬ìš´ë“œ ì¬ìƒ\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    playCollisionSound(collision) {\n        // ì‚¬ìš´ë“œ ì‹œìŠ¤í…œì´ ìˆë‹¤ë©´ ì¬ìƒ\n        this.dispatchEvent('playCollisionSound', {\n            collisionType: collision.collisionType,\n            intensity: collision.impactVelocity,\n            position: collision.contactPoint\n        });\n    }\n    \n    /**\n     * ì¶©ëŒ íŒŒí‹°í´ ìƒì„±\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    createCollisionParticles(collision) {\n        this.dispatchEvent('createCollisionParticles', {\n            position: collision.contactPoint,\n            intensity: collision.impactVelocity,\n            collisionType: collision.collisionType\n        });\n    }\n    \n    /**\n     * ê°•í•œ ì¶©ê²© íŒŒí‹°í´ ìƒì„±\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    createHighImpactParticles(collision) {\n        this.dispatchEvent('createHighImpactParticles', {\n            position: collision.contactPoint,\n            intensity: collision.impactVelocity * 2,\n            collisionType: collision.collisionType\n        });\n    }\n    \n    /**\n     * ì¹´ë©”ë¼ í”ë“¤ë¦¼ íŠ¸ë¦¬ê±°\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    triggerCameraShake(collision) {\n        const intensity = Math.min(collision.impactVelocity * 0.1, 1.0);\n        \n        this.dispatchEvent('cameraShake', {\n            intensity: intensity * this.effects.camera.shakeIntensity,\n            duration: this.effects.camera.shakeDuration\n        });\n    }\n    \n    /**\n     * ê°•í•œ ì¹´ë©”ë¼ í”ë“¤ë¦¼ íŠ¸ë¦¬ê±°\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    triggerStrongCameraShake(collision) {\n        const intensity = Math.min(collision.impactVelocity * 0.2, 2.0);\n        \n        this.dispatchEvent('cameraShake', {\n            intensity: intensity * this.effects.camera.shakeIntensity,\n            duration: this.effects.camera.shakeDuration * 1.5\n        });\n    }\n    \n    /**\n     * í–…í‹± í”¼ë“œë°± íŠ¸ë¦¬ê±°\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    triggerHapticFeedback(collision) {\n        if ('vibrate' in navigator) {\n            const duration = Math.min(collision.impactVelocity * 20, this.effects.haptic.duration);\n            navigator.vibrate(duration);\n        }\n    }\n    \n    /**\n     * ê°•í•œ í–…í‹± í”¼ë“œë°± íŠ¸ë¦¬ê±°\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    triggerStrongHapticFeedback(collision) {\n        if ('vibrate' in navigator) {\n            const pattern = [100, 50, 100, 50, 200];\n            navigator.vibrate(pattern);\n        }\n    }\n    \n    /**\n     * ì¶©ëŒ í†µê³„ ì—…ë°ì´íŠ¸\n     * @param {Object} collision - ì¶©ëŒ ì •ë³´\n     */\n    updateCollisionStats(collision) {\n        this.collisionStats.totalCollisions++;\n        \n        // íƒ€ì…ë³„ í†µê³„\n        if (collision.collisionType.includes('cake')) {\n            this.collisionStats.cakeCollisions++;\n        }\n        if (collision.collisionType.includes('character')) {\n            this.collisionStats.characterCollisions++;\n        }\n        if (collision.collisionType === 'environment') {\n            this.collisionStats.environmentCollisions++;\n        }\n        \n        // í‰ê·  ì¶©ê²©ë ¥ ê³„ì‚°\n        const totalImpact = this.collisionStats.averageImpactForce * (this.collisionStats.totalCollisions - 1);\n        this.collisionStats.averageImpactForce = (totalImpact + collision.impactVelocity) / this.collisionStats.totalCollisions;\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€\n     * @param {string} eventType - ì´ë²¤íŠ¸ íƒ€ì…\n     * @param {Function} callback - ì½œë°± í•¨ìˆ˜\n     */\n    addEventListener(eventType, callback) {\n        if (!this.eventListeners.has(eventType)) {\n            this.eventListeners.set(eventType, []);\n        }\n        this.eventListeners.get(eventType).push(callback);\n    }\n    \n    /**\n     * ì´ë²¤íŠ¸ ë°œìƒ\n     * @param {string} eventType - ì´ë²¤íŠ¸ íƒ€ì…\n     * @param {Object} data - ì´ë²¤íŠ¸ ë°ì´í„°\n     */\n    dispatchEvent(eventType, data) {\n        const listeners = this.eventListeners.get(eventType);\n        if (listeners) {\n            listeners.forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`ì¶©ëŒ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì˜¤ë¥˜ (${eventType}):`, error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * ì¶©ëŒ ì„ê³„ê°’ ì„¤ì •\n     * @param {Object} thresholds - ìƒˆë¡œìš´ ì„ê³„ê°’\n     */\n    setThresholds(thresholds) {\n        Object.assign(this.thresholds, thresholds);\n        console.log('ğŸ¯ ì¶©ëŒ ì„ê³„ê°’ ì—…ë°ì´íŠ¸:', thresholds);\n    }\n    \n    /**\n     * íš¨ê³¼ ì„¤ì •\n     * @param {Object} effects - ìƒˆë¡œìš´ íš¨ê³¼ ì„¤ì •\n     */\n    setEffects(effects) {\n        Object.assign(this.effects, effects);\n        console.log('âœ¨ ì¶©ëŒ íš¨ê³¼ ì„¤ì • ì—…ë°ì´íŠ¸:', effects);\n    }\n    \n    /**\n     * ì¶©ëŒ í†µê³„ ë°˜í™˜\n     * @returns {Object}\n     */\n    getCollisionStats() {\n        return { ...this.collisionStats };\n    }\n    \n    /**\n     * ìµœê·¼ ì¶©ëŒ ì´ë²¤íŠ¸ ë°˜í™˜\n     * @param {number} count - ë°˜í™˜í•  ì´ë²¤íŠ¸ ìˆ˜\n     * @returns {Array}\n     */\n    getRecentCollisions(count = 10) {\n        return this.collisionEvents.slice(-count);\n    }\n    \n    /**\n     * ì¶©ëŒ í†µê³„ ì´ˆê¸°í™”\n     */\n    resetStats() {\n        this.collisionStats = {\n            totalCollisions: 0,\n            cakeCollisions: 0,\n            characterCollisions: 0,\n            environmentCollisions: 0,\n            averageImpactForce: 0\n        };\n        \n        this.collisionEvents = [];\n        \n        console.log('ğŸ“Š ì¶©ëŒ í†µê³„ ì´ˆê¸°í™”');\n    }\n    \n    /**\n     * ì •ë¦¬\n     */\n    cleanup() {\n        console.log('ğŸ§¹ ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ ì •ë¦¬ ì‹œì‘...');\n        \n        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬\n        this.eventListeners.clear();\n        \n        // ì¶©ëŒ ì²˜ë¦¬ê¸° ì •ë¦¬\n        this.collisionHandlers.clear();\n        \n        // ì¶©ëŒ ì´ë²¤íŠ¸ ì •ë¦¬\n        this.collisionEvents = [];\n        \n        console.log('âœ… ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ');\n    }\n    \n    /**\n     * ë””ë²„ê·¸ ì •ë³´ ë°˜í™˜\n     * @returns {Object}\n     */\n    getDebugInfo() {\n        return {\n            collisionStats: this.collisionStats,\n            recentCollisions: this.getRecentCollisions(5),\n            thresholds: this.thresholds,\n            effects: this.effects,\n            handlerCount: this.collisionHandlers.size,\n            listenerCount: this.eventListeners.size\n        };\n    }\n}"