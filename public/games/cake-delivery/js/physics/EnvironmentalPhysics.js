/**
 * 환경 물리 시스템
 * 바람, 경사, 온도 등 환경 요소의 물리적 영향을 시뮬레이션
 */
class EnvironmentalPhysics {
    constructor(physicsManager) {
        this.physicsManager = physicsManager;
        
        // 환경 효과들
        this.effects = {\n            wind: {\n                enabled: false,\n                strength: 0.0,\n                direction: { x: 1, y: 0, z: 0 },\n                turbulence: 0.1,\n                gustiness: 0.2,\n                gustFrequency: 0.5,\n                altitude: 0, // 높이에 따른 바람 강도 변화\n                time: 0\n            },\n            gravity: {\n                enabled: true,\n                strength: -9.82,\n                direction: { x: 0, y: 1, z: 0 },\n                variations: false, // 중력 변화 효과\n                anomalies: [] // 중력 이상 지역\n            },\n            temperature: {\n                enabled: false,\n                current: 20, // 섭씨\n                effects: {\n                    freezing: false, // 얼음 효과\n                    melting: false, // 녹는 효과\n                    expansion: false // 열팽창 효과\n                }\n            },\n            terrain: {\n                enabled: true,\n                slopes: [], // 경사면들\n                friction: {\n                    base: 0.5,\n                    wet: 0.3,\n                    ice: 0.1,\n                    rough: 0.8\n                },\n                materials: new Map() // 지형 재질별 속성\n            },\n            atmosphere: {\n                enabled: false,\n                pressure: 1.0, // 기압\n                humidity: 0.5, // 습도\n                density: 1.225, // 공기 밀도 (kg/m³)\n                resistance: 0.02 // 공기 저항 계수\n            }\n        };\n        \n        // 환경 구역들\n        this.environmentalZones = new Map();\n        \n        // 시간 기반 효과\n        this.timeEffects = {\n            dayNightCycle: {\n                enabled: false,\n                timeOfDay: 0.5, // 0: 자정, 0.5: 정오, 1: 자정\n                speed: 0.001, // 시간 진행 속도\n                effects: {\n                    temperature: true,\n                    wind: true,\n                    gravity: false\n                }\n            },\n            weather: {\n                enabled: false,\n                current: 'clear', // clear, rain, snow, storm\n                intensity: 0.0,\n                duration: 0,\n                transition: false\n            }\n        };\n        \n        // 성능 설정\n        this.performance = {\n            updateFrequency: 30, // Hz\n            lastUpdateTime: 0,\n            enableOptimizations: true\n        };\n        \n        console.log('🌍 환경 물리 시스템 초기화 완료');\n    }\n    \n    /**\n     * 환경 물리 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    update(deltaTime) {\n        // 성능 최적화: 업데이트 빈도 제한\n        const now = Date.now();\n        if (this.performance.enableOptimizations) {\n            const updateInterval = 1000 / this.performance.updateFrequency;\n            if (now - this.performance.lastUpdateTime < updateInterval) {\n                return;\n            }\n            this.performance.lastUpdateTime = now;\n        }\n        \n        // 시간 기반 효과 업데이트\n        this.updateTimeEffects(deltaTime);\n        \n        // 바람 효과 업데이트\n        if (this.effects.wind.enabled) {\n            this.updateWindEffects(deltaTime);\n        }\n        \n        // 중력 효과 업데이트\n        if (this.effects.gravity.enabled && this.effects.gravity.variations) {\n            this.updateGravityEffects(deltaTime);\n        }\n        \n        // 온도 효과 업데이트\n        if (this.effects.temperature.enabled) {\n            this.updateTemperatureEffects(deltaTime);\n        }\n        \n        // 지형 효과 업데이트\n        if (this.effects.terrain.enabled) {\n            this.updateTerrainEffects(deltaTime);\n        }\n        \n        // 대기 효과 업데이트\n        if (this.effects.atmosphere.enabled) {\n            this.updateAtmosphereEffects(deltaTime);\n        }\n        \n        // 환경 구역 효과 적용\n        this.applyEnvironmentalZones();\n    }\n    \n    /**\n     * 시간 기반 효과 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    updateTimeEffects(deltaTime) {\n        const { dayNightCycle, weather } = this.timeEffects;\n        \n        // 낮밤 사이클\n        if (dayNightCycle.enabled) {\n            dayNightCycle.timeOfDay += dayNightCycle.speed * deltaTime;\n            if (dayNightCycle.timeOfDay > 1) dayNightCycle.timeOfDay -= 1;\n            \n            // 시간에 따른 환경 변화\n            if (dayNightCycle.effects.temperature) {\n                this.updateTemperatureByTime(dayNightCycle.timeOfDay);\n            }\n            if (dayNightCycle.effects.wind) {\n                this.updateWindByTime(dayNightCycle.timeOfDay);\n            }\n        }\n        \n        // 날씨 효과\n        if (weather.enabled && weather.duration > 0) {\n            weather.duration -= deltaTime;\n            this.applyWeatherEffects(weather.current, weather.intensity);\n            \n            if (weather.duration <= 0) {\n                this.endWeatherEffect();\n            }\n        }\n    }\n    \n    /**\n     * 바람 효과 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    updateWindEffects(deltaTime) {\n        const wind = this.effects.wind;\n        wind.time += deltaTime;\n        \n        // 돌풍 효과 계산\n        const gustEffect = Math.sin(wind.time * wind.gustFrequency) * wind.gustiness;\n        const currentStrength = wind.strength * (1 + gustEffect);\n        \n        // 난기류 효과\n        const turbulenceX = (Math.random() - 0.5) * wind.turbulence;\n        const turbulenceZ = (Math.random() - 0.5) * wind.turbulence;\n        \n        // 현재 바람 벡터 계산\n        const windVector = {\n            x: wind.direction.x * currentStrength + turbulenceX,\n            y: 0,\n            z: wind.direction.z * currentStrength + turbulenceZ\n        };\n        \n        // 모든 동적 바디에 바람 효과 적용\n        this.applyWindToAllBodies(windVector);\n    }\n    \n    /**\n     * 모든 바디에 바람 효과 적용\n     * @param {Object} windVector - 바람 벡터\n     */\n    applyWindToAllBodies(windVector) {\n        if (!this.physicsManager || !this.physicsManager.world) return;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0 && body.userData) { // 동적 바디만\n                const windForce = this.calculateWindForce(body, windVector);\n                \n                if (windForce.length() > 0.001) {\n                    body.applyForce(windForce, body.position);\n                }\n            }\n        });\n    }\n    \n    /**\n     * 바디에 대한 바람 힘 계산\n     * @param {CANNON.Body} body - 물리 바디\n     * @param {Object} windVector - 바람 벡터\n     * @returns {CANNON.Vec3} 바람 힘\n     */\n    calculateWindForce(body, windVector) {\n        // 바디 타입별 바람 저항 계수\n        const dragCoefficients = {\n            cake: 0.8,\n            character: 0.6,\n            box: 1.0,\n            sphere: 0.47,\n            default: 0.7\n        };\n        \n        const bodyType = body.userData.name?.split('_')[0] || 'default';\n        const dragCoeff = dragCoefficients[bodyType] || dragCoefficients.default;\n        \n        // 바디 크기 추정 (질량 기반)\n        const estimatedArea = Math.pow(body.mass, 2/3); // 대략적인 표면적\n        \n        // 높이에 따른 바람 강도 변화\n        const altitudeEffect = 1 + (body.position.y * this.effects.wind.altitude);\n        \n        // 바람 힘 계산 (공기역학 공식 단순화)\n        const airDensity = this.effects.atmosphere.density;\n        const relativeVelocity = new CANNON.Vec3(\n            windVector.x - body.velocity.x,\n            windVector.y - body.velocity.y,\n            windVector.z - body.velocity.z\n        );\n        \n        const speed = relativeVelocity.length();\n        if (speed < 0.1) return new CANNON.Vec3(0, 0, 0);\n        \n        const forceDirection = relativeVelocity.unit();\n        const forceMagnitude = 0.5 * airDensity * dragCoeff * estimatedArea * speed * speed * altitudeEffect;\n        \n        return forceDirection.scale(forceMagnitude / body.mass); // 질량으로 나누어 가속도로 변환\n    }\n    \n    /**\n     * 중력 효과 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    updateGravityEffects(deltaTime) {\n        const gravity = this.effects.gravity;\n        \n        // 중력 이상 지역 처리\n        gravity.anomalies.forEach(anomaly => {\n            this.applyGravityAnomaly(anomaly);\n        });\n    }\n    \n    /**\n     * 중력 이상 적용\n     * @param {Object} anomaly - 중력 이상 정보\n     */\n    applyGravityAnomaly(anomaly) {\n        const { center, radius, strength, type } = anomaly;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0) {\n                const distance = body.position.distanceTo(new CANNON.Vec3(center.x, center.y, center.z));\n                \n                if (distance < radius) {\n                    const effect = 1 - (distance / radius); // 거리에 따른 효과 감소\n                    let gravityModifier;\n                    \n                    switch (type) {\n                        case 'low': // 저중력 지역\n                            gravityModifier = 1 - (strength * effect);\n                            break;\n                        case 'high': // 고중력 지역\n                            gravityModifier = 1 + (strength * effect);\n                            break;\n                        case 'zero': // 무중력 지역\n                            gravityModifier = 1 - effect;\n                            break;\n                        default:\n                            gravityModifier = 1;\n                    }\n                    \n                    // 중력 수정 적용\n                    const modifiedGravity = new CANNON.Vec3(\n                        this.physicsManager.world.gravity.x * gravityModifier,\n                        this.physicsManager.world.gravity.y * gravityModifier,\n                        this.physicsManager.world.gravity.z * gravityModifier\n                    );\n                    \n                    body.force.vadd(modifiedGravity.scale(body.mass), body.force);\n                }\n            }\n        });\n    }\n    \n    /**\n     * 온도 효과 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    updateTemperatureEffects(deltaTime) {\n        const temp = this.effects.temperature;\n        \n        // 얼음 효과\n        if (temp.current < 0 && temp.effects.freezing) {\n            this.applyFreezingEffects();\n        }\n        \n        // 녹는 효과\n        if (temp.current > 0 && temp.effects.melting) {\n            this.applyMeltingEffects();\n        }\n        \n        // 열팽창 효과\n        if (temp.effects.expansion) {\n            this.applyThermalExpansion(temp.current);\n        }\n    }\n    \n    /**\n     * 얼음 효과 적용\n     */\n    applyFreezingEffects() {\n        // 마찰력 감소 (얼음 표면)\n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.userData?.name === 'ground') {\n                // 바닥 마찰력을 얼음 수준으로 감소\n                if (body.material) {\n                    body.material.friction = this.effects.terrain.friction.ice;\n                }\n            }\n        });\n    }\n    \n    /**\n     * 녹는 효과 적용\n     */\n    applyMeltingEffects() {\n        // 케이크가 녹는 효과 (질량 감소, 모양 변화)\n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.userData?.name?.includes('cake')) {\n                // 케이크 질량 점진적 감소\n                if (body.userData.originalMass === undefined) {\n                    body.userData.originalMass = body.mass;\n                }\n                \n                const meltingRate = 0.001; // 녹는 속도\n                body.mass = Math.max(body.userData.originalMass * 0.5, body.mass - meltingRate);\n                body.updateMassProperties();\n            }\n        });\n    }\n    \n    /**\n     * 열팽창 효과 적용\n     * @param {number} temperature - 온도\n     */\n    applyThermalExpansion(temperature) {\n        const expansionCoeff = 0.001; // 열팽창 계수\n        const referenceTemp = 20; // 기준 온도\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.userData?.thermalExpansion) {\n                const tempDiff = temperature - referenceTemp;\n                const expansionFactor = 1 + (expansionCoeff * tempDiff);\n                \n                // 바디 크기 조정 (단순화)\n                if (body.shapes[0]) {\n                    const shape = body.shapes[0];\n                    if (shape.type === CANNON.Shape.types.BOX) {\n                        shape.halfExtents.scale(expansionFactor, shape.halfExtents);\n                    } else if (shape.type === CANNON.Shape.types.SPHERE) {\n                        shape.radius *= expansionFactor;\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * 지형 효과 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    updateTerrainEffects(deltaTime) {\n        // 경사면 효과 적용\n        this.effects.terrain.slopes.forEach(slope => {\n            this.applySlopeEffect(slope);\n        });\n    }\n    \n    /**\n     * 경사면 효과 적용\n     * @param {Object} slope - 경사면 정보\n     */\n    applySlopeEffect(slope) {\n        const { center, size, angle, direction } = slope;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0) {\n                // 바디가 경사면 위에 있는지 확인\n                const bodyPos = body.position;\n                const slopeCenter = new CANNON.Vec3(center.x, center.y, center.z);\n                \n                const distance = Math.sqrt(\n                    Math.pow(bodyPos.x - slopeCenter.x, 2) + \n                    Math.pow(bodyPos.z - slopeCenter.z, 2)\n                );\n                \n                if (distance < size) {\n                    // 경사력 계산\n                    const slopeForce = new CANNON.Vec3(\n                        Math.sin(angle) * direction.x,\n                        0,\n                        Math.sin(angle) * direction.z\n                    );\n                    \n                    slopeForce.scale(body.mass * Math.abs(this.physicsManager.world.gravity.y), slopeForce);\n                    body.applyForce(slopeForce, body.position);\n                }\n            }\n        });\n    }\n    \n    /**\n     * 대기 효과 업데이트\n     * @param {number} deltaTime - 델타 시간\n     */\n    updateAtmosphereEffects(deltaTime) {\n        const atmosphere = this.effects.atmosphere;\n        \n        // 공기 저항 적용\n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0 && body.velocity.length() > 0.1) {\n                const dragForce = body.velocity.clone();\n                dragForce.scale(-atmosphere.resistance * atmosphere.density, dragForce);\n                body.applyForce(dragForce, body.position);\n            }\n        });\n    }\n    \n    /**\n     * 환경 구역 효과 적용\n     */\n    applyEnvironmentalZones() {\n        this.environmentalZones.forEach((zone, zoneName) => {\n            this.applyZoneEffect(zone);\n        });\n    }\n    \n    /**\n     * 구역 효과 적용\n     * @param {Object} zone - 환경 구역\n     */\n    applyZoneEffect(zone) {\n        const { center, radius, effects } = zone;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0) {\n                const distance = body.position.distanceTo(new CANNON.Vec3(center.x, center.y, center.z));\n                \n                if (distance < radius) {\n                    const intensity = 1 - (distance / radius);\n                    \n                    // 구역별 효과 적용\n                    Object.keys(effects).forEach(effectType => {\n                        this.applyZoneEffectToBody(body, effectType, effects[effectType], intensity);\n                    });\n                }\n            }\n        });\n    }\n    \n    /**\n     * 바디에 구역 효과 적용\n     * @param {CANNON.Body} body - 물리 바디\n     * @param {string} effectType - 효과 타입\n     * @param {*} effectValue - 효과 값\n     * @param {number} intensity - 강도\n     */\n    applyZoneEffectToBody(body, effectType, effectValue, intensity) {\n        switch (effectType) {\n            case 'gravity':\n                const gravityForce = new CANNON.Vec3(0, effectValue * intensity * body.mass, 0);\n                body.applyForce(gravityForce, body.position);\n                break;\n                \n            case 'friction':\n                if (body.material) {\n                    body.material.friction = effectValue * intensity;\n                }\n                break;\n                \n            case 'damping':\n                body.linearDamping = effectValue * intensity;\n                break;\n                \n            case 'force':\n                const force = new CANNON.Vec3(\n                    effectValue.x * intensity,\n                    effectValue.y * intensity,\n                    effectValue.z * intensity\n                );\n                body.applyForce(force, body.position);\n                break;\n        }\n    }\n    \n    /**\n     * 시간에 따른 온도 업데이트\n     * @param {number} timeOfDay - 하루 중 시간 (0-1)\n     */\n    updateTemperatureByTime(timeOfDay) {\n        // 간단한 사인파 기반 온도 변화\n        const baseTemp = 20;\n        const tempVariation = 15;\n        const temp = baseTemp + Math.sin((timeOfDay - 0.25) * Math.PI * 2) * tempVariation;\n        \n        this.effects.temperature.current = temp;\n    }\n    \n    /**\n     * 시간에 따른 바람 업데이트\n     * @param {number} timeOfDay - 하루 중 시간 (0-1)\n     */\n    updateWindByTime(timeOfDay) {\n        // 낮에는 바람이 강하고, 밤에는 약함\n        const baseStrength = 2.0;\n        const variation = 1.5;\n        const strength = baseStrength + Math.sin(timeOfDay * Math.PI * 2) * variation;\n        \n        this.effects.wind.strength = Math.max(0, strength);\n    }\n    \n    /**\n     * 날씨 효과 적용\n     * @param {string} weatherType - 날씨 타입\n     * @param {number} intensity - 강도\n     */\n    applyWeatherEffects(weatherType, intensity) {\n        switch (weatherType) {\n            case 'rain':\n                this.effects.terrain.friction.base *= (1 - intensity * 0.3); // 미끄러움\n                this.effects.wind.strength += intensity * 2; // 바람 증가\n                break;\n                \n            case 'snow':\n                this.effects.temperature.current -= intensity * 10; // 온도 하강\n                this.effects.terrain.friction.base *= (1 - intensity * 0.5); // 매우 미끄러움\n                break;\n                \n            case 'storm':\n                this.effects.wind.strength += intensity * 5; // 강한 바람\n                this.effects.wind.turbulence += intensity * 0.3; // 난기류 증가\n                break;\n        }\n    }\n    \n    /**\n     * 날씨 효과 종료\n     */\n    endWeatherEffect() {\n        // 날씨 효과를 기본값으로 복원\n        this.effects.terrain.friction.base = 0.5;\n        this.effects.wind.strength = 0;\n        this.effects.wind.turbulence = 0.1;\n        this.effects.temperature.current = 20;\n        \n        this.timeEffects.weather.enabled = false;\n        this.timeEffects.weather.current = 'clear';\n        \n        console.log('🌤️ 날씨 효과 종료');\n    }\n    \n    /**\n     * 바람 설정\n     * @param {boolean} enabled - 활성화\n     * @param {number} strength - 강도\n     * @param {Object} direction - 방향\n     * @param {number} turbulence - 난기류\n     */\n    setWind(enabled, strength = 0, direction = { x: 1, y: 0, z: 0 }, turbulence = 0.1) {\n        this.effects.wind.enabled = enabled;\n        this.effects.wind.strength = strength;\n        this.effects.wind.direction = direction;\n        this.effects.wind.turbulence = turbulence;\n        \n        console.log(`💨 바람 설정: ${enabled ? '활성화' : '비활성화'} (강도: ${strength})`);\n    }\n    \n    /**\n     * 중력 이상 지역 추가\n     * @param {string} name - 이름\n     * @param {Object} center - 중심점\n     * @param {number} radius - 반경\n     * @param {number} strength - 강도\n     * @param {string} type - 타입 (low, high, zero)\n     */\n    addGravityAnomaly(name, center, radius, strength, type = 'low') {\n        const anomaly = { center, radius, strength, type };\n        this.effects.gravity.anomalies.push(anomaly);\n        \n        console.log(`🌍 중력 이상 지역 추가: ${name} (${type})`);\n    }\n    \n    /**\n     * 환경 구역 추가\n     * @param {string} name - 구역 이름\n     * @param {Object} center - 중심점\n     * @param {number} radius - 반경\n     * @param {Object} effects - 효과들\n     */\n    addEnvironmentalZone(name, center, radius, effects) {\n        this.environmentalZones.set(name, {\n            center,\n            radius,\n            effects\n        });\n        \n        console.log(`🏞️ 환경 구역 추가: ${name}`);\n    }\n    \n    /**\n     * 경사면 추가\n     * @param {Object} center - 중심점\n     * @param {number} size - 크기\n     * @param {number} angle - 각도 (라디안)\n     * @param {Object} direction - 방향\n     */\n    addSlope(center, size, angle, direction) {\n        this.effects.terrain.slopes.push({\n            center,\n            size,\n            angle,\n            direction\n        });\n        \n        console.log(`⛰️ 경사면 추가: 각도 ${(angle * 180 / Math.PI).toFixed(1)}도`);\n    }\n    \n    /**\n     * 날씨 설정\n     * @param {string} weatherType - 날씨 타입\n     * @param {number} intensity - 강도\n     * @param {number} duration - 지속 시간\n     */\n    setWeather(weatherType, intensity = 1.0, duration = 60) {\n        this.timeEffects.weather.enabled = true;\n        this.timeEffects.weather.current = weatherType;\n        this.timeEffects.weather.intensity = intensity;\n        this.timeEffects.weather.duration = duration;\n        \n        console.log(`🌦️ 날씨 설정: ${weatherType} (강도: ${intensity}, 지속: ${duration}초)`);\n    }\n    \n    /**\n     * 낮밤 사이클 설정\n     * @param {boolean} enabled - 활성화\n     * @param {number} speed - 속도\n     * @param {number} startTime - 시작 시간\n     */\n    setDayNightCycle(enabled, speed = 0.001, startTime = 0.5) {\n        this.timeEffects.dayNightCycle.enabled = enabled;\n        this.timeEffects.dayNightCycle.speed = speed;\n        this.timeEffects.dayNightCycle.timeOfDay = startTime;\n        \n        console.log(`🌅 낮밤 사이클: ${enabled ? '활성화' : '비활성화'}`);\n    }\n    \n    /**\n     * 현재 환경 상태 반환\n     * @returns {Object}\n     */\n    getEnvironmentalState() {\n        return {\n            wind: { ...this.effects.wind },\n            temperature: { ...this.effects.temperature },\n            weather: { ...this.timeEffects.weather },\n            timeOfDay: this.timeEffects.dayNightCycle.timeOfDay,\n            zones: this.environmentalZones.size,\n            anomalies: this.effects.gravity.anomalies.length\n        };\n    }\n    \n    /**\n     * 정리\n     */\n    cleanup() {\n        console.log('🧹 환경 물리 시스템 정리 시작...');\n        \n        // 환경 구역 정리\n        this.environmentalZones.clear();\n        \n        // 중력 이상 지역 정리\n        this.effects.gravity.anomalies = [];\n        \n        // 경사면 정리\n        this.effects.terrain.slopes = [];\n        \n        console.log('✅ 환경 물리 시스템 정리 완료');\n    }\n    \n    /**\n     * 디버그 정보 반환\n     * @returns {Object}\n     */\n    getDebugInfo() {\n        return {\n            effects: this.effects,\n            timeEffects: this.timeEffects,\n            environmentalZones: Array.from(this.environmentalZones.keys()),\n            performance: this.performance\n        };\n    }\n}"