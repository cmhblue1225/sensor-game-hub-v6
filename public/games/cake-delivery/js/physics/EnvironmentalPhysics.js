/**
 * í™˜ê²½ ë¬¼ë¦¬ ì‹œìŠ¤í…œ
 * ë°”ëŒ, ê²½ì‚¬, ì˜¨ë„ ë“± í™˜ê²½ ìš”ì†Œì˜ ë¬¼ë¦¬ì  ì˜í–¥ì„ ì‹œë®¬ë ˆì´ì…˜
 */
class EnvironmentalPhysics {
    constructor(physicsManager) {
        this.physicsManager = physicsManager;
        
        // í™˜ê²½ íš¨ê³¼ë“¤
        this.effects = {\n            wind: {\n                enabled: false,\n                strength: 0.0,\n                direction: { x: 1, y: 0, z: 0 },\n                turbulence: 0.1,\n                gustiness: 0.2,\n                gustFrequency: 0.5,\n                altitude: 0, // ë†’ì´ì— ë”°ë¥¸ ë°”ëŒ ê°•ë„ ë³€í™”\n                time: 0\n            },\n            gravity: {\n                enabled: true,\n                strength: -9.82,\n                direction: { x: 0, y: 1, z: 0 },\n                variations: false, // ì¤‘ë ¥ ë³€í™” íš¨ê³¼\n                anomalies: [] // ì¤‘ë ¥ ì´ìƒ ì§€ì—­\n            },\n            temperature: {\n                enabled: false,\n                current: 20, // ì„­ì”¨\n                effects: {\n                    freezing: false, // ì–¼ìŒ íš¨ê³¼\n                    melting: false, // ë…¹ëŠ” íš¨ê³¼\n                    expansion: false // ì—´íŒ½ì°½ íš¨ê³¼\n                }\n            },\n            terrain: {\n                enabled: true,\n                slopes: [], // ê²½ì‚¬ë©´ë“¤\n                friction: {\n                    base: 0.5,\n                    wet: 0.3,\n                    ice: 0.1,\n                    rough: 0.8\n                },\n                materials: new Map() // ì§€í˜• ì¬ì§ˆë³„ ì†ì„±\n            },\n            atmosphere: {\n                enabled: false,\n                pressure: 1.0, // ê¸°ì••\n                humidity: 0.5, // ìŠµë„\n                density: 1.225, // ê³µê¸° ë°€ë„ (kg/mÂ³)\n                resistance: 0.02 // ê³µê¸° ì €í•­ ê³„ìˆ˜\n            }\n        };\n        \n        // í™˜ê²½ êµ¬ì—­ë“¤\n        this.environmentalZones = new Map();\n        \n        // ì‹œê°„ ê¸°ë°˜ íš¨ê³¼\n        this.timeEffects = {\n            dayNightCycle: {\n                enabled: false,\n                timeOfDay: 0.5, // 0: ìì •, 0.5: ì •ì˜¤, 1: ìì •\n                speed: 0.001, // ì‹œê°„ ì§„í–‰ ì†ë„\n                effects: {\n                    temperature: true,\n                    wind: true,\n                    gravity: false\n                }\n            },\n            weather: {\n                enabled: false,\n                current: 'clear', // clear, rain, snow, storm\n                intensity: 0.0,\n                duration: 0,\n                transition: false\n            }\n        };\n        \n        // ì„±ëŠ¥ ì„¤ì •\n        this.performance = {\n            updateFrequency: 30, // Hz\n            lastUpdateTime: 0,\n            enableOptimizations: true\n        };\n        \n        console.log('ğŸŒ í™˜ê²½ ë¬¼ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');\n    }\n    \n    /**\n     * í™˜ê²½ ë¬¼ë¦¬ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    update(deltaTime) {\n        // ì„±ëŠ¥ ìµœì í™”: ì—…ë°ì´íŠ¸ ë¹ˆë„ ì œí•œ\n        const now = Date.now();\n        if (this.performance.enableOptimizations) {\n            const updateInterval = 1000 / this.performance.updateFrequency;\n            if (now - this.performance.lastUpdateTime < updateInterval) {\n                return;\n            }\n            this.performance.lastUpdateTime = now;\n        }\n        \n        // ì‹œê°„ ê¸°ë°˜ íš¨ê³¼ ì—…ë°ì´íŠ¸\n        this.updateTimeEffects(deltaTime);\n        \n        // ë°”ëŒ íš¨ê³¼ ì—…ë°ì´íŠ¸\n        if (this.effects.wind.enabled) {\n            this.updateWindEffects(deltaTime);\n        }\n        \n        // ì¤‘ë ¥ íš¨ê³¼ ì—…ë°ì´íŠ¸\n        if (this.effects.gravity.enabled && this.effects.gravity.variations) {\n            this.updateGravityEffects(deltaTime);\n        }\n        \n        // ì˜¨ë„ íš¨ê³¼ ì—…ë°ì´íŠ¸\n        if (this.effects.temperature.enabled) {\n            this.updateTemperatureEffects(deltaTime);\n        }\n        \n        // ì§€í˜• íš¨ê³¼ ì—…ë°ì´íŠ¸\n        if (this.effects.terrain.enabled) {\n            this.updateTerrainEffects(deltaTime);\n        }\n        \n        // ëŒ€ê¸° íš¨ê³¼ ì—…ë°ì´íŠ¸\n        if (this.effects.atmosphere.enabled) {\n            this.updateAtmosphereEffects(deltaTime);\n        }\n        \n        // í™˜ê²½ êµ¬ì—­ íš¨ê³¼ ì ìš©\n        this.applyEnvironmentalZones();\n    }\n    \n    /**\n     * ì‹œê°„ ê¸°ë°˜ íš¨ê³¼ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    updateTimeEffects(deltaTime) {\n        const { dayNightCycle, weather } = this.timeEffects;\n        \n        // ë‚®ë°¤ ì‚¬ì´í´\n        if (dayNightCycle.enabled) {\n            dayNightCycle.timeOfDay += dayNightCycle.speed * deltaTime;\n            if (dayNightCycle.timeOfDay > 1) dayNightCycle.timeOfDay -= 1;\n            \n            // ì‹œê°„ì— ë”°ë¥¸ í™˜ê²½ ë³€í™”\n            if (dayNightCycle.effects.temperature) {\n                this.updateTemperatureByTime(dayNightCycle.timeOfDay);\n            }\n            if (dayNightCycle.effects.wind) {\n                this.updateWindByTime(dayNightCycle.timeOfDay);\n            }\n        }\n        \n        // ë‚ ì”¨ íš¨ê³¼\n        if (weather.enabled && weather.duration > 0) {\n            weather.duration -= deltaTime;\n            this.applyWeatherEffects(weather.current, weather.intensity);\n            \n            if (weather.duration <= 0) {\n                this.endWeatherEffect();\n            }\n        }\n    }\n    \n    /**\n     * ë°”ëŒ íš¨ê³¼ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    updateWindEffects(deltaTime) {\n        const wind = this.effects.wind;\n        wind.time += deltaTime;\n        \n        // ëŒí’ íš¨ê³¼ ê³„ì‚°\n        const gustEffect = Math.sin(wind.time * wind.gustFrequency) * wind.gustiness;\n        const currentStrength = wind.strength * (1 + gustEffect);\n        \n        // ë‚œê¸°ë¥˜ íš¨ê³¼\n        const turbulenceX = (Math.random() - 0.5) * wind.turbulence;\n        const turbulenceZ = (Math.random() - 0.5) * wind.turbulence;\n        \n        // í˜„ì¬ ë°”ëŒ ë²¡í„° ê³„ì‚°\n        const windVector = {\n            x: wind.direction.x * currentStrength + turbulenceX,\n            y: 0,\n            z: wind.direction.z * currentStrength + turbulenceZ\n        };\n        \n        // ëª¨ë“  ë™ì  ë°”ë””ì— ë°”ëŒ íš¨ê³¼ ì ìš©\n        this.applyWindToAllBodies(windVector);\n    }\n    \n    /**\n     * ëª¨ë“  ë°”ë””ì— ë°”ëŒ íš¨ê³¼ ì ìš©\n     * @param {Object} windVector - ë°”ëŒ ë²¡í„°\n     */\n    applyWindToAllBodies(windVector) {\n        if (!this.physicsManager || !this.physicsManager.world) return;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0 && body.userData) { // ë™ì  ë°”ë””ë§Œ\n                const windForce = this.calculateWindForce(body, windVector);\n                \n                if (windForce.length() > 0.001) {\n                    body.applyForce(windForce, body.position);\n                }\n            }\n        });\n    }\n    \n    /**\n     * ë°”ë””ì— ëŒ€í•œ ë°”ëŒ í˜ ê³„ì‚°\n     * @param {CANNON.Body} body - ë¬¼ë¦¬ ë°”ë””\n     * @param {Object} windVector - ë°”ëŒ ë²¡í„°\n     * @returns {CANNON.Vec3} ë°”ëŒ í˜\n     */\n    calculateWindForce(body, windVector) {\n        // ë°”ë”” íƒ€ì…ë³„ ë°”ëŒ ì €í•­ ê³„ìˆ˜\n        const dragCoefficients = {\n            cake: 0.8,\n            character: 0.6,\n            box: 1.0,\n            sphere: 0.47,\n            default: 0.7\n        };\n        \n        const bodyType = body.userData.name?.split('_')[0] || 'default';\n        const dragCoeff = dragCoefficients[bodyType] || dragCoefficients.default;\n        \n        // ë°”ë”” í¬ê¸° ì¶”ì • (ì§ˆëŸ‰ ê¸°ë°˜)\n        const estimatedArea = Math.pow(body.mass, 2/3); // ëŒ€ëµì ì¸ í‘œë©´ì \n        \n        // ë†’ì´ì— ë”°ë¥¸ ë°”ëŒ ê°•ë„ ë³€í™”\n        const altitudeEffect = 1 + (body.position.y * this.effects.wind.altitude);\n        \n        // ë°”ëŒ í˜ ê³„ì‚° (ê³µê¸°ì—­í•™ ê³µì‹ ë‹¨ìˆœí™”)\n        const airDensity = this.effects.atmosphere.density;\n        const relativeVelocity = new CANNON.Vec3(\n            windVector.x - body.velocity.x,\n            windVector.y - body.velocity.y,\n            windVector.z - body.velocity.z\n        );\n        \n        const speed = relativeVelocity.length();\n        if (speed < 0.1) return new CANNON.Vec3(0, 0, 0);\n        \n        const forceDirection = relativeVelocity.unit();\n        const forceMagnitude = 0.5 * airDensity * dragCoeff * estimatedArea * speed * speed * altitudeEffect;\n        \n        return forceDirection.scale(forceMagnitude / body.mass); // ì§ˆëŸ‰ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ê°€ì†ë„ë¡œ ë³€í™˜\n    }\n    \n    /**\n     * ì¤‘ë ¥ íš¨ê³¼ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    updateGravityEffects(deltaTime) {\n        const gravity = this.effects.gravity;\n        \n        // ì¤‘ë ¥ ì´ìƒ ì§€ì—­ ì²˜ë¦¬\n        gravity.anomalies.forEach(anomaly => {\n            this.applyGravityAnomaly(anomaly);\n        });\n    }\n    \n    /**\n     * ì¤‘ë ¥ ì´ìƒ ì ìš©\n     * @param {Object} anomaly - ì¤‘ë ¥ ì´ìƒ ì •ë³´\n     */\n    applyGravityAnomaly(anomaly) {\n        const { center, radius, strength, type } = anomaly;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0) {\n                const distance = body.position.distanceTo(new CANNON.Vec3(center.x, center.y, center.z));\n                \n                if (distance < radius) {\n                    const effect = 1 - (distance / radius); // ê±°ë¦¬ì— ë”°ë¥¸ íš¨ê³¼ ê°ì†Œ\n                    let gravityModifier;\n                    \n                    switch (type) {\n                        case 'low': // ì €ì¤‘ë ¥ ì§€ì—­\n                            gravityModifier = 1 - (strength * effect);\n                            break;\n                        case 'high': // ê³ ì¤‘ë ¥ ì§€ì—­\n                            gravityModifier = 1 + (strength * effect);\n                            break;\n                        case 'zero': // ë¬´ì¤‘ë ¥ ì§€ì—­\n                            gravityModifier = 1 - effect;\n                            break;\n                        default:\n                            gravityModifier = 1;\n                    }\n                    \n                    // ì¤‘ë ¥ ìˆ˜ì • ì ìš©\n                    const modifiedGravity = new CANNON.Vec3(\n                        this.physicsManager.world.gravity.x * gravityModifier,\n                        this.physicsManager.world.gravity.y * gravityModifier,\n                        this.physicsManager.world.gravity.z * gravityModifier\n                    );\n                    \n                    body.force.vadd(modifiedGravity.scale(body.mass), body.force);\n                }\n            }\n        });\n    }\n    \n    /**\n     * ì˜¨ë„ íš¨ê³¼ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    updateTemperatureEffects(deltaTime) {\n        const temp = this.effects.temperature;\n        \n        // ì–¼ìŒ íš¨ê³¼\n        if (temp.current < 0 && temp.effects.freezing) {\n            this.applyFreezingEffects();\n        }\n        \n        // ë…¹ëŠ” íš¨ê³¼\n        if (temp.current > 0 && temp.effects.melting) {\n            this.applyMeltingEffects();\n        }\n        \n        // ì—´íŒ½ì°½ íš¨ê³¼\n        if (temp.effects.expansion) {\n            this.applyThermalExpansion(temp.current);\n        }\n    }\n    \n    /**\n     * ì–¼ìŒ íš¨ê³¼ ì ìš©\n     */\n    applyFreezingEffects() {\n        // ë§ˆì°°ë ¥ ê°ì†Œ (ì–¼ìŒ í‘œë©´)\n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.userData?.name === 'ground') {\n                // ë°”ë‹¥ ë§ˆì°°ë ¥ì„ ì–¼ìŒ ìˆ˜ì¤€ìœ¼ë¡œ ê°ì†Œ\n                if (body.material) {\n                    body.material.friction = this.effects.terrain.friction.ice;\n                }\n            }\n        });\n    }\n    \n    /**\n     * ë…¹ëŠ” íš¨ê³¼ ì ìš©\n     */\n    applyMeltingEffects() {\n        // ì¼€ì´í¬ê°€ ë…¹ëŠ” íš¨ê³¼ (ì§ˆëŸ‰ ê°ì†Œ, ëª¨ì–‘ ë³€í™”)\n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.userData?.name?.includes('cake')) {\n                // ì¼€ì´í¬ ì§ˆëŸ‰ ì ì§„ì  ê°ì†Œ\n                if (body.userData.originalMass === undefined) {\n                    body.userData.originalMass = body.mass;\n                }\n                \n                const meltingRate = 0.001; // ë…¹ëŠ” ì†ë„\n                body.mass = Math.max(body.userData.originalMass * 0.5, body.mass - meltingRate);\n                body.updateMassProperties();\n            }\n        });\n    }\n    \n    /**\n     * ì—´íŒ½ì°½ íš¨ê³¼ ì ìš©\n     * @param {number} temperature - ì˜¨ë„\n     */\n    applyThermalExpansion(temperature) {\n        const expansionCoeff = 0.001; // ì—´íŒ½ì°½ ê³„ìˆ˜\n        const referenceTemp = 20; // ê¸°ì¤€ ì˜¨ë„\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.userData?.thermalExpansion) {\n                const tempDiff = temperature - referenceTemp;\n                const expansionFactor = 1 + (expansionCoeff * tempDiff);\n                \n                // ë°”ë”” í¬ê¸° ì¡°ì • (ë‹¨ìˆœí™”)\n                if (body.shapes[0]) {\n                    const shape = body.shapes[0];\n                    if (shape.type === CANNON.Shape.types.BOX) {\n                        shape.halfExtents.scale(expansionFactor, shape.halfExtents);\n                    } else if (shape.type === CANNON.Shape.types.SPHERE) {\n                        shape.radius *= expansionFactor;\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * ì§€í˜• íš¨ê³¼ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    updateTerrainEffects(deltaTime) {\n        // ê²½ì‚¬ë©´ íš¨ê³¼ ì ìš©\n        this.effects.terrain.slopes.forEach(slope => {\n            this.applySlopeEffect(slope);\n        });\n    }\n    \n    /**\n     * ê²½ì‚¬ë©´ íš¨ê³¼ ì ìš©\n     * @param {Object} slope - ê²½ì‚¬ë©´ ì •ë³´\n     */\n    applySlopeEffect(slope) {\n        const { center, size, angle, direction } = slope;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0) {\n                // ë°”ë””ê°€ ê²½ì‚¬ë©´ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸\n                const bodyPos = body.position;\n                const slopeCenter = new CANNON.Vec3(center.x, center.y, center.z);\n                \n                const distance = Math.sqrt(\n                    Math.pow(bodyPos.x - slopeCenter.x, 2) + \n                    Math.pow(bodyPos.z - slopeCenter.z, 2)\n                );\n                \n                if (distance < size) {\n                    // ê²½ì‚¬ë ¥ ê³„ì‚°\n                    const slopeForce = new CANNON.Vec3(\n                        Math.sin(angle) * direction.x,\n                        0,\n                        Math.sin(angle) * direction.z\n                    );\n                    \n                    slopeForce.scale(body.mass * Math.abs(this.physicsManager.world.gravity.y), slopeForce);\n                    body.applyForce(slopeForce, body.position);\n                }\n            }\n        });\n    }\n    \n    /**\n     * ëŒ€ê¸° íš¨ê³¼ ì—…ë°ì´íŠ¸\n     * @param {number} deltaTime - ë¸íƒ€ ì‹œê°„\n     */\n    updateAtmosphereEffects(deltaTime) {\n        const atmosphere = this.effects.atmosphere;\n        \n        // ê³µê¸° ì €í•­ ì ìš©\n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0 && body.velocity.length() > 0.1) {\n                const dragForce = body.velocity.clone();\n                dragForce.scale(-atmosphere.resistance * atmosphere.density, dragForce);\n                body.applyForce(dragForce, body.position);\n            }\n        });\n    }\n    \n    /**\n     * í™˜ê²½ êµ¬ì—­ íš¨ê³¼ ì ìš©\n     */\n    applyEnvironmentalZones() {\n        this.environmentalZones.forEach((zone, zoneName) => {\n            this.applyZoneEffect(zone);\n        });\n    }\n    \n    /**\n     * êµ¬ì—­ íš¨ê³¼ ì ìš©\n     * @param {Object} zone - í™˜ê²½ êµ¬ì—­\n     */\n    applyZoneEffect(zone) {\n        const { center, radius, effects } = zone;\n        \n        this.physicsManager.world.bodies.forEach(body => {\n            if (body.mass > 0) {\n                const distance = body.position.distanceTo(new CANNON.Vec3(center.x, center.y, center.z));\n                \n                if (distance < radius) {\n                    const intensity = 1 - (distance / radius);\n                    \n                    // êµ¬ì—­ë³„ íš¨ê³¼ ì ìš©\n                    Object.keys(effects).forEach(effectType => {\n                        this.applyZoneEffectToBody(body, effectType, effects[effectType], intensity);\n                    });\n                }\n            }\n        });\n    }\n    \n    /**\n     * ë°”ë””ì— êµ¬ì—­ íš¨ê³¼ ì ìš©\n     * @param {CANNON.Body} body - ë¬¼ë¦¬ ë°”ë””\n     * @param {string} effectType - íš¨ê³¼ íƒ€ì…\n     * @param {*} effectValue - íš¨ê³¼ ê°’\n     * @param {number} intensity - ê°•ë„\n     */\n    applyZoneEffectToBody(body, effectType, effectValue, intensity) {\n        switch (effectType) {\n            case 'gravity':\n                const gravityForce = new CANNON.Vec3(0, effectValue * intensity * body.mass, 0);\n                body.applyForce(gravityForce, body.position);\n                break;\n                \n            case 'friction':\n                if (body.material) {\n                    body.material.friction = effectValue * intensity;\n                }\n                break;\n                \n            case 'damping':\n                body.linearDamping = effectValue * intensity;\n                break;\n                \n            case 'force':\n                const force = new CANNON.Vec3(\n                    effectValue.x * intensity,\n                    effectValue.y * intensity,\n                    effectValue.z * intensity\n                );\n                body.applyForce(force, body.position);\n                break;\n        }\n    }\n    \n    /**\n     * ì‹œê°„ì— ë”°ë¥¸ ì˜¨ë„ ì—…ë°ì´íŠ¸\n     * @param {number} timeOfDay - í•˜ë£¨ ì¤‘ ì‹œê°„ (0-1)\n     */\n    updateTemperatureByTime(timeOfDay) {\n        // ê°„ë‹¨í•œ ì‚¬ì¸íŒŒ ê¸°ë°˜ ì˜¨ë„ ë³€í™”\n        const baseTemp = 20;\n        const tempVariation = 15;\n        const temp = baseTemp + Math.sin((timeOfDay - 0.25) * Math.PI * 2) * tempVariation;\n        \n        this.effects.temperature.current = temp;\n    }\n    \n    /**\n     * ì‹œê°„ì— ë”°ë¥¸ ë°”ëŒ ì—…ë°ì´íŠ¸\n     * @param {number} timeOfDay - í•˜ë£¨ ì¤‘ ì‹œê°„ (0-1)\n     */\n    updateWindByTime(timeOfDay) {\n        // ë‚®ì—ëŠ” ë°”ëŒì´ ê°•í•˜ê³ , ë°¤ì—ëŠ” ì•½í•¨\n        const baseStrength = 2.0;\n        const variation = 1.5;\n        const strength = baseStrength + Math.sin(timeOfDay * Math.PI * 2) * variation;\n        \n        this.effects.wind.strength = Math.max(0, strength);\n    }\n    \n    /**\n     * ë‚ ì”¨ íš¨ê³¼ ì ìš©\n     * @param {string} weatherType - ë‚ ì”¨ íƒ€ì…\n     * @param {number} intensity - ê°•ë„\n     */\n    applyWeatherEffects(weatherType, intensity) {\n        switch (weatherType) {\n            case 'rain':\n                this.effects.terrain.friction.base *= (1 - intensity * 0.3); // ë¯¸ë„ëŸ¬ì›€\n                this.effects.wind.strength += intensity * 2; // ë°”ëŒ ì¦ê°€\n                break;\n                \n            case 'snow':\n                this.effects.temperature.current -= intensity * 10; // ì˜¨ë„ í•˜ê°•\n                this.effects.terrain.friction.base *= (1 - intensity * 0.5); // ë§¤ìš° ë¯¸ë„ëŸ¬ì›€\n                break;\n                \n            case 'storm':\n                this.effects.wind.strength += intensity * 5; // ê°•í•œ ë°”ëŒ\n                this.effects.wind.turbulence += intensity * 0.3; // ë‚œê¸°ë¥˜ ì¦ê°€\n                break;\n        }\n    }\n    \n    /**\n     * ë‚ ì”¨ íš¨ê³¼ ì¢…ë£Œ\n     */\n    endWeatherEffect() {\n        // ë‚ ì”¨ íš¨ê³¼ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì›\n        this.effects.terrain.friction.base = 0.5;\n        this.effects.wind.strength = 0;\n        this.effects.wind.turbulence = 0.1;\n        this.effects.temperature.current = 20;\n        \n        this.timeEffects.weather.enabled = false;\n        this.timeEffects.weather.current = 'clear';\n        \n        console.log('ğŸŒ¤ï¸ ë‚ ì”¨ íš¨ê³¼ ì¢…ë£Œ');\n    }\n    \n    /**\n     * ë°”ëŒ ì„¤ì •\n     * @param {boolean} enabled - í™œì„±í™”\n     * @param {number} strength - ê°•ë„\n     * @param {Object} direction - ë°©í–¥\n     * @param {number} turbulence - ë‚œê¸°ë¥˜\n     */\n    setWind(enabled, strength = 0, direction = { x: 1, y: 0, z: 0 }, turbulence = 0.1) {\n        this.effects.wind.enabled = enabled;\n        this.effects.wind.strength = strength;\n        this.effects.wind.direction = direction;\n        this.effects.wind.turbulence = turbulence;\n        \n        console.log(`ğŸ’¨ ë°”ëŒ ì„¤ì •: ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'} (ê°•ë„: ${strength})`);\n    }\n    \n    /**\n     * ì¤‘ë ¥ ì´ìƒ ì§€ì—­ ì¶”ê°€\n     * @param {string} name - ì´ë¦„\n     * @param {Object} center - ì¤‘ì‹¬ì \n     * @param {number} radius - ë°˜ê²½\n     * @param {number} strength - ê°•ë„\n     * @param {string} type - íƒ€ì… (low, high, zero)\n     */\n    addGravityAnomaly(name, center, radius, strength, type = 'low') {\n        const anomaly = { center, radius, strength, type };\n        this.effects.gravity.anomalies.push(anomaly);\n        \n        console.log(`ğŸŒ ì¤‘ë ¥ ì´ìƒ ì§€ì—­ ì¶”ê°€: ${name} (${type})`);\n    }\n    \n    /**\n     * í™˜ê²½ êµ¬ì—­ ì¶”ê°€\n     * @param {string} name - êµ¬ì—­ ì´ë¦„\n     * @param {Object} center - ì¤‘ì‹¬ì \n     * @param {number} radius - ë°˜ê²½\n     * @param {Object} effects - íš¨ê³¼ë“¤\n     */\n    addEnvironmentalZone(name, center, radius, effects) {\n        this.environmentalZones.set(name, {\n            center,\n            radius,\n            effects\n        });\n        \n        console.log(`ğŸï¸ í™˜ê²½ êµ¬ì—­ ì¶”ê°€: ${name}`);\n    }\n    \n    /**\n     * ê²½ì‚¬ë©´ ì¶”ê°€\n     * @param {Object} center - ì¤‘ì‹¬ì \n     * @param {number} size - í¬ê¸°\n     * @param {number} angle - ê°ë„ (ë¼ë””ì•ˆ)\n     * @param {Object} direction - ë°©í–¥\n     */\n    addSlope(center, size, angle, direction) {\n        this.effects.terrain.slopes.push({\n            center,\n            size,\n            angle,\n            direction\n        });\n        \n        console.log(`â›°ï¸ ê²½ì‚¬ë©´ ì¶”ê°€: ê°ë„ ${(angle * 180 / Math.PI).toFixed(1)}ë„`);\n    }\n    \n    /**\n     * ë‚ ì”¨ ì„¤ì •\n     * @param {string} weatherType - ë‚ ì”¨ íƒ€ì…\n     * @param {number} intensity - ê°•ë„\n     * @param {number} duration - ì§€ì† ì‹œê°„\n     */\n    setWeather(weatherType, intensity = 1.0, duration = 60) {\n        this.timeEffects.weather.enabled = true;\n        this.timeEffects.weather.current = weatherType;\n        this.timeEffects.weather.intensity = intensity;\n        this.timeEffects.weather.duration = duration;\n        \n        console.log(`ğŸŒ¦ï¸ ë‚ ì”¨ ì„¤ì •: ${weatherType} (ê°•ë„: ${intensity}, ì§€ì†: ${duration}ì´ˆ)`);\n    }\n    \n    /**\n     * ë‚®ë°¤ ì‚¬ì´í´ ì„¤ì •\n     * @param {boolean} enabled - í™œì„±í™”\n     * @param {number} speed - ì†ë„\n     * @param {number} startTime - ì‹œì‘ ì‹œê°„\n     */\n    setDayNightCycle(enabled, speed = 0.001, startTime = 0.5) {\n        this.timeEffects.dayNightCycle.enabled = enabled;\n        this.timeEffects.dayNightCycle.speed = speed;\n        this.timeEffects.dayNightCycle.timeOfDay = startTime;\n        \n        console.log(`ğŸŒ… ë‚®ë°¤ ì‚¬ì´í´: ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);\n    }\n    \n    /**\n     * í˜„ì¬ í™˜ê²½ ìƒíƒœ ë°˜í™˜\n     * @returns {Object}\n     */\n    getEnvironmentalState() {\n        return {\n            wind: { ...this.effects.wind },\n            temperature: { ...this.effects.temperature },\n            weather: { ...this.timeEffects.weather },\n            timeOfDay: this.timeEffects.dayNightCycle.timeOfDay,\n            zones: this.environmentalZones.size,\n            anomalies: this.effects.gravity.anomalies.length\n        };\n    }\n    \n    /**\n     * ì •ë¦¬\n     */\n    cleanup() {\n        console.log('ğŸ§¹ í™˜ê²½ ë¬¼ë¦¬ ì‹œìŠ¤í…œ ì •ë¦¬ ì‹œì‘...');\n        \n        // í™˜ê²½ êµ¬ì—­ ì •ë¦¬\n        this.environmentalZones.clear();\n        \n        // ì¤‘ë ¥ ì´ìƒ ì§€ì—­ ì •ë¦¬\n        this.effects.gravity.anomalies = [];\n        \n        // ê²½ì‚¬ë©´ ì •ë¦¬\n        this.effects.terrain.slopes = [];\n        \n        console.log('âœ… í™˜ê²½ ë¬¼ë¦¬ ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ');\n    }\n    \n    /**\n     * ë””ë²„ê·¸ ì •ë³´ ë°˜í™˜\n     * @returns {Object}\n     */\n    getDebugInfo() {\n        return {\n            effects: this.effects,\n            timeEffects: this.timeEffects,\n            environmentalZones: Array.from(this.environmentalZones.keys()),\n            performance: this.performance\n        };\n    }\n}"