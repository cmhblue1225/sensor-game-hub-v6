<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è Rhythm Blade Dual</title>
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --sensor1-color: #ef4444;  /* Red for left player */
            --sensor2-color: #3b82f6;  /* Blue for right player */
            --cooperation-color: #8b5cf6; /* Purple for cooperation */
            --background: #0f172a;
            --surface: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --border: #475569;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0f172a, #1e293b);
        }
        
        .game-ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.25rem;
            backdrop-filter: blur(12px);
            pointer-events: all;
        }
        
        .session-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            min-width: 350px;
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            overflow-y: auto;
        }
        
        .session-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, var(--sensor1-color), var(--sensor2-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .session-code {
            font-size: 2.5rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            color: var(--primary);
            margin: 1rem 0;
            padding: 0.75rem;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--primary);
            border-radius: 0.75rem;
            letter-spacing: 0.3em;
        }
        
        .qr-container {
            margin: 1rem 0;
            padding: 0.75rem;
            background: white;
            border-radius: 0.75rem;
            display: inline-block;
        }
        
        .sensor-status {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin: 2rem 0;
        }
        
        .sensor-info {
            padding: 1rem;
            border-radius: 0.5rem;
            min-width: 150px;
            text-align: center;
            border: 2px solid;
        }
        
        .sensor1 {
            border-color: var(--sensor1-color);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .sensor2 {
            border-color: var(--sensor2-color);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .sensor-label {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .sensor-state {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .game-stats {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: grid;
            gap: 1rem;
            min-width: 200px;
        }
        
        .stat-item {
            background: rgba(30, 41, 59, 0.8);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        
        .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
        }
        
        .cooperation-meter {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 200px;
        }
        
        .meter-label {
            text-align: center;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--cooperation-color);
        }
        
        .meter-bar {
            height: 20px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--cooperation-color);
        }
        
        .meter-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, var(--sensor1-color), var(--cooperation-color), var(--sensor2-color));
            transition: width 0.3s ease;
        }
        
        .control-panel {
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1rem;
        }
        
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            text-decoration: none;
            display: inline-block;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .hidden {
            display: none !important;
        }
        
        .game-instructions {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            max-width: 300px;
            font-size: 0.9rem;
            background: rgba(30, 41, 59, 0.8);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }
        
        .instruction-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--cooperation-color);
        }
        
        .instruction-item {
            margin-bottom: 0.5rem;
            padding-left: 1rem;
            position: relative;
        }
        
        .instruction-item::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: var(--primary);
        }
        
        /* üéµ ÏùåÏïÖ ÏÑ†ÌÉù UI Ïä§ÌÉÄÏùº */
        .music-selection {
            margin: 1rem 0;
            padding: 0.75rem;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }
        
        .music-title {
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--primary);
        }
        
        .music-tracks {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.4rem;
            margin-bottom: 0.75rem;
            max-height: 12rem;
            overflow-y: auto;
        }
        
        .track-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.4rem 0.3rem;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid transparent;
            border-radius: 0.4rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 3.5rem;
            aspect-ratio: 1.2;
        }
        
        .track-option:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--primary);
            transform: translateY(-2px);
        }
        
        .track-option.selected {
            background: rgba(59, 130, 246, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
        }
        
        .track-icon {
            font-size: 1.2rem;
            margin-bottom: 0.15rem;
        }
        
        .track-name {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 0.1rem;
            line-height: 1;
        }
        
        .track-details {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1;
        }
        
        .track-status {
            position: absolute;
            top: 0.2rem;
            right: 0.2rem;
            font-size: 0.8rem;
            color: var(--success);
        }
        
        .selected-track-info {
            text-align: center;
            padding: 0.4rem;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 0.4rem;
            font-size: 0.75rem;
            border: 1px solid var(--primary);
            color: var(--primary);
            font-weight: 600;
        }
        
        #selectedTrackName {
            color: var(--success);
        }
        
        /* ÏùåÏïÖ Ìä∏Îûô Ïä§ÌÅ¨Î°§Î∞î Ïä§ÌÉÄÏùº */
        .music-tracks::-webkit-scrollbar {
            width: 4px;
        }
        
        .music-tracks::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 2px;
        }
        
        .music-tracks::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 2px;
        }
        
        .music-tracks::-webkit-scrollbar-thumb:hover {
            background: var(--secondary);
        }
        
        /* Î∞òÏùëÌòï ÎîîÏûêÏù∏ */
        @media (max-width: 480px) {
            .music-tracks {
                grid-template-columns: repeat(2, 1fr);
                max-height: 14rem;
            }
            
            .track-option {
                min-height: 4rem;
                padding: 0.5rem 0.3rem;
            }
            
            .track-icon {
                font-size: 1.4rem;
            }
            
            .track-name {
                font-size: 0.75rem;
            }
        }
        
        @media (max-width: 360px) {
            .music-tracks {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.3rem;
            }
            
            .track-option {
                min-height: 3.8rem;
            }
            
            .track-name {
                font-size: 0.7rem;
            }
            
            .track-details {
                font-size: 0.55rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui">
        <!-- ÏÑ∏ÏÖò ÎåÄÍ∏∞ Ìå®ÎÑê -->
        <div class="ui-panel session-panel" id="sessionPanel">
            <div class="session-title">‚öîÔ∏è Rhythm Blade Dual</div>
            <div style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                Îëê Î™ÖÏù¥ ÌòëÎ†•ÌïòÏó¨ ÌîåÎ†àÏù¥ÌïòÎäî 3D Î¶¨Îì¨ Í≤åÏûÑ!<br>
                ÏÑ†ÌÉùÌïú ÏùåÏïÖÏóê ÎßûÏ∂ò ÌäπÎ≥ÑÌïú ÎπÑÌä∏ÎßµÏúºÎ°ú ÌîåÎ†àÏù¥ÌïòÏÑ∏Ïöî!<br>
                ÏôÑÎ≤ΩÌïú ÌÉÄÏù¥Î∞çÍ≥º ÌòëÎ†•ÏúºÎ°ú ÏµúÍ≥† Ï†êÏàòÎ•º Îã¨ÏÑ±ÌïòÏÑ∏Ïöî!
            </div>
            
            <!-- üéµ ÏùåÏïÖ ÏÑ†ÌÉù ÏÑπÏÖò -->
            <div class="music-selection" id="musicSelection">
                <div class="music-title">üéµ ÏùåÏïÖ ÏÑ†ÌÉù</div>
                <div class="music-tracks">
                    <div class="track-option" data-track="electric-storm" id="track-electric-storm">
                        <div class="track-icon">‚ö°</div>
                        <div class="track-name">Electric Storm</div>
                        <div class="track-details">Electronic</div>
                        <div class="track-status">‚úì</div>
                    </div>
                    <div class="track-option" data-track="neon-nights" id="track-neon-nights">
                        <div class="track-icon">üåô</div>
                        <div class="track-name">Neon Nights</div>
                        <div class="track-details">Synthwave</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="cyber-beat" id="track-cyber-beat">
                        <div class="track-icon">ü§ñ</div>
                        <div class="track-name">Cyber Beat</div>
                        <div class="track-details">Techno</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="space-rhythm" id="track-space-rhythm">
                        <div class="track-icon">üöÄ</div>
                        <div class="track-name">Space Rhythm</div>
                        <div class="track-details">Ambient</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="fire-dance" id="track-fire-dance">
                        <div class="track-icon">üî•</div>
                        <div class="track-name">Fire Dance</div>
                        <div class="track-details">Drum&Bass</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="ocean-waves" id="track-ocean-waves">
                        <div class="track-icon">üåä</div>
                        <div class="track-name">Ocean Waves</div>
                        <div class="track-details">Chill</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="crystal-cave" id="track-crystal-cave">
                        <div class="track-icon">üíé</div>
                        <div class="track-name">Crystal Cave</div>
                        <div class="track-details">Progressive</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="neon-city" id="track-neon-city">
                        <div class="track-icon">üèôÔ∏è</div>
                        <div class="track-name">Neon City</div>
                        <div class="track-details">Retrowave</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="thunder-storm" id="track-thunder-storm">
                        <div class="track-icon">‚õàÔ∏è</div>
                        <div class="track-name">Thunder Storm</div>
                        <div class="track-details">Hardcore</div>
                        <div class="track-status"></div>
                    </div>
                    <div class="track-option" data-track="starlight" id="track-starlight">
                        <div class="track-icon">‚ú®</div>
                        <div class="track-name">Starlight</div>
                        <div class="track-details">Melodic</div>
                        <div class="track-status"></div>
                    </div>
                </div>
                <div class="selected-track-info" id="selectedTrackInfo">
                    <span id="selectedTrackName">Electric Storm</span> ÏÑ†ÌÉùÎê®
                </div>
            </div>
            
            <div class="session-code" id="sessionCode">----</div>
            
            <div class="qr-container" id="qrContainer">
                <div style="color: #666; padding: 2rem;">QR ÏΩîÎìú ÏÉùÏÑ± Ï§ë...</div>
            </div>
            
            <div class="sensor-status">
                <div class="sensor-info sensor1">
                    <div class="sensor-label">üî¥ Player 1 (Left)</div>
                    <div class="sensor-state" id="sensor1Status">ÎåÄÍ∏∞ Ï§ë...</div>
                </div>
                <div class="sensor-info sensor2">
                    <div class="sensor-label">üîµ Player 2 (Right)</div>
                    <div class="sensor-state" id="sensor2Status">ÎåÄÍ∏∞ Ï§ë...</div>
                </div>
            </div>
            
            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 1rem;">
                üì± Îëê Î™ÖÏùò ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Í∞ÅÏûê Î™®Î∞îÏùºÎ°ú QR ÏΩîÎìúÎ•º Ïä§Ï∫îÌïòÍ±∞ÎÇò<br>
                ÏÑºÏÑú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÏÑ∏ÏÖò ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî
            </div>
        </div>
        
        <!-- Í≤åÏûÑ ÌÜµÍ≥Ñ Ìå®ÎÑê -->
        <div class="ui-panel game-stats hidden" id="gameStats">
            <div class="stat-item">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="scoreValue">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Combo</div>
                <div class="stat-value" id="comboValue">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracyValue">100%</div>
            </div>
        </div>
        
        <!-- ÌòëÎ†• ÎØ∏ÌÑ∞ -->
        <div class="ui-panel cooperation-meter hidden" id="cooperationMeter">
            <div class="meter-label">Cooperation Sync</div>
            <div class="meter-bar">
                <div class="meter-fill" id="cooperationFill"></div>
            </div>
        </div>
        
        <!-- Ïª®Ìä∏Î°§ Ìå®ÎÑê -->
        <div class="ui-panel control-panel hidden" id="controlPanel">
            <button class="btn btn-secondary" onclick="game.resetGame()">üîÑ Ïû¨ÏãúÏûë</button>
            <button class="btn btn-secondary" onclick="game.togglePause()">‚è∏Ô∏è ÏùºÏãúÏ†ïÏßÄ</button>
            <a href="/" class="btn btn-secondary">üè† ÌóàÎ∏åÎ°ú</a>
        </div>
        
        <!-- ‚úÖ Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ Í≤åÏûÑ ÏÑ§Î™Ö (ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº) -->
        <div class="game-instructions hidden" id="gameInstructions">
            <div class="instruction-title">üéµ Rhythm Blade Í≤åÏûÑ Î∞©Î≤ï</div>
            <div class="instruction-item">üéØ Î∞îÎã•Ïùò ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº Í∞ÄÏù¥ÎìúÎùºÏù∏ÏúºÎ°ú ÏôÑÎ≤ΩÌïú ÌÉÄÏù¥Î∞ç!</div>
            <div class="instruction-item">üî¥ Îπ®Í∞Ñ Î∞îÎã• Ìå®Îìú: ÌîåÎ†àÏù¥Ïñ¥1, Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïä§Ïúô</div>
            <div class="instruction-item">üîµ ÌååÎûÄ Î∞îÎã• Ìå®Îìú: ÌîåÎ†àÏù¥Ïñ¥2, ÏôºÏ™ΩÏúºÎ°ú Ïä§Ïúô</div>
            <div class="instruction-item">üü£ Î≥¥Îùº Î∞îÎã• Ìå®Îìú: ÌòëÎ†• ÎÖ∏Ìä∏ (ÎèôÏãú ÌÉÄÍ≤©)</div>
            <div class="instruction-item">‚ú® ÎÖ∏Ìä∏Í∞Ä Î∞îÎã• ÏõêÌòï Ïù∏ÎîîÏºÄÏù¥ÌÑ∞Ïóê ÎèÑÎã¨Ìï† Îïå ÌÉÄÍ≤©!</div>
            <div class="instruction-item">üõ§Ô∏è Ìä∏Îûô ÎùºÏù∏ÏùÑ Îî∞Îùº Îã§Í∞ÄÏò§Îäî ÎÖ∏Ìä∏Î•º Ï∂îÏ†ÅÌïòÏÑ∏Ïöî</div>
            <div class="instruction-item">üéµ 128 BPM Î∞ïÏûêÏóê ÎßûÏ∂ò Î∞îÎã• ÌéÑÏä§ Ìö®Í≥º</div>
            <div class="instruction-item">‚å®Ô∏è ÌÖåÏä§Ìä∏: Q(ÏôºÏ™Ω), E(Ïò§Î•∏Ï™Ω), Space(ÌòëÎ†•)</div>
        </div>
    </div>
    
    <!-- üéµ Î∞∞Í≤Ω ÏùåÏïÖ - NCS Î¨¥Î£å ÏùåÏïÖ -->
    <audio id="bgMusic" loop preload="auto">
        <!-- NCS - Invincible -->
        <source src="https://ncsmusic.s3.eu-west-1.amazonaws.com/tracks/000/000/436/invincible-1594303577-xVcWl8s6uH.mp3" type="audio/mpeg">
        <!-- ÎåÄÏ≤¥ NCS ÏùåÏïÖ -->
        <source src="https://ncsmusic.s3.eu-west-1.amazonaws.com/tracks/000/000/152/1654766391_N6uRkX7YQX_Elektronomia---Summersong-2018-NCS-Release.mp3" type="audio/mpeg">
        <!-- Ìè¥Î∞±: Î¨¥Î£å ÏùºÎ†âÌä∏Î°úÎãâ ÏùåÏïÖ -->
        <source src="https://www.bensound.com/bensound-music/bensound-energy.mp3" type="audio/mpeg">
        <!-- ÏµúÏ¢Ö Ìè¥Î∞±: Î°úÏª¨ ÏÉùÏÑ± ÎπÑÌä∏ -->
        <source src="data:audio/wav;base64,UklGRiQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQADAAA=" type="audio/wav">
    </audio>
    
    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- QR Code Generator (Ìè¥Î∞± Ï≤òÎ¶¨ Ìè¨Ìï®) -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- SessionSDK -->
    <script src="/js/SessionSDK.js"></script>
    
    <script>
        class RhythmBladeDual {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                
                // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // ‚úÖ Ïò¨Î∞îÎ•∏ SDK Ï¥àÍ∏∞Ìôî (dual ÌÉÄÏûÖ)
                this.sdk = new SessionSDK({
                    gameId: 'rhythm-blade',
                    gameType: 'dual',         // dual ÌÉÄÏûÖÏúºÎ°ú ÏÑ§Ï†ï
                    debug: true
                });
                
                // Í≤åÏûÑ ÏÉÅÌÉú
                this.gameState = {
                    phase: 'waiting',         // waiting, playing, paused, ended
                    score: 0,
                    combo: 0,
                    maxCombo: 0,             // ÏµúÎåÄ ÏΩ§Î≥¥ Ï∂îÏ†Å
                    totalNotes: 0,
                    hitNotes: 0,
                    startTime: 0,
                    endingStartTime: 0        // Í≤åÏûÑ Ï¢ÖÎ£å ÏãúÏûë ÏãúÍ∞Ñ
                };
                
                // ÏÑºÏÑú Ïó∞Í≤∞ ÏÉÅÌÉú
                this.sensorStatus = {
                    sensor1: { connected: false, lastSwing: 0 },
                    sensor2: { connected: false, lastSwing: 0 }
                };
                
                // ÌòëÎ†• ÏãúÏä§ÌÖú
                this.cooperation = {
                    sync: 100,               // ÌòëÎ†• ÎèôÍ∏∞Ìôî ÏàòÏπò
                    recentHits: [],          // ÏµúÍ∑º ÌûàÌä∏ Í∏∞Î°ù
                    cooperationBonus: 1.0    // ÌòëÎ†• Î≥¥ÎÑàÏä§ Î∞∞Ïàò
                };
                
                // üéµ Îã§Ï§ë ÏùåÏïÖ ÏãúÏä§ÌÖú - ÏÑ†ÌÉù Í∞ÄÎä•Ìïú Ìä∏ÎûôÎì§
                this.bgMusic = document.getElementById('bgMusic');
                this.musicLoaded = false;
                this.currentTrack = 'electric-storm'; // Í∏∞Î≥∏ ÏÑ†ÌÉù Ìä∏Îûô
                
                // üéº ÏùåÏïÖ Ìä∏Îûô Ï†ïÎ≥¥ (Í∞ôÏùÄ ÏùåÏïÖ, Îã§Î•∏ Ïù¥Î¶ÑÍ≥º ÏÑ§Ï†ï)
                this.tracks = {
                    'electric-storm': {
                        name: 'Electric Storm',
                        icon: '‚ö°',
                        description: '128 BPM ‚Ä¢ Electronic ‚Ä¢ 45Ï¥à',
                        bpm: 128,
                        sources: [
                            'https://ncsmusic.s3.eu-west-1.amazonaws.com/tracks/000/000/436/invincible-1594303577-xVcWl8s6uH.mp3',
                            'https://ncsmusic.s3.eu-west-1.amazonaws.com/tracks/000/000/152/1654766391_N6uRkX7YQX_Elektronomia---Summersong-2018-NCS-Release.mp3',
                            'https://www.bensound.com/bensound-music/bensound-energy.mp3'
                        ]
                    },
                    'neon-nights': {
                        name: 'Neon Nights',
                        icon: 'üåô',
                        description: '128 BPM ‚Ä¢ Synthwave ‚Ä¢ 45Ï¥à',
                        bpm: 128,
                        sources: [
                            'https://ncsmusic.s3.eu-west-1.amazonaws.com/tracks/000/000/436/invincible-1594303577-xVcWl8s6uH.mp3',
                            'https://ncsmusic.s3.eu-west-1.amazonaws.com/tracks/000/000/152/1654766391_N6uRkX7YQX_Elektronomia---Summersong-2018-NCS-Release.mp3',
                            'https://www.bensound.com/bensound-music/bensound-energy.mp3'
                        ]
                    }
                };
                
                this.bpm = this.tracks[this.currentTrack].bpm;
                this.beatInterval = 60 / this.bpm; // ÎπÑÌä∏ Í∞ÑÍ≤© Í≥ÑÏÇ∞
                
                this.initializeMusic();
                
                // Three.js Ï¥àÍ∏∞Ìôî
                this.initThreeJS();
                
                // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞
                this.notes = [];
                this.noteSpawnIndex = 0;
                this.particleEffects = [];
                
                // üéµ Î¶¨Îì¨Ïóê ÎßûÎäî ÎπÑÌä∏Îßµ (ÏÑ†ÌÉùÎêú Ìä∏Îûô Í∏∞Ï§Ä)
                this.beatmap = this.generateRhythmBeatmap();
                
                this.gameState.totalNotes = this.beatmap.length;
                
                // üéµ ÏùåÏïÖ ÏÑ†ÌÉù ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
                this.setupMusicSelection();
                
                this.setupEventListeners();
                this.gameLoop();
            }
            
            initializeMusic() {
                // üéµ ÏÑ†ÌÉùÎêú Ìä∏ÎûôÏóê Îî∞Î•∏ ÏùåÏïÖ Î°úÎìú
                this.loadTrack(this.currentTrack);
            }
            
            loadTrack(trackId) {
                // üéµ Ìä∏Îûô Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                const track = this.tracks[trackId];
                if (!track) {
                    console.error(`Ìä∏ÎûôÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${trackId}`);
                    return;
                }
                
                // BPM ÏóÖÎç∞Ïù¥Ìä∏
                this.bpm = track.bpm;
                this.beatInterval = 60 / this.bpm;
                
                // üéµ audio ÏóòÎ¶¨Î®ºÌä∏ ÏÜåÏä§ ÏóÖÎç∞Ïù¥Ìä∏
                this.bgMusic.innerHTML = '';
                track.sources.forEach(src => {
                    const source = document.createElement('source');
                    source.src = src;
                    source.type = 'audio/mpeg';
                    this.bgMusic.appendChild(source);
                });
                
                // ÏµúÏ¢Ö Ìè¥Î∞± Ï∂îÍ∞Ä
                const fallbackSource = document.createElement('source');
                fallbackSource.src = 'data:audio/wav;base64,UklGRiQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQADAAA=';
                fallbackSource.type = 'audio/wav';
                this.bgMusic.appendChild(fallbackSource);
                
                // üéµ ÏùåÏïÖ ÏÑ§Ï†ï
                this.bgMusic.volume = 0.6;
                this.bgMusic.currentTime = 0;
                this.musicLoaded = false;
                
                // ÏùåÏïÖ Î°úÎìú ÏôÑÎ£å Ïù¥Î≤§Ìä∏
                this.bgMusic.addEventListener('canplaythrough', () => {
                    this.musicLoaded = true;
                    console.log(`üéµ ${track.name} Î°úÎìú ÏôÑÎ£å`);
                });
                
                // ÏùåÏïÖ Ïû¨ÏÉù Ïò§Î•ò Ï≤òÎ¶¨
                this.bgMusic.addEventListener('error', (e) => {
                    console.warn(`üéµ ${track.name} Î°úÎìú Ïã§Ìå®, Î¨¥Ïùå Î™®ÎìúÎ°ú ÏßÑÌñâ`);
                    this.musicLoaded = false;
                });
                
                // ÏùåÏïÖ Î°úÎìú ÏãúÎèÑ
                this.bgMusic.load();
                
                console.log(`üéµ ${track.name} Ìä∏Îûô Î°úÎî© Ï§ë...`);
            }
            
            // üéµ ÏùåÏïÖ ÏÑ†ÌÉù ÏãúÏä§ÌÖú ÏÑ§Ï†ï
            setupMusicSelection() {
                // Ìä∏Îûô ÏòµÏÖò ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
                document.querySelectorAll('.track-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const trackId = option.getAttribute('data-track');
                        this.selectTrack(trackId);
                    });
                });
                
                // Ï¥àÍ∏∞ ÏÑ†ÌÉù ÏÉÅÌÉú ÏÑ§Ï†ï
                this.updateTrackSelection();
            }
            
            selectTrack(trackId) {
                if (this.gameState.phase === 'playing') {
                    console.warn('Í≤åÏûÑ ÏßÑÌñâ Ï§ëÏóêÎäî Ìä∏ÎûôÏùÑ Î≥ÄÍ≤ΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
                    return;
                }
                
                this.currentTrack = trackId;
                
                // üéµ ÏÉà Ìä∏Îûô Î°úÎìú
                this.loadTrack(trackId);
                
                // üéº ÏÉà ÎπÑÌä∏Îßµ ÏÉùÏÑ±
                this.beatmap = this.generateRhythmBeatmap();
                this.gameState.totalNotes = this.beatmap.length;
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                this.updateTrackSelection();
                
                console.log(`üéµ Ìä∏Îûô Î≥ÄÍ≤Ω: ${this.tracks[trackId].name}`);
            }
            
            updateTrackSelection() {
                // Î™®Îì† Ìä∏Îûô ÏòµÏÖò ÏÑ†ÌÉù Ìï¥Ï†ú
                document.querySelectorAll('.track-option').forEach(option => {
                    option.classList.remove('selected');
                    option.querySelector('.track-status').textContent = '';
                });
                
                // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ìä∏Îûô Í∞ïÏ°∞
                const selectedOption = document.getElementById(`track-${this.currentTrack}`);
                if (selectedOption) {
                    selectedOption.classList.add('selected');
                    selectedOption.querySelector('.track-status').textContent = '‚úì';
                }
                
                // ÏÑ†ÌÉùÎêú Ìä∏Îûô Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                const track = this.tracks[this.currentTrack];
                document.getElementById('selectedTrackName').textContent = track.name;
            }
            
            generateRhythmBeatmap() {
                // üéµ ÏÑ†ÌÉùÎêú Ìä∏ÎûôÏóê Îî∞Î•∏ ÎßûÏ∂§Ìòï ÎπÑÌä∏Îßµ ÏÉùÏÑ±
                const track = this.tracks[this.currentTrack];
                console.log(`üéº ${track.name} ÎπÑÌä∏Îßµ ÏÉùÏÑ± Ï§ë...`);
                
                // BPMÏóê Îî∞Î•∏ ÎπÑÌä∏ Í∞ÑÍ≤© Í≥ÑÏÇ∞ (ÏÑºÏÑú ÎîúÎ†àÏù¥ ÏµúÏ†ÅÌôî)
                const beat = this.beatInterval; // ÌòÑÏû¨ Ìä∏ÎûôÏùò BPM Í∏∞Ï§Ä
                const halfBeat = beat / 2; // ÏÑºÏÑú ÎîúÎ†àÏù¥Î°ú Ïó∞ÏÜç Î∂àÍ∞Ä
                const quarterBeat = beat / 4; // ÏÑºÏÑú ÎîúÎ†àÏù¥Î°ú Î∂àÍ∞Ä
                const doubleBeat = beat * 2; // Ïó¨Ïú†Î°úÏö¥ Í∞ÑÍ≤©
                
                // üéº Ìä∏ÎûôÎ≥Ñ ÎßûÏ∂§Ìòï ÎπÑÌä∏Îßµ ÏÉùÏÑ±
                if (this.currentTrack === 'electric-storm') {
                    return this.generateElectricStormBeatmap(beat, halfBeat, doubleBeat);
                } else if (this.currentTrack === 'neon-nights') {
                    return this.generateNeonNightsBeatmap(beat, halfBeat, doubleBeat);
                } else {
                    // Í∏∞Î≥∏ Ìå®ÌÑ¥
                    return this.generateDefaultBeatmap(beat, halfBeat, doubleBeat);
                }
            }
            
            generateElectricStormBeatmap(beat, halfBeat, doubleBeat) {
                // ‚ö° Electric Storm - ÏóêÎÑàÏßÄ ÎÑòÏπòÎäî Ï†ÑÍ∏∞Ï†Å Ìå®ÌÑ¥ (Í∞ïÎ†¨ÌïòÍ≥† ÏßÅÏÑ†Ï†Å)
                const beatmap = [];
                
                // ‚ö° Ï†ÑÍ∏∞Ï†Å ÏãúÏûë - Î≤àÍ∞ú Í∞ôÏùÄ Îπ†Î•∏ ÍµêÎåÄ (0-5Ï¥à)
                beatmap.push(
                    { time: beat * 1, lane: "sensor1", type: "normal" },
                    { time: beat * 2, lane: "sensor2", type: "normal" },
                    { time: beat * 3, lane: "sensor1", type: "normal" },
                    { time: beat * 4, lane: "sensor2", type: "normal" },
                    { time: beat * 5, lane: "both", type: "cooperation" }, // Ï≤´ Î≤àÏß∏ Ï†ÑÍ∏∞ Ìè≠Î∞ú
                    { time: beat * 7, lane: "sensor1", type: "normal" },
                    { time: beat * 8, lane: "sensor2", type: "normal" },
                    { time: beat * 10, lane: "both", type: "cooperation" }
                );
                
                // ‚ö° Ï†ÑÍ∏∞ Î∞©Ï†Ñ Íµ¨Í∞Ñ - ÏßÄÍ∑∏Ïû¨Í∑∏ Ìå®ÌÑ¥ (6-12Ï¥à)
                for (let i = 0; i < 12; i++) {
                    const baseTime = beat * (12 + i);
                    const pattern = i % 4; // 4Î∞ïÏûê Ìå®ÌÑ¥
                    
                    if (pattern === 0) {
                        beatmap.push({ time: baseTime, lane: "sensor1", type: "normal" });
                    } else if (pattern === 1) {
                        beatmap.push({ time: baseTime, lane: "sensor2", type: "normal" });
                    } else if (pattern === 2) {
                        beatmap.push({ time: baseTime, lane: "sensor1", type: "normal" });
                    } else { // Ï†ÑÍ∏∞ Ï∂©Îèå
                        beatmap.push({ time: baseTime, lane: "both", type: "cooperation" });
                    }
                }
                
                // ‚ö° Ï†ÑÍ∏∞ Ìè≠Ìíç Ìú¥Ïãù (13-15Ï¥à)
                const stormRest = beat * 26;
                beatmap.push(
                    { time: stormRest, lane: "sensor1", type: "normal" },
                    { time: stormRest + doubleBeat, lane: "sensor2", type: "normal" },
                    { time: stormRest + doubleBeat * 2, lane: "both", type: "cooperation" },
                    { time: stormRest + doubleBeat * 3, lane: "sensor1", type: "normal" }
                );
                
                // ‚ö° Î≤àÍ∞ú Ïó∞ÏáÑ Î∞òÏùë (16-20Ï¥à)
                const lightningChain = beat * 34;
                for (let i = 0; i < 8; i++) {
                    const chainTime = lightningChain + (beat * i);
                    const lane = i % 3 === 0 ? "both" : (i % 2 === 0 ? "sensor1" : "sensor2");
                    const type = lane === "both" ? "cooperation" : "normal";
                    
                    beatmap.push({ time: chainTime, lane: lane, type: type });
                }
                
                // ‚ö° ÏµúÏ¢Ö Ï†ÑÍ∏∞ Ìè≠Î∞ú (21-25Ï¥à)
                const finalExplosion = beat * 44;
                beatmap.push(
                    { time: finalExplosion, lane: "both", type: "cooperation" },
                    { time: finalExplosion + beat, lane: "sensor1", type: "normal" },
                    { time: finalExplosion + doubleBeat, lane: "sensor2", type: "normal" },
                    { time: finalExplosion + doubleBeat + beat, lane: "both", type: "cooperation" },
                    { time: finalExplosion + doubleBeat * 2, lane: "both", type: "cooperation" } // ÏµúÏ¢Ö Ìè≠Î∞ú
                );
                
                const totalDuration = (finalExplosion + doubleBeat * 2).toFixed(1);
                console.log(`‚ö° Electric Storm ÎπÑÌä∏Îßµ: ${beatmap.length}Í∞ú ÎÖ∏Ìä∏, ${totalDuration}Ï¥à`);
                return beatmap;
            }
            
            generateNeonNightsBeatmap(beat, halfBeat, doubleBeat) {
                // üåô Neon Nights - Î™ΩÌôòÏ†ÅÏù¥Í≥† Ïã†Ïä§Ïõ®Ïù¥Î∏åÌïú Ìå®ÌÑ¥
                const beatmap = [];
                
                // üåô ÎÑ§Ïò® ÏãúÏûë - Î∂ÄÎìúÎüΩÍ≥† Î™ΩÌôòÏ†Å (0-5Ï¥à)
                beatmap.push(
                    { time: beat * 1.5, lane: "sensor1", type: "normal" },
                    { time: beat * 3, lane: "sensor2", type: "normal" },
                    { time: beat * 4.5, lane: "sensor1", type: "normal" },
                    { time: beat * 6, lane: "both", type: "cooperation" }, // ÎÑ§Ïò® Î∞úÍ¥ë
                    { time: beat * 8, lane: "sensor2", type: "normal" },
                    { time: beat * 10, lane: "sensor1", type: "normal" }
                );
                
                // üåô Ïã†Ïä§Ïõ®Ïù¥Î∏å Î¶¨Îì¨ - Ïõ®Ïù¥Î∏å Ìå®ÌÑ¥ (6-12Ï¥à)
                for (let i = 0; i < 10; i++) {
                    const baseTime = beat * (12 + i * 1.2); // ÏïΩÍ∞Ñ ÎäêÎ¶∞ Í∞ÑÍ≤©
                    const pattern = i % 5; // 5Î∞ïÏûê Ìå®ÌÑ¥ (Ïã†Ïä§Ïõ®Ïù¥Î∏å ÌäπÏßï)
                    
                    if (pattern === 0 || pattern === 2) {
                        beatmap.push({ time: baseTime, lane: "sensor1", type: "normal" });
                    } else if (pattern === 1 || pattern === 3) {
                        beatmap.push({ time: baseTime, lane: "sensor2", type: "normal" });
                    } else { // ÎÑ§Ïò® ÌéÑÏä§
                        beatmap.push({ time: baseTime, lane: "both", type: "cooperation" });
                    }
                }
                
                // üåô Î∞§Ïùò Ï†ïÏ†Å (13-16Ï¥à)
                const nightQuiet = beat * 28;
                beatmap.push(
                    { time: nightQuiet, lane: "sensor1", type: "normal" },
                    { time: nightQuiet + doubleBeat * 1.5, lane: "sensor2", type: "normal" },
                    { time: nightQuiet + doubleBeat * 3, lane: "both", type: "cooperation" },
                    { time: nightQuiet + doubleBeat * 4.5, lane: "sensor1", type: "normal" }
                );
                
                // üåô ÎÑ§Ïò® ÌÅ¥ÎùºÏù¥Îß•Ïä§ - ÏÉâÍπî Ìè≠Î∞ú (17-21Ï¥à)
                const neonClimax = beat * 38;
                for (let i = 0; i < 6; i++) {
                    const clTime = neonClimax + (doubleBeat * i);
                    const lane = i % 3 === 0 ? "both" : (i % 2 === 0 ? "sensor2" : "sensor1");
                    const type = lane === "both" ? "cooperation" : "normal";
                    
                    beatmap.push({ time: clTime, lane: lane, type: type });
                }
                
                // üåô ÎÑ§Ïò® ÌéòÏù¥ÎìúÏïÑÏõÉ (22-25Ï¥à)
                const neonFade = beat * 50;
                beatmap.push(
                    { time: neonFade, lane: "both", type: "cooperation" },
                    { time: neonFade + doubleBeat, lane: "sensor2", type: "normal" },
                    { time: neonFade + doubleBeat * 2, lane: "sensor1", type: "normal" },
                    { time: neonFade + doubleBeat * 3, lane: "both", type: "cooperation" } // ÎÑ§Ïò® Í∫ºÏßê
                );
                
                const totalDuration = (neonFade + doubleBeat * 3).toFixed(1);
                console.log(`üåô Neon Nights ÎπÑÌä∏Îßµ: ${beatmap.length}Í∞ú ÎÖ∏Ìä∏, ${totalDuration}Ï¥à`);
                return beatmap;
            }
            
            generateDefaultBeatmap(beat, halfBeat, doubleBeat) {
                // üéµ Í∏∞Î≥∏ Ìå®ÌÑ¥ (fallback)
                const beatmap = [];
                
                // Í∞ÑÎã®Ìïú Í∏∞Î≥∏ Ìå®ÌÑ¥
                for (let i = 0; i < 20; i++) {
                    const time = beat * (i + 1);
                    const pattern = i % 4;
                    
                    if (pattern === 0) {
                        beatmap.push({ time: time, lane: "sensor1", type: "normal" });
                    } else if (pattern === 1) {
                        beatmap.push({ time: time, lane: "sensor2", type: "normal" });
                    } else if (pattern === 2) {
                        beatmap.push({ time: time, lane: "sensor1", type: "normal" });
                    } else {
                        beatmap.push({ time: time, lane: "both", type: "cooperation" });
                    }
                }
                
                console.log(`üéµ Í∏∞Î≥∏ ÎπÑÌä∏Îßµ: ${beatmap.length}Í∞ú ÎÖ∏Ìä∏`);
                return beatmap;
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                if (this.renderer) {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                }
                if (this.camera) {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                }
            }
            
            initThreeJS() {
                // Scene ÏÑ§Ï†ï
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0f172a, 10, 50);
                
                // Camera ÏÑ§Ï†ï
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 2, 5);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer ÏÑ§Ï†ï
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x0f172a);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Ï°∞Î™Ö ÏÑ§Ï†ï
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // ÏÑ∏Ïù¥Î≤Ñ ÏÉùÏÑ± (dualÏö©)
                this.sabers = {
                    sensor1: this.createSaber(0xff0000, -2),    // Îπ®Í∞ÑÏÉâ, ÏôºÏ™Ω
                    sensor2: this.createSaber(0x0000ff, 2)      // ÌååÎûÄÏÉâ, Ïò§Î•∏Ï™Ω
                };
                
                this.scene.add(this.sabers.sensor1);
                this.scene.add(this.sabers.sensor2);
                
                // Î∞∞Í≤Ω ÌôòÍ≤Ω ÏÉùÏÑ±
                this.createEnvironment();
                
                // ‚úÖ ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº Í∞ÄÏù¥ÎìúÎùºÏù∏ ÏãúÏä§ÌÖú Ï∂îÍ∞Ä
                this.createTimingGuidelines();
            }
            
            createSaber(color, xPosition) {
                const saberGroup = new THREE.Group();
                
                // ÏÑ∏Ïù¥Î≤Ñ ÏÜêÏû°Ïù¥
                const hiltGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.6, 8);
                const hiltMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const hilt = new THREE.Mesh(hiltGeometry, hiltMaterial);
                hilt.position.y = -0.3;
                
                // ÏÑ∏Ïù¥Î≤Ñ ÎÇ†
                const bladeGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
                const bladeMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.y = 1;
                
                // ÏÑ∏Ïù¥Î≤Ñ Í¥ëÏÑ† Ìö®Í≥º
                const glowGeometry = new THREE.CylinderGeometry(0.08, 0.08, 2, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 1;
                
                saberGroup.add(hilt);
                saberGroup.add(blade);
                saberGroup.add(glow);
                
                saberGroup.position.set(xPosition, 1.5, 3);
                saberGroup.rotation.x = THREE.MathUtils.degToRad(-15);
                
                saberGroup.userData = { 
                    swinging: false, 
                    swingTime: 0,
                    sensorId: xPosition < 0 ? 'sensor1' : 'sensor2'
                };
                
                return saberGroup;
            }
            
            createEnvironment() {
                // Î∞îÎã•
                const floorGeometry = new THREE.PlaneGeometry(20, 50);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1e293b,
                    transparent: true,
                    opacity: 0.8
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -1;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // ÏÇ¨Ïù¥Îìú Î≤Ω
                for (let i = 0; i < 2; i++) {
                    const wallGeometry = new THREE.PlaneGeometry(50, 10);
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x334155,
                        transparent: true,
                        opacity: 0.5
                    });
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(i === 0 ? -10 : 10, 4, 0);
                    wall.rotation.y = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                    this.scene.add(wall);
                }
            }
            
            // ‚úÖ ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ ÏãúÏä§ÌÖú (ÎÖ∏Ìä∏ Í∞ÄÏãúÏÑ± Í∞úÏÑ†)
            createTimingGuidelines() {
                this.timingGuidelines = {
                    sensor1: null,    // ÏôºÏ™Ω Îπ®Í∞Ñ Í∞ÄÏù¥ÎìúÎùºÏù∏
                    sensor2: null,    // Ïò§Î•∏Ï™Ω ÌååÎûÄ Í∞ÄÏù¥ÎìúÎùºÏù∏
                    cooperation: null // Ï§ëÏïô Î≥¥ÎùºÏÉâ Í∞ÄÏù¥ÎìúÎùºÏù∏
                };
                
                // ÏôºÏ™Ω ÏÑ∏Ïù¥Î≤ÑÏö© Îπ®Í∞Ñ Í∞ÄÏù¥ÎìúÎùºÏù∏ (Î∞îÎã•)
                this.timingGuidelines.sensor1 = this.createFloorGuideline(-2, 0xff0000, 'sensor1');
                this.scene.add(this.timingGuidelines.sensor1);
                
                // Ïò§Î•∏Ï™Ω ÏÑ∏Ïù¥Î≤ÑÏö© ÌååÎûÄ Í∞ÄÏù¥ÎìúÎùºÏù∏ (Î∞îÎã•)
                this.timingGuidelines.sensor2 = this.createFloorGuideline(2, 0x0000ff, 'sensor2');
                this.scene.add(this.timingGuidelines.sensor2);
                
                // ÌòëÎ†• ÎÖ∏Ìä∏Ïö© Î≥¥ÎùºÏÉâ Í∞ÄÏù¥ÎìúÎùºÏù∏ (Ï§ëÏïô Î∞îÎã•)
                this.timingGuidelines.cooperation = this.createFloorGuideline(0, 0x8b5cf6, 'cooperation');
                this.scene.add(this.timingGuidelines.cooperation);
                
                console.log('üéØ ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ ÏÉùÏÑ± ÏôÑÎ£å - ÎÖ∏Ìä∏ Í∞ÄÏãúÏÑ± Ìñ•ÏÉÅ');
            }
            
            // ‚úÖ Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ ÏÉùÏÑ± (ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùºÎ°ú ÎÖ∏Ìä∏ Í∞ÄÏãúÏÑ± Ìñ•ÏÉÅ)
            createFloorGuideline(xPosition, color, type) {
                const guidelineGroup = new THREE.Group();
                
                // Î∞îÎã• ÌÉÄÍ≤© ÏßÄÏ†ê (ÏßÅÏÇ¨Í∞ÅÌòï Ìå®Îìú)
                const hitZoneGeometry = new THREE.PlaneGeometry(1.5, 3);
                const hitZoneMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const hitZone = new THREE.Mesh(hitZoneGeometry, hitZoneMaterial);
                hitZone.rotation.x = -Math.PI / 2; // Î∞îÎã•Ïóê ÌèâÌñâÌïòÍ≤å
                hitZone.position.set(0, -0.8, 3.5); // Î∞îÎã• ÏúÑÏπò
                hitZone.userData = { originalOpacity: 0.4 };
                
                // ÌÉÄÍ≤© ÏßÄÏ†ê Ï§ëÏïô ÏõêÌòï Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
                const centerCircleGeometry = new THREE.CircleGeometry(0.6, 16);
                const centerCircleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const centerCircle = new THREE.Mesh(centerCircleGeometry, centerCircleMaterial);
                centerCircle.rotation.x = -Math.PI / 2;
                centerCircle.position.set(0, -0.75, 3.5); // Î∞îÎã•Î≥¥Îã§ ÏÇ¥Ïßù ÏúÑ
                centerCircle.userData = { originalOpacity: 0.8, pulsePhase: 0 };
                
                // Í∞ÄÏù¥ÎìúÎùºÏù∏ Í≤ΩÍ≥ÑÏÑ† (ÏïûÎí§)
                for (let i = 0; i < 2; i++) {
                    const borderGeometry = new THREE.PlaneGeometry(1.5, 0.1);
                    const borderMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                    const border = new THREE.Mesh(borderGeometry, borderMaterial);
                    border.rotation.x = -Math.PI / 2;
                    border.position.set(0, -0.7, 3.5 + (i === 0 ? -1.5 : 1.5));
                    border.userData = { originalOpacity: 0.9 };
                    
                    guidelineGroup.add(border);
                }
                
                // ÎÖ∏Ìä∏ Ìä∏Îûô ÎùºÏù∏ (Í∏∏Í≤å ÎªóÏùÄ Í∞ÄÏù¥Îìú)
                const trackGeometry = new THREE.PlaneGeometry(0.8, 40);
                const trackMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const track = new THREE.Mesh(trackGeometry, trackMaterial);
                track.rotation.x = -Math.PI / 2;
                track.position.set(0, -0.9, -16); // Î©ÄÎ¶¨ÏÑúÎ∂ÄÌÑ∞ ÏãúÏûë
                track.userData = { originalOpacity: 0.2 };
                
                // Î∞ïÏûê Ïù∏ÎîîÏºÄÏù¥ÌÑ∞Îì§ (Î∞îÎã• ÏõêÌòïÎì§)
                for (let i = 1; i <= 3; i++) {
                    const beatGeometry = new THREE.CircleGeometry(0.2, 8);
                    const beatMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.5,
                        side: THREE.DoubleSide
                    });
                    const beatIndicator = new THREE.Mesh(beatGeometry, beatMaterial);
                    beatIndicator.rotation.x = -Math.PI / 2;
                    beatIndicator.position.set(0, -0.7, 3.5 - (i * 2));
                    beatIndicator.userData = { originalOpacity: 0.5 };
                    
                    guidelineGroup.add(beatIndicator);
                }
                
                guidelineGroup.add(track);
                guidelineGroup.add(hitZone);
                guidelineGroup.add(centerCircle);
                
                guidelineGroup.position.x = xPosition;
                guidelineGroup.userData = { 
                    type: type,
                    color: color,
                    isActive: false,
                    lastPulse: 0
                };
                
                return guidelineGroup;
            }
            
            setupEventListeners() {
                // ‚úÖ Ï§ëÏöî: ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏôÑÎ£å ÌõÑ ÏÑ∏ÏÖò ÏÉùÏÑ±
                this.sdk.on('connected', () => {
                    console.log('‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏôÑÎ£å, ÏÑ∏ÏÖò ÏÉùÏÑ± Ï§ë...');
                    this.createSession();
                });
                
                // ‚úÖ Ï§ëÏöî: CustomEvent Ï≤òÎ¶¨ Ìå®ÌÑ¥
                this.sdk.on('session-created', (event) => {
                    const session = event.detail || event;  // ÌïÑÏàò Ìå®ÌÑ¥!
                    console.log('ÏÑ∏ÏÖò ÏÉùÏÑ±Îê®:', session);
                    this.displaySessionInfo(session);
                });
                
                this.sdk.on('sensor-connected', (event) => {
                    const data = event.detail || event;     // ÌïÑÏàò Ìå®ÌÑ¥!
                    console.log('ÏÑºÏÑú Ïó∞Í≤∞Îê®:', data);
                    this.onSensorConnected(data);
                });
                
                this.sdk.on('sensor-data', (event) => {
                    const data = event.detail || event;     // ÌïÑÏàò Ìå®ÌÑ¥!
                    this.processSensorData(data);
                });
                
                this.sdk.on('game-ready', (event) => {
                    const data = event.detail || event;     // ÌïÑÏàò Ìå®ÌÑ¥!
                    console.log('Í≤åÏûÑ Ï§ÄÎπÑ ÏôÑÎ£å - ÏÇ¨Ïö©Ïûê ÏãúÏûë Î≤ÑÌäº ÌôúÏÑ±Ìôî');
                    this.showStartButton();
                });
                
                this.sdk.on('sensor-disconnected', (event) => {
                    const data = event.detail || event;     // ÌïÑÏàò Ìå®ÌÑ¥!
                    console.log('ÏÑºÏÑú Ïó∞Í≤∞ Ìï¥Ï†ú:', data.sensorId);
                    this.onSensorDisconnected(data);
                });
                
                // ‚úÖ Í∞úÏÑ†Îêú ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ (ÌÖåÏä§Ìä∏Ïö©)
                window.addEventListener('keydown', (e) => {
                    if (this.gameState.phase !== 'playing') return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'q': 
                            this.triggerSwing('sensor1'); 
                            console.log('üî¥ ÏôºÏ™Ω ÏÑ∏Ïù¥Î≤Ñ(sensor1) Ïä§Ïúô - Ïò§Î•∏Ï™ΩÏúºÎ°ú');
                            break;
                        case 'e': 
                            this.triggerSwing('sensor2'); 
                            console.log('üîµ Ïò§Î•∏Ï™Ω ÏÑ∏Ïù¥Î≤Ñ(sensor2) Ïä§Ïúô - ÏôºÏ™ΩÏúºÎ°ú');
                            break;
                        case ' ': 
                            this.triggerCooperationSwing(); 
                            console.log('ü§ù ÌòëÎ†• Ïä§Ïúô - Îëê ÏÑ∏Ïù¥Î≤Ñ ÎèôÏãú Ïä§Ïúô');
                            break;
                        case 'a':
                            // ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥Î•º ÎëêÍ≥† ÌòëÎ†• ÌÖåÏä§Ìä∏
                            this.triggerSwing('sensor1');
                            setTimeout(() => this.triggerSwing('sensor2'), 100);
                            console.log('‚è±Ô∏è ÏàúÏ∞® ÌòëÎ†• ÌÖåÏä§Ìä∏ (100ms ÎîúÎ†àÏù¥)');
                            break;
                        case 's':
                            // Îçî Í∏¥ ÎîúÎ†àÏù¥Î°ú Ïã§Ìå® ÌÖåÏä§Ìä∏
                            this.triggerSwing('sensor1');
                            setTimeout(() => this.triggerSwing('sensor2'), 600);
                            console.log('‚ùå ÌòëÎ†• Ïã§Ìå® ÌÖåÏä§Ìä∏ (600ms ÎîúÎ†àÏù¥)');
                            break;
                    }
                });
            }
            
            async createSession() {
                try {
                    await this.sdk.createSession();
                } catch (error) {
                    console.error('ÏÑ∏ÏÖò ÏÉùÏÑ± Ïã§Ìå®:', error);
                }
            }
            
            // ‚úÖ QR ÏΩîÎìú ÏïàÏ†ÑÌïú ÏÉùÏÑ± (Ìè¥Î∞± Ï≤òÎ¶¨ Ìè¨Ìï®)
            displaySessionInfo(session) {
                document.getElementById('sessionCode').textContent = session.sessionCode;
                
                const qrUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                
                if (typeof QRCode !== 'undefined') {
                    QRCode.toCanvas(document.createElement('canvas'), qrUrl, (error, canvas) => {
                        if (!error) {
                            canvas.style.width = '200px';
                            canvas.style.height = '200px';
                            document.getElementById('qrContainer').innerHTML = '';
                            document.getElementById('qrContainer').appendChild(canvas);
                        } else {
                            console.error('QR ÏΩîÎìú ÏÉùÏÑ± Ïã§Ìå®:', error);
                            this.showQRCodeFallback(qrUrl);
                        }
                    });
                } else {
                    console.warn('QRCode ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ìè¥Î∞± ÏÇ¨Ïö©.');
                    this.showQRCodeFallback(qrUrl);
                }
            }
            
            showQRCodeFallback(qrUrl) {
                const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qrUrl)}`;
                const img = document.createElement('img');
                img.src = qrApiUrl;
                img.style.width = '200px';
                img.style.height = '200px';
                img.alt = 'QR Code';
                
                document.getElementById('qrContainer').innerHTML = '';
                document.getElementById('qrContainer').appendChild(img);
            }
            
            onSensorConnected(data) {
                const sensorId = data.sensorId;
                this.sensorStatus[sensorId].connected = true;
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                const statusElement = document.getElementById(`${sensorId}Status`);
                statusElement.textContent = 'Ïó∞Í≤∞Îê® ‚úÖ';
                statusElement.style.color = '#10b981';
                
                console.log(`${sensorId} Ïó∞Í≤∞Îê®`);
                
                // Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
                this.updateConnectionStatus();
            }
            
            onSensorDisconnected(data) {
                const sensorId = data.sensorId;
                this.sensorStatus[sensorId].connected = false;
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                const statusElement = document.getElementById(`${sensorId}Status`);
                statusElement.textContent = 'Ïó∞Í≤∞ Ìï¥Ï†úÎê® ‚ùå';
                statusElement.style.color = '#ef4444';
                
                console.log(`${sensorId} Ïó∞Í≤∞ Ìï¥Ï†úÎê®`);
            }
            
            updateConnectionStatus() {
                const connectedCount = Object.values(this.sensorStatus).filter(s => s.connected).length;
                console.log(`Ïó∞Í≤∞Îêú ÏÑºÏÑú: ${connectedCount}/2`);
            }
            
            processSensorData(data) {
                if (this.gameState.phase !== 'playing') return;
                
                const sensorId = data.sensorId;
                const sensorData = data.data;
                
                if (sensorData.orientation) {
                    // Ïä§Ïúô Í∞êÏßÄ Î°úÏßÅ
                    const rotationSpeed = Math.abs(sensorData.rotationRate?.alpha || 0) + 
                                         Math.abs(sensorData.rotationRate?.beta || 0) + 
                                         Math.abs(sensorData.rotationRate?.gamma || 0);
                    
                    const swingThreshold = 300;  // Ïä§Ïúô Ïù∏Ïãù Í∏∞Ï§Ä
                    
                    if (rotationSpeed > swingThreshold) {
                        const now = Date.now();
                        if (now - this.sensorStatus[sensorId].lastSwing > 500) {  // 500ms Ïø®Îã§Ïö¥
                            this.triggerSwing(sensorId);
                            this.sensorStatus[sensorId].lastSwing = now;
                        }
                    }
                }
            }
            
            showStartButton() {
                const startButton = document.createElement('button');
                startButton.className = 'btn btn-primary';
                startButton.style.cssText = 'font-size: 1.2rem; padding: 1rem 2rem; margin-top: 1rem;';
                startButton.innerHTML = 'üéµ Í≤åÏûÑ ÏãúÏûë!';
                startButton.onclick = () => {
                    startButton.remove();
                    this.startGame();
                };
                
                const sessionPanel = document.getElementById('sessionPanel');
                sessionPanel.appendChild(startButton);
                
                console.log('üéÆ ÏÑºÏÑú Ïó∞Í≤∞ ÏôÑÎ£å - Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäº ÌëúÏãú');
            }
            
            startGame() {
                this.gameState.phase = 'playing';
                this.gameState.startTime = Date.now();
                
                // üéµ ÏùåÏïÖ Ïû¨ÏÉù ÏãúÏûë
                if (this.musicLoaded) {
                    this.bgMusic.currentTime = 0;
                    this.bgMusic.play().then(() => {
                        console.log('üéµ ÏùåÏïÖ Ïû¨ÏÉù ÏãúÏûë');
                    }).catch(e => {
                        console.warn('üéµ ÏùåÏïÖ Ïû¨ÏÉù Ïã§Ìå®:', e);
                    });
                }
                
                // UI Ï†ÑÌôò
                document.getElementById('sessionPanel').classList.add('hidden');
                document.getElementById('gameStats').classList.remove('hidden');
                document.getElementById('cooperationMeter').classList.remove('hidden');
                document.getElementById('controlPanel').classList.remove('hidden');
                document.getElementById('gameInstructions').classList.remove('hidden');
                
                console.log('üéÆ Rhythm Blade Dual Í≤åÏûÑ ÏãúÏûë!');
            }
            
            triggerSwing(sensorId) {
                const saber = this.sabers[sensorId];
                if (!saber.userData.swinging) {
                    saber.userData.swinging = true;
                    saber.userData.swingTime = Date.now();
                    this.checkHit(sensorId);
                    
                    // ÏãúÍ∞ÅÏ†Å Ìö®Í≥º
                    this.createSwingEffect(saber);
                }
            }
            
            triggerCooperationSwing() {
                // Îëê ÏÑºÏÑú Î™®Îëê Ïä§Ïúô (ÌÖåÏä§Ìä∏Ïö©)
                this.triggerSwing('sensor1');
                this.triggerSwing('sensor2');
            }
            
            checkHit(sensorId) {
                const saber = this.sabers[sensorId];
                let hit = false;
                
                for (let i = this.notes.length - 1; i >= 0; i--) {
                    const note = this.notes[i];
                    const noteData = note.userData;
                    
                    // ‚úÖ Í∞úÏÑ†Îêú Í±∞Î¶¨ Ï≤¥ÌÅ¨ (ÌòëÎ†• ÎÖ∏Ìä∏Îäî Îçî ÎÑìÏùÄ Î≤îÏúÑ)
                    const hitRange = noteData.type === 'cooperation' ? 2.5 : 2;
                    const distance = note.position.distanceTo(saber.position);
                    
                    if (distance < hitRange) {  
                        if (noteData.type === 'cooperation') {
                            // ‚úÖ Í∞úÏÑ†Îêú ÌòëÎ†• ÎÖ∏Ìä∏ ÏãúÏä§ÌÖú
                            noteData.hitBy = noteData.hitBy || [];
                            noteData.hitTimes = noteData.hitTimes || [];
                            
                            if (!noteData.hitBy.includes(sensorId)) {
                                const now = Date.now();
                                noteData.hitBy.push(sensorId);
                                noteData.hitTimes.push(now);
                                
                                console.log(`ü§ù ÌòëÎ†• ÎÖ∏Ìä∏ ÌûàÌä∏: ${sensorId} (${noteData.hitBy.length}/2)`);
                                
                                // Îëê ÏÑºÏÑú Î™®Îëê ÌûàÌä∏ÌñàÎäîÏßÄ ÌôïÏù∏
                                if (noteData.hitBy.length >= 2) {
                                    // ‚úÖ ÎèôÏãúÏÑ± Ï≤¥ÌÅ¨ (500ms ÎÇ¥Ïóê Îëê ÌûàÌä∏Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï®)
                                    const timeDiff = Math.abs(noteData.hitTimes[1] - noteData.hitTimes[0]);
                                    const maxSyncTime = 500; // 500ms ÎèôÍ∏∞Ìôî ÏúàÎèÑÏö∞
                                    
                                    if (timeDiff <= maxSyncTime) {
                                        // ÏôÑÎ≤ΩÌïú ÌòëÎ†• ÌûàÌä∏!
                                        this.processHit(note, 'cooperation', true);
                                        hit = true;
                                        
                                        // ‚úÖ ÌäπÎ≥ÑÌïú ÌòëÎ†• Î≥¥ÎÑàÏä§
                                        const syncBonus = Math.max(1, (maxSyncTime - timeDiff) / maxSyncTime);
                                        this.cooperation.sync = Math.min(100, this.cooperation.sync + (10 * syncBonus));
                                        
                                        console.log(`üåü ÏôÑÎ≤ΩÌïú ÌòëÎ†•! ÎèôÍ∏∞Ìôî: ${timeDiff}ms, Î≥¥ÎÑàÏä§: ${syncBonus.toFixed(2)}`);
                                    } else {
                                        // ÌÉÄÏù¥Î∞çÏù¥ ÎßûÏßÄ ÏïäÏùå
                                        console.log(`‚è∞ ÌòëÎ†• ÌÉÄÏù¥Î∞ç Ïã§Ìå®: ${timeDiff}ms (ÏµúÎåÄ ${maxSyncTime}ms)`);
                                        this.updateCooperation(false);
                                    }
                                }
                            }
                        } else if (noteData.lane === sensorId) {
                            // ÏùºÎ∞ò ÎÖ∏Ìä∏
                            this.processHit(note, 'normal', false);
                            hit = true;
                        }
                    }
                }
                
                if (hit) {
                    this.gameState.combo++;
                    // ÏµúÎåÄ ÏΩ§Î≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                    this.gameState.maxCombo = Math.max(this.gameState.maxCombo, this.gameState.combo);
                    this.updateCooperation(true);
                } else {
                    // ‚úÖ Í≤åÏûÑÏù¥ Í±∞Ïùò ÎÅùÎÇòÍ∞à ÎïåÎäî ÏΩ§Î≥¥ Ï¥àÍ∏∞ÌôîÎ•º Î∞©ÏßÄ
                    const isGameEnding = this.noteSpawnIndex >= this.beatmap.length && this.notes.length <= 2;
                    
                    if (!isGameEnding) {
                        // ÏùºÎ∞òÏ†ÅÏù∏ Í≤ΩÏö∞: Ïä§ÏúôÌñàÏßÄÎßå ÌûàÌä∏ÌïòÏßÄ Î™ªÌïú Í≤ΩÏö∞ ÏΩ§Î≥¥ Ï¥àÍ∏∞Ìôî
                        this.gameState.combo = 0;
                        this.updateCooperation(false);
                    } else {
                        // Í≤åÏûÑ Ï¢ÖÎ£å ÏßÅÏ†Ñ: ÏΩ§Î≥¥ Ïú†ÏßÄÌïòÎêò ÌòëÎ†•ÎèÑÎßå Í∞êÏÜå
                        console.log('üéØ Í≤åÏûÑ Ï¢ÖÎ£å ÏßÅÏ†Ñ - ÏΩ§Î≥¥ Ïú†ÏßÄ');
                        this.cooperation.sync = Math.max(0, this.cooperation.sync - 5);
                    }
                }
                
                this.updateUI();
            }
            
            // ‚úÖ ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº Í∞ÄÏù¥ÎìúÎùºÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏä§ÌÖú
            updateGuidelineForNote(note) {
                const noteData = note.userData;
                const distanceToHitPoint = Math.abs(note.position.z - 3.5); // Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ ÏúÑÏπò: z=3.5
                
                // ÎÖ∏Ìä∏Í∞Ä Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏Ïóê Ï†ëÍ∑ºÌï† Îïå ÌôúÏÑ±Ìôî (Îçî ÎÑìÏùÄ Î≤îÏúÑ)
                if (distanceToHitPoint <= 30 && distanceToHitPoint >= 0) {
                    let guidelineType;
                    
                    if (noteData.type === 'cooperation') {
                        guidelineType = 'cooperation';
                    } else if (noteData.lane === 'sensor1') {
                        guidelineType = 'sensor1';
                    } else if (noteData.lane === 'sensor2') {
                        guidelineType = 'sensor2';
                    }
                    
                    if (guidelineType && this.timingGuidelines[guidelineType]) {
                        this.activateGuideline(guidelineType, note);
                        
                        // ÎÖ∏Ìä∏Í∞Ä ÏôÑÎ≤ΩÌïú ÌÉÄÏù¥Î∞ç ÏßÄÏ†êÏóê Í∞ÄÍπåÏõåÏßà Îïå Í∞ïÏ°∞ Ìö®Í≥º
                        if (distanceToHitPoint <= 3) {
                            this.highlightGuideline(guidelineType, distanceToHitPoint);
                        }
                    }
                }
            }
            
            activateGuideline(guidelineType, note) {
                const guideline = this.timingGuidelines[guidelineType];
                if (!guideline) return;
                
                guideline.userData.isActive = true;
                guideline.userData.activeNote = note;
                
                // Í∞ÄÏù¥ÎìúÎùºÏù∏ÏùÑ Îçî Î∞ùÍ≤å ÎßåÎì§Í∏∞
                guideline.children.forEach(child => {
                    if (child.material && child.userData.originalOpacity) {
                        child.material.opacity = Math.min(1.0, child.userData.originalOpacity * 1.5);
                    }
                });
            }
            
            highlightGuideline(guidelineType, distance) {
                const guideline = this.timingGuidelines[guidelineType];
                if (!guideline) return;
                
                // Í±∞Î¶¨Ïóê Îî∞Î•∏ Í∞ïÏ°∞ Í∞ïÎèÑ Í≥ÑÏÇ∞ (Í∞ÄÍπåÏö∏ÏàòÎ°ù Í∞ïÌïòÍ≤å)
                const intensity = Math.max(0, 1 - (distance / 3));
                
                // Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏Ïùò Ï§ëÏïô ÏõêÌòï Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ï∞æÍ∏∞
                const hitPoint = guideline.children.find(child => 
                    child.geometry && child.geometry.type === 'CircleGeometry' && 
                    child.userData.pulsePhase !== undefined &&
                    child.geometry.parameters && child.geometry.parameters.radius === 0.6
                );
                
                if (hitPoint) {
                    // ÌéÑÏä§ Ìö®Í≥º Ï†ÅÏö©
                    hitPoint.userData.pulsePhase += 0.3;
                    const pulse = 0.6 + (Math.sin(hitPoint.userData.pulsePhase) * 0.4 * intensity);
                    hitPoint.material.opacity = pulse;
                    hitPoint.scale.setScalar(1 + (intensity * 0.5));
                    
                    // Îß§Ïö∞ Í∞ÄÍπåÏö∏ Îïå (ÏôÑÎ≤ΩÌïú ÌÉÄÏù¥Î∞ç) ÌäπÎ≥ÑÌïú Ìö®Í≥º
                    if (distance <= 1) {
                        hitPoint.material.opacity = 1.0;
                        hitPoint.scale.setScalar(1.5);
                        
                        // Í∞ÄÏù¥ÎìúÎùºÏù∏ Ï†ÑÏ≤¥Î•º ÍπúÎπ°Ïù¥Í≤å ÌïòÍ∏∞
                        guideline.children.forEach(child => {
                            if (child !== hitPoint && child.material) {
                                const flash = 0.8 + (Math.sin(Date.now() * 0.01) * 0.2);
                                child.material.opacity = child.userData.originalOpacity * flash;
                            }
                        });
                    }
                }
            }
            
            deactivateGuideline(noteData) {
                let guidelineType;
                
                if (noteData.type === 'cooperation') {
                    guidelineType = 'cooperation';
                } else if (noteData.lane === 'sensor1') {
                    guidelineType = 'sensor1';
                } else if (noteData.lane === 'sensor2') {
                    guidelineType = 'sensor2';
                }
                
                if (guidelineType && this.timingGuidelines[guidelineType]) {
                    const guideline = this.timingGuidelines[guidelineType];
                    guideline.userData.isActive = false;
                    guideline.userData.activeNote = null;
                    
                    // Í∞ÄÏù¥ÎìúÎùºÏù∏ÏùÑ ÏõêÎûò Î∞ùÍ∏∞Î°ú Î≥µÏõê
                    guideline.children.forEach(child => {
                        if (child.material && child.userData.originalOpacity) {
                            child.material.opacity = child.userData.originalOpacity;
                        }
                        if (child.scale) {
                            child.scale.setScalar(1);
                        }
                    });
                }
            }
            
            updateTimingGuidelines() {
                // Í∞Å Í∞ÄÏù¥ÎìúÎùºÏù∏Ïùò Í∏∞Î≥∏ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
                Object.values(this.timingGuidelines).forEach(guideline => {
                    if (!guideline) return;
                    
                    // Í∏∞Î≥∏ ÌéÑÏä§ Ìö®Í≥º (ÌôúÏÑ±ÌôîÎêòÏßÄ ÏïäÏùÄ Í∞ÄÏù¥ÎìúÎùºÏù∏)
                    if (!guideline.userData.isActive) {
                        const time = Date.now() * 0.002;
                        const pulse = 0.7 + (Math.sin(time) * 0.3);
                        
                        // Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ Ìä∏ÎûôÏóê ÌéÑÏä§ Ï†ÅÏö©
                        guideline.children.forEach(child => {
                            if (child.geometry && child.geometry.type === 'PlaneGeometry' && 
                                child.userData.originalOpacity === 0.2) { // Ìä∏Îûô ÎùºÏù∏
                                child.material.opacity = child.userData.originalOpacity * pulse;
                            }
                        });
                    }
                    
                    // Î∞ïÏûêÏóê ÎßûÎäî ÍπúÎπ°ÏûÑ Ìö®Í≥º
                    if (this.gameState.phase === 'playing') {
                        const elapsedTime = (Date.now() - this.gameState.startTime) / 1000;
                        const beatTime = elapsedTime % this.beatInterval;
                        const beatPulse = beatTime < 0.1 ? 1.5 : 1.0;
                        
                        // Î∞îÎã• Î∞ïÏûê Ïù∏ÎîîÏºÄÏù¥ÌÑ∞Îì§Ïóê Î∞ïÏûê ÎßûÏ∂§ Ìö®Í≥º
                        guideline.children.forEach(child => {
                            if (child.geometry && child.geometry.type === 'CircleGeometry' && 
                                child.userData.originalOpacity === 0.5) { // Î∞îÎã• Î∞ïÏûê Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
                                child.material.opacity = child.userData.originalOpacity * beatPulse;
                            }
                        });
                    }
                    
                    // ÌûàÌä∏ Ìö®Í≥º ÌéòÏù¥ÎìúÏïÑÏõÉ Ï≤òÎ¶¨
                    if (guideline.userData.hitEffectTime) {
                        const timeSinceHit = Date.now() - guideline.userData.hitEffectTime;
                        if (timeSinceHit > 500) { // 0.5Ï¥à ÌõÑ Ìö®Í≥º Ï†úÍ±∞
                            guideline.userData.hitEffectTime = null;
                            // ÏõêÎûò ÏÉÅÌÉúÎ°ú Î≥µÏõê
                            this.deactivateGuideline({ 
                                type: guideline.userData.type === 'cooperation' ? 'cooperation' : 'normal',
                                lane: guideline.userData.type
                            });
                        }
                    }
                });
            }
            
            triggerGuidelineHitEffect(noteData) {
                let guidelineType;
                
                if (noteData.type === 'cooperation') {
                    guidelineType = 'cooperation';
                } else if (noteData.lane === 'sensor1') {
                    guidelineType = 'sensor1';
                } else if (noteData.lane === 'sensor2') {
                    guidelineType = 'sensor2';
                }
                
                if (guidelineType && this.timingGuidelines[guidelineType]) {
                    const guideline = this.timingGuidelines[guidelineType];
                    guideline.userData.hitEffectTime = Date.now();
                    
                    // Í∞ïÎ†¨Ìïú ÌûàÌä∏ Ìö®Í≥º
                    guideline.children.forEach(child => {
                        if (child.material) {
                            // Î∞ùÏùÄ ÌîåÎûòÏãú Ìö®Í≥º
                            child.material.opacity = 1.0;
                            
                            // Î∞îÎã• Í∞ÄÏù¥ÎìúÎùºÏù∏ Ï§ëÏïô ÏõêÌòï ÌôïÎåÄ Ìö®Í≥º
                            if (child.geometry && child.geometry.type === 'CircleGeometry' && 
                                child.userData.pulsePhase !== undefined &&
                                child.geometry.parameters && child.geometry.parameters.radius === 0.6) {
                                child.scale.setScalar(2.0);
                                
                                // Î∞îÎã• ÎßÅ ÌôïÏÇ∞ Ìö®Í≥º ÏÉùÏÑ±
                                this.createFloorRingEffect(child.position, guideline.userData.color);
                            }
                        }
                    });
                    
                    console.log(`üéØ Í∞ÄÏù¥ÎìúÎùºÏù∏ ÌûàÌä∏ Ìö®Í≥º: ${guidelineType}`);
                }
            }
            
            createGuidelineRingEffect(position, color) {
                // ÌôïÏÇ∞ÎêòÎäî ÎßÅ Ìö®Í≥º ÏÉùÏÑ±
                const ringGeometry = new THREE.RingGeometry(0.5, 0.7, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.userData = { 
                    startTime: Date.now(),
                    duration: 300 // 0.3Ï¥à ÎèôÏïà ÌôïÏÇ∞
                };
                
                this.scene.add(ring);
                
                // Ïï†ÎãàÎ©îÏù¥ÏÖò Ìï®Ïàò
                const animateRing = () => {
                    const elapsed = Date.now() - ring.userData.startTime;
                    const progress = elapsed / ring.userData.duration;
                    
                    if (progress >= 1) {
                        this.scene.remove(ring);
                        return;
                    }
                    
                    // ÌÅ¨Í∏∞ ÌôïÎåÄ Î∞è ÌéòÏù¥ÎìúÏïÑÏõÉ
                    const scale = 1 + (progress * 3); // 4Î∞∞ÍπåÏßÄ ÌôïÎåÄ
                    ring.scale.setScalar(scale);
                    ring.material.opacity = 0.8 * (1 - progress);
                    
                    requestAnimationFrame(animateRing);
                };
                
                animateRing();
            }
            
            createFloorRingEffect(position, color) {
                // Î∞îÎã•Ïóê ÌôïÏÇ∞ÎêòÎäî ÎßÅ Ìö®Í≥º ÏÉùÏÑ± (ÌÉ≠ÏÜåÎãâ Ïä§ÌÉÄÏùº)
                const ringGeometry = new THREE.RingGeometry(0.7, 1.0, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.rotation.x = -Math.PI / 2; // Î∞îÎã•Ïóê ÌèâÌñâÌïòÍ≤å
                ring.userData = { 
                    startTime: Date.now(),
                    duration: 400 // 0.4Ï¥à ÎèôÏïà ÌôïÏÇ∞
                };
                
                this.scene.add(ring);
                
                // Î∞îÎã• ÎßÅ Ïï†ÎãàÎ©îÏù¥ÏÖò Ìï®Ïàò
                const animateFloorRing = () => {
                    const elapsed = Date.now() - ring.userData.startTime;
                    const progress = elapsed / ring.userData.duration;
                    
                    if (progress >= 1) {
                        this.scene.remove(ring);
                        return;
                    }
                    
                    // ÌÅ¨Í∏∞ ÌôïÎåÄ Î∞è ÌéòÏù¥ÎìúÏïÑÏõÉ
                    const scale = 1 + (progress * 4); // 5Î∞∞ÍπåÏßÄ ÌôïÎåÄ
                    ring.scale.setScalar(scale);
                    ring.material.opacity = 0.9 * (1 - progress);
                    
                    requestAnimationFrame(animateFloorRing);
                };
                
                animateFloorRing();
            }
            
            processHit(note, type, isCooperation) {
                // Ï†êÏàò Í≥ÑÏÇ∞
                let score = 100;
                if (isCooperation) {
                    score *= 2;  // ÌòëÎ†• Î≥¥ÎÑàÏä§
                    score *= this.cooperation.cooperationBonus;
                }
                
                this.gameState.score += Math.floor(score);
                this.gameState.hitNotes++;
                
                // Ïù¥ÌéôÌä∏ ÏÉùÏÑ±
                this.createHitEffect(note.position, isCooperation);
                
                // ‚úÖ Í∞ÄÏù¥ÎìúÎùºÏù∏ ÌûàÌä∏ Ìö®Í≥º
                this.triggerGuidelineHitEffect(note.userData);
                
                // ÎÖ∏Ìä∏ Ï†úÍ±∞
                this.scene.remove(note);
                this.notes.splice(this.notes.indexOf(note), 1);
                
                console.log(`Hit! Score: +${Math.floor(score)}, Type: ${type}`);
            }
            
            createSwingEffect(saber) {
                // ÏÑ∏Ïù¥Î≤Ñ Ïä§Ïúô Ïù¥ÌéôÌä∏
                const trailGeometry = new THREE.PlaneGeometry(0.1, 2);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: saber.children[1].material.color,
                    transparent: true,
                    opacity: 0.6
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(saber.position);
                trail.rotation.copy(saber.rotation);
                
                this.scene.add(trail);
                
                // ÌéòÏù¥Îìú ÏïÑÏõÉ Ïï†ÎãàÎ©îÏù¥ÏÖò
                const fadeOut = () => {
                    trail.material.opacity -= 0.05;
                    if (trail.material.opacity <= 0) {
                        this.scene.remove(trail);
                    } else {
                        requestAnimationFrame(fadeOut);
                    }
                };
                fadeOut();
            }
            
            createHitEffect(position, isCooperation) {
                const particleCount = isCooperation ? 30 : 20;
                const particles = new THREE.Group();
                
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: isCooperation ? 0x8b5cf6 : Math.random() > 0.5 ? 0xff0000 : 0x0000ff,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(position);
                    
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 4
                    );
                    particle.userData.life = 1;
                    
                    particles.add(particle);
                }
                
                this.particleEffects.push(particles);
                this.scene.add(particles);
            }
            
            updateCooperation(success) {
                if (success) {
                    this.cooperation.sync = Math.min(100, this.cooperation.sync + 5);
                    this.cooperation.cooperationBonus = 1.0 + (this.cooperation.sync / 200);
                } else {
                    this.cooperation.sync = Math.max(0, this.cooperation.sync - 10);
                    this.cooperation.cooperationBonus = 1.0 + (this.cooperation.sync / 200);
                }
                
                // ÌòëÎ†• ÎØ∏ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                const fillElement = document.getElementById('cooperationFill');
                fillElement.style.width = `${this.cooperation.sync}%`;
            }
            
            spawnNote() {
                if (this.noteSpawnIndex >= this.beatmap.length) return;
                
                const now = Date.now();
                const elapsedTime = (now - this.gameState.startTime) / 1000;
                const noteData = this.beatmap[this.noteSpawnIndex];
                
                if (elapsedTime >= noteData.time) {
                    this.createNote(noteData);
                    this.noteSpawnIndex++;
                }
            }
            
            createNote(noteData) {
                let geometry, material, position;
                
                if (noteData.type === 'cooperation') {
                    // ÌòëÎ†• ÎÖ∏Ìä∏ (Î≥¥ÎùºÏÉâ, ÌÅ∞ ÌÅ¨Í∏∞)
                    geometry = new THREE.SphereGeometry(0.8, 8, 8);
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0x8b5cf6,
                        transparent: true,
                        opacity: 0.8
                    });
                    position = new THREE.Vector3(0, 1.5, -20);
                } else {
                    // ÏùºÎ∞ò ÎÖ∏Ìä∏
                    geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    const color = noteData.lane === 'sensor1' ? 0xff0000 : 0x0000ff;
                    material = new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    });
                    const x = noteData.lane === 'sensor1' ? -2 : 2;
                    position = new THREE.Vector3(x, 1.5, -20);
                }
                
                const note = new THREE.Mesh(geometry, material);
                note.position.copy(position);
                note.userData = { ...noteData };
                
                // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
                const glowGeometry = geometry.clone();
                glowGeometry.scale(1.2, 1.2, 1.2);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: material.color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                note.add(glow);
                
                this.notes.push(note);
                this.scene.add(note);
            }
            
            update() {
                if (this.gameState.phase !== 'playing') return;
                
                const delta = 0.3;  // ÎÖ∏Ìä∏ Ïù¥Îèô ÏÜçÎèÑ
                
                // ÎÖ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                for (let i = this.notes.length - 1; i >= 0; i--) {
                    const note = this.notes[i];
                    note.position.z += delta;
                    note.rotation.y += 0.02;  // ÌöåÏ†Ñ Ìö®Í≥º
                    
                    // ‚úÖ Í∞ÄÏù¥ÎìúÎùºÏù∏Í≥º ÎÖ∏Ìä∏ Îß§Ïπ≠ Ï≤¥ÌÅ¨
                    this.updateGuidelineForNote(note);
                    
                    // ÎÜìÏπú ÎÖ∏Ìä∏ Ï≤òÎ¶¨
                    if (note.position.z > 6) {
                        this.scene.remove(note);
                        this.notes.splice(i, 1);
                        this.gameState.combo = 0;
                        this.updateCooperation(false);
                        
                        // ÎÜìÏπú ÎÖ∏Ìä∏Ïóê Ìï¥ÎãπÌïòÎäî Í∞ÄÏù¥ÎìúÎùºÏù∏ ÎπÑÌôúÏÑ±Ìôî
                        this.deactivateGuideline(note.userData);
                    }
                }
                
                // ÏÉà ÎÖ∏Ìä∏ ÏÉùÏÑ±
                this.spawnNote();
                
                // ÏÑ∏Ïù¥Î≤Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
                this.updateSaber(this.sabers.sensor1);
                this.updateSaber(this.sabers.sensor2);
                
                // ÌååÌã∞ÌÅ¥ Ìö®Í≥º ÏóÖÎç∞Ïù¥Ìä∏
                this.updateParticles();
                
                // ‚úÖ Í∞ÄÏù¥ÎìúÎùºÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
                this.updateTimingGuidelines();
                
                // Í≤åÏûÑ Ï¢ÖÎ£å Ï≤¥ÌÅ¨
                this.checkGameEnd();
            }
            
            updateSaber(saber) {
                if (saber.userData.swinging) {
                    const now = Date.now();
                    const swingDuration = 300;
                    const timeSinceSwing = now - saber.userData.swingTime;
                    
                    if (timeSinceSwing < swingDuration) {
                        const progress = timeSinceSwing / swingDuration;
                        const baseAngle = Math.sin(progress * Math.PI) * 45;
                        
                        // ‚úÖ ÏÑºÏÑúÎ≥Ñ Ïä§Ïúô Î∞©Ìñ• ÏÑ§Ï†ï
                        // sensor1(ÏôºÏ™Ω): Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïä§Ïúô (ÏùåÏùò Í∞ÅÎèÑ)
                        // sensor2(Ïò§Î•∏Ï™Ω): ÏôºÏ™ΩÏúºÎ°ú Ïä§Ïúô (ÏñëÏùò Í∞ÅÎèÑ)
                        let angle;
                        if (saber.userData.sensorId === 'sensor1') {
                            angle = -baseAngle;  // ÏôºÏ™Ω ÏÑ∏Ïù¥Î≤ÑÎäî Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïä§Ïúô
                        } else {
                            angle = baseAngle;   // Ïò§Î•∏Ï™Ω ÏÑ∏Ïù¥Î≤ÑÎäî ÏôºÏ™ΩÏúºÎ°ú Ïä§Ïúô
                        }
                        
                        saber.rotation.z = THREE.MathUtils.degToRad(angle);
                    } else {
                        saber.userData.swinging = false;
                        saber.rotation.z = 0;
                    }
                }
            }
            
            updateParticles() {
                for (let i = this.particleEffects.length - 1; i >= 0; i--) {
                    const particleGroup = this.particleEffects[i];
                    let allDead = true;
                    
                    particleGroup.children.forEach(particle => {
                        if (particle.userData.life > 0) {
                            allDead = false;
                            particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.02));
                            particle.userData.life -= 0.02;
                            particle.material.opacity = particle.userData.life;
                            particle.scale.setScalar(particle.userData.life);
                        }
                    });
                    
                    if (allDead) {
                        this.scene.remove(particleGroup);
                        this.particleEffects.splice(i, 1);
                    }
                }
            }
            
            updateUI() {
                document.getElementById('scoreValue').textContent = this.gameState.score;
                document.getElementById('comboValue').textContent = this.gameState.combo;
                
                const accuracy = this.gameState.totalNotes > 0 ? 
                    Math.round((this.gameState.hitNotes / this.noteSpawnIndex) * 100) : 100;
                document.getElementById('accuracyValue').textContent = `${accuracy}%`;
                
                // ‚úÖ Í≤åÏûÑ Ï¢ÖÎ£å Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌëúÏãú
                if (this.gameState.endingStartTime > 0) {
                    const remainingTime = Math.max(0, 2000 - (Date.now() - this.gameState.endingStartTime));
                    const seconds = Math.ceil(remainingTime / 1000);
                    
                    if (seconds > 0) {
                        document.getElementById('scoreValue').textContent = `Ï¢ÖÎ£å ${seconds}Ï¥à Ï†Ñ...`;
                    }
                }
            }
            
            checkGameEnd() {
                // Î™®Îì† ÎÖ∏Ìä∏Í∞Ä ÏÉùÏÑ±ÎêòÍ≥† ÌôîÎ©¥ÏóêÏÑú ÏÇ¨ÎùºÏ°åÏùÑ Îïå
                if (this.noteSpawnIndex >= this.beatmap.length && this.notes.length === 0) {
                    // ÏïÑÏßÅ Ï¢ÖÎ£å ÎåÄÍ∏∞Í∞Ä ÏãúÏûëÎêòÏßÄ ÏïäÏïòÎã§Î©¥ ÏãúÏûë
                    if (this.gameState.endingStartTime === 0) {
                        this.gameState.endingStartTime = Date.now();
                        console.log('üéØ ÎßàÏßÄÎßâ Î∏îÎ°ù Ï≤òÎ¶¨ ÏôÑÎ£å - 2Ï¥à ÌõÑ Í≤åÏûÑ Ï¢ÖÎ£å');
                    }
                    
                    // 2Ï¥à ÏßÄÏó∞ ÌõÑ Í≤åÏûÑ Ï¢ÖÎ£å
                    const elapsedEndingTime = Date.now() - this.gameState.endingStartTime;
                    if (elapsedEndingTime >= 2000) { // 2Ï¥à (2000ms) ÏßÄÏó∞
                        this.endGame();
                    }
                }
            }
            
            endGame() {
                this.gameState.phase = 'ended';
                
                // üéµ ÏùåÏïÖ Ï†ïÏßÄ
                if (this.bgMusic && !this.bgMusic.paused) {
                    this.bgMusic.pause();
                    this.bgMusic.currentTime = 0;
                }
                
                const accuracy = Math.round((this.gameState.hitNotes / this.gameState.totalNotes) * 100);
                const cooperationScore = Math.round(this.cooperation.sync);
                
                // ‚úÖ ÏÑ±Í≥ºÏóê Îî∞Î•∏ Î©îÏãúÏßÄ
                let message = "üéÆ Rhythm Blade Dual ÏôÑÎ£å!\n\n";
                message += `üìä ÏµúÏ¢Ö Í≤∞Í≥º:\n`;
                message += `Ï†êÏàò: ${this.gameState.score.toLocaleString()}\n`;
                message += `Ï†ïÌôïÎèÑ: ${accuracy}%\n`;
                message += `ÌòëÎ†•ÎèÑ: ${cooperationScore}%\n`;
                message += `ÏµúÎåÄ ÏΩ§Î≥¥: ${this.gameState.maxCombo}\n`;
                message += `ÌòÑÏû¨ ÏΩ§Î≥¥: ${this.gameState.combo}\n\n`;
                
                // ÏÑ±Í≥º ÌèâÍ∞Ä
                if (accuracy >= 95 && cooperationScore >= 90) {
                    message += "üåü PERFECT COOPERATION! üåü\nÏôÑÎ≤ΩÌïú ÌòëÎ†•ÏûÖÎãàÎã§!";
                } else if (accuracy >= 85 && cooperationScore >= 80) {
                    message += "üéñÔ∏è EXCELLENT TEAMWORK! üéñÔ∏è\nÌõåÎ•≠Ìïú ÌåÄÏõåÌÅ¨ÏûÖÎãàÎã§!";
                } else if (accuracy >= 70 && cooperationScore >= 70) {
                    message += "üëç GOOD COOPERATION! üëç\nÏ¢ãÏùÄ ÌòëÎ†•Ïù¥ÏóàÏäµÎãàÎã§!";
                } else if (accuracy >= 50) {
                    message += "üí™ KEEP PRACTICING! üí™\nÏó∞ÏäµÌïòÎ©¥ Îçî Ï¢ãÏïÑÏßà Í±∞ÏòàÏöî!";
                } else {
                    message += "üéØ TRY AGAIN! üéØ\nÎã§Ïãú ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî!";
                }
                
                alert(message);
                
                console.log('üéÆ Í≤åÏûÑ Ï¢ÖÎ£å - ÎßàÏßÄÎßâ Î∏îÎ°ù Ï≤òÎ¶¨ ÏôÑÎ£å 2Ï¥à ÌõÑ Ï¢ÖÎ£å!');
            }
            
            resetGame() {
                this.gameState = {
                    phase: 'playing',
                    score: 0,
                    combo: 0,
                    maxCombo: 0,
                    totalNotes: this.beatmap.length,
                    hitNotes: 0,
                    startTime: Date.now(),
                    endingStartTime: 0        // 2Ï¥à ÏßÄÏó∞ Ï¢ÖÎ£åÎ•º ÏúÑÌïú Ï¥àÍ∏∞Ìôî
                };
                
                this.noteSpawnIndex = 0;
                this.cooperation.sync = 100;
                this.cooperation.cooperationBonus = 1.0;
                
                // Í∏∞Ï°¥ ÎÖ∏Ìä∏Îì§ Ï†úÍ±∞
                this.notes.forEach(note => this.scene.remove(note));
                this.notes = [];
                
                // üéµ ÏùåÏïÖ Ïû¨ÏãúÏûë
                if (this.musicLoaded) {
                    this.bgMusic.currentTime = 0;
                    this.bgMusic.play().catch(e => {
                        console.warn('üéµ ÏùåÏïÖ Ïû¨ÏãúÏûë Ïã§Ìå®:', e);
                    });
                }
                
                console.log('üîÑ Í≤åÏûÑ Ïû¨ÏãúÏûë');
            }
            
            togglePause() {
                if (this.gameState.phase === 'playing') {
                    this.gameState.phase = 'paused';
                    // üéµ ÏùåÏïÖ ÏùºÏãúÏ†ïÏßÄ
                    if (this.bgMusic && !this.bgMusic.paused) {
                        this.bgMusic.pause();
                    }
                    console.log('‚è∏Ô∏è Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ');
                } else if (this.gameState.phase === 'paused') {
                    this.gameState.phase = 'playing';
                    // üéµ ÏùåÏïÖ Ïû¨Í∞ú
                    if (this.bgMusic && this.bgMusic.paused) {
                        this.bgMusic.play().catch(e => {
                            console.warn('üéµ ÏùåÏïÖ Ïû¨Í∞ú Ïã§Ìå®:', e);
                        });
                    }
                    console.log('‚ñ∂Ô∏è Í≤åÏûÑ Ïû¨Í∞ú');
                }
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
            }
            
            gameLoop() {
                requestAnimationFrame(() => this.gameLoop());
                this.update();
                this.render();
            }
        }
        
        // Í≤åÏûÑ ÏãúÏûë
        const game = new RhythmBladeDual();
        window.game = game;  // ÎîîÎ≤ÑÍπÖÏö©
    </script>
</body>
</html>