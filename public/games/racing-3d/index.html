<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸï¸ 3D ìë™ì°¨ ê²½ì£¼</title>
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #0f172a;
            --surface: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --border: #475569;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0f172a, #1e293b);
        }
        
        .game-ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.25rem;
            backdrop-filter: blur(12px);
            pointer-events: all;
        }
        
        .session-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            min-width: 400px;
        }
        
        .session-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .session-code {
            font-size: 3rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            color: var(--primary);
            margin: 1.5rem 0;
            padding: 1rem;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--primary);
            border-radius: 0.75rem;
            letter-spacing: 0.3em;
        }
        
        .qr-container {
            margin: 1.5rem 0;
            padding: 1rem;
            background: white;
            border-radius: 0.75rem;
            display: inline-block;
        }
        
        .control-panel {
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1rem;
        }
        
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            text-decoration: none;
            display: inline-block;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .hidden {
            display: none !important;
        }

        /* í™”ë©´ ë¶„í•  ìŠ¤íƒ€ì¼ */
        .split-screen {
            display: flex;
            width: 100%;
            height: 100%;
        }
        
        .player-viewport {
            flex: 1;
            position: relative;
            border-right: 2px solid var(--border);
            overflow: hidden;
        }
        
        .player-viewport:last-child {
            border-right: none;
        }
        
        .player-hud {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(30, 41, 59, 0.95);
            padding: 1rem;
            border-radius: 0.75rem;
            backdrop-filter: blur(12px);
            min-width: 220px;
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .player-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
            color: var(--primary);
            text-align: center;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .hud-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        
        .hud-stat:last-child {
            margin-bottom: 0;
        }
        
        .hud-label {
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .hud-value {
            font-weight: 700;
            font-family: 'Courier New', monospace;
            color: var(--text-primary);
            background: rgba(59, 130, 246, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            min-width: 80px;
            text-align: center;
        }
        
        /* ì—°ê²° ìƒíƒœ í‘œì‹œ */
        .connection-status {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(30, 41, 59, 0.95);
            padding: 0.75rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(8px);
            border: 1px solid var(--border);
        }
        
        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
        }
        
        .connection-indicator:last-child {
            margin-bottom: 0;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error);
            transition: all 0.3s ease;
        }
        
        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 6px var(--success);
        }
        
        /* ê²Œì„ ìƒíƒœ í‘œì‹œ */
        .game-status {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 41, 59, 0.95);
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            backdrop-filter: blur(8px);
            border: 1px solid var(--border);
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        /* ì¹´ìš´íŠ¸ë‹¤ìš´ ìŠ¤íƒ€ì¼ */
        .countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: 900;
            color: var(--primary);
            text-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            z-index: 200;
            animation: countdownPulse 1s ease-in-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui">
        <!-- ì„¸ì…˜ ëŒ€ê¸° íŒ¨ë„ -->
        <div class="ui-panel session-panel" id="sessionPanel">
            <div class="session-title">ğŸï¸ 3D ìë™ì°¨ ê²½ì£¼</div>
            <div style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                ë‘ ëª…ì´ ì„¼ì„œë¡œ ì¡°ì‘í•˜ëŠ” 3D ìë™ì°¨ ê²½ì£¼ ê²Œì„<br>
                í™”ë©´ ë¶„í• ë¡œ ê°ìì˜ ì‹œì ì—ì„œ ê²½ì£¼í•˜ì„¸ìš”!
            </div>
            
            <div class="session-code" id="sessionCode">----</div>
            
            <div class="qr-container" id="qrContainer">
                <div style="color: #666; padding: 2rem;">QR ì½”ë“œ ìƒì„± ì¤‘...</div>
            </div>
            
            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 1rem;">
                ğŸ“± ëª¨ë°”ì¼ë¡œ QR ì½”ë“œë¥¼ ìŠ¤ìº”í•˜ê±°ë‚˜<br>
                ì„¼ì„œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„¸ì…˜ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”<br><br>
                <strong>ì¡°ì‘ë²•:</strong><br>
                ì¢Œìš° ê¸°ìš¸ê¸° â†’ í•¸ë“¤ ì¡°ì‘<br>
                ì•ìœ¼ë¡œ ê¸°ìš¸ê¸° â†’ ê°€ì†<br>
                ë’¤ë¡œ ê¸°ìš¸ê¸° â†’ ë¸Œë ˆì´í¬
            </div>
        </div>
        
        <!-- ê²Œì„ HUD -->
        <div class="split-screen hidden" id="gameHUD">
            <div class="player-viewport">
                <div class="player-hud">
                    <div class="player-title">ğŸï¸ í”Œë ˆì´ì–´ 1</div>
                    <div class="hud-stat">
                        <span class="hud-label">ì†ë„:</span>
                        <span class="hud-value" id="player1Speed">0 km/h</span>
                    </div>
                    <div class="hud-stat">
                        <span class="hud-label">ë©:</span>
                        <span class="hud-value" id="player1Lap">0/3</span>
                    </div>
                    <div class="hud-stat">
                        <span class="hud-label">ì‹œê°„:</span>
                        <span class="hud-value" id="player1Time">0.00s</span>
                    </div>
                </div>
                
                <!-- ì—°ê²° ìƒíƒœ í‘œì‹œ -->
                <div class="connection-status">
                    <div class="connection-indicator">
                        <div class="status-dot" id="server1Status"></div>
                        <span>ì„œë²„</span>
                    </div>
                    <div class="connection-indicator">
                        <div class="status-dot" id="sensor1Status"></div>
                        <span>ì„¼ì„œ 1</span>
                    </div>
                </div>
            </div>
            <div class="player-viewport">
                <div class="player-hud">
                    <div class="player-title">ğŸï¸ í”Œë ˆì´ì–´ 2</div>
                    <div class="hud-stat">
                        <span class="hud-label">ì†ë„:</span>
                        <span class="hud-value" id="player2Speed">0 km/h</span>
                    </div>
                    <div class="hud-stat">
                        <span class="hud-label">ë©:</span>
                        <span class="hud-value" id="player2Lap">0/3</span>
                    </div>
                    <div class="hud-stat">
                        <span class="hud-label">ì‹œê°„:</span>
                        <span class="hud-value" id="player2Time">0.00s</span>
                    </div>
                </div>
                
                <!-- ì—°ê²° ìƒíƒœ í‘œì‹œ -->
                <div class="connection-status">
                    <div class="connection-indicator">
                        <div class="status-dot" id="server2Status"></div>
                        <span>ì„œë²„</span>
                    </div>
                    <div class="connection-indicator">
                        <div class="status-dot" id="sensor2Status"></div>
                        <span>ì„¼ì„œ 2</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ê²Œì„ ìƒíƒœ í‘œì‹œ -->
        <div class="game-status hidden" id="gameStatus">ê²Œì„ ì¤€ë¹„ ì¤‘...</div>
        
        <!-- ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
        <div class="ui-panel control-panel hidden" id="controlPanel">
            <button class="btn btn-secondary" id="pauseResumeBtn" onclick="game.togglePauseResume()">â¸ï¸ ì¼ì‹œì •ì§€</button>
            <button class="btn btn-secondary" onclick="game.resetGame()">ğŸ”„ ì¬ì‹œì‘</button>
            <button class="btn btn-secondary" onclick="game.returnToHub()">ğŸ  í—ˆë¸Œë¡œ</button>
        </div>
    </div>
    
    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    
    <!-- QR Code Generator (í´ë°± ì²˜ë¦¬ í¬í•¨) -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- Three.js (ë¡œì»¬ ë¼ì´ë¸ŒëŸ¬ë¦¬) -->
    <script src="libs/three.min.js"></script>
    
    <!-- Cannon.js ë¬¼ë¦¬ ì—”ì§„ (ë¡œì»¬ ë¼ì´ë¸ŒëŸ¬ë¦¬) -->
    <script src="libs/cannon.min.js"></script>
    
    <!-- SessionSDK -->
    <script src="/js/SessionSDK.js"></script>
    
    <script>
        // Car í´ë˜ìŠ¤ êµ¬í˜„
        class Car {
            constructor(scene, world, color, x, y, z, carMaterial) {
                this.scene = scene;
                this.world = world;
                this.color = color;
                this.carMaterial = carMaterial;
                
                // 3D ë©”ì‹œ ê·¸ë£¹ ìƒì„±
                this.mesh = new THREE.Group();
                
                // ë¬¼ë¦¬ ë°”ë”” ìƒì„±
                this.physicsBody = this.createPhysicsBody(x, y, z);
                
                // 3D ëª¨ë¸ ìƒì„±
                this.create3DModel();
                
                // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
                this.mesh.position.set(x, y, z);
                
                // ì”¬ì— ì¶”ê°€
                this.scene.add(this.mesh);
                
                // ìë™ì°¨ ì†ì„±
                this.maxSpeed = 30; // m/s
                this.acceleration = 0;
                this.steering = 0;
                this.enginePower = 1500; // N
                this.brakePower = 3000; // N
            }
            
            create3DModel() {
                // ìë™ì°¨ ë³¸ì²´ (ë” ìƒì„¸í•œ ëª¨ë¸)
                this.createCarBody();
                
                // ë°”í€´ë“¤
                this.createWheels();
                
                // ìë™ì°¨ ì„¸ë¶€ì‚¬í•­
                this.createCarDetails();
            }
            
            createCarBody() {
                // ë©”ì¸ ë°”ë””
                const bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.9
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.3;
                body.castShadow = true;
                body.receiveShadow = true;
                this.mesh.add(body);
                
                // ìë™ì°¨ ì§€ë¶• (ìºë¹ˆ)
                const roofGeometry = new THREE.BoxGeometry(1.6, 0.8, 2);
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.color === 0xff0000 ? 0xcc0000 : 0x0000cc // ì•½ê°„ ì–´ë‘ìš´ ìƒ‰ìƒ
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 0.7, -0.5);
                roof.castShadow = true;
                this.mesh.add(roof);
                
                // ì• ë²”í¼
                const frontBumperGeometry = new THREE.BoxGeometry(1.9, 0.3, 0.3);
                const bumperMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const frontBumper = new THREE.Mesh(frontBumperGeometry, bumperMaterial);
                frontBumper.position.set(0, 0.15, 2.1);
                frontBumper.castShadow = true;
                this.mesh.add(frontBumper);
                
                // ë’¤ ë²”í¼
                const rearBumper = new THREE.Mesh(frontBumperGeometry, bumperMaterial);
                rearBumper.position.set(0, 0.15, -2.1);
                rearBumper.castShadow = true;
                this.mesh.add(rearBumper);
            }
            
            createWheels() {
                const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12);
                const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                
                // íœ  ë¦¼ (ì€ìƒ‰)
                const rimGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.32, 12);
                const rimMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
                
                const wheelPositions = [
                    { pos: [-1.1, 0.4, 1.4], name: 'frontLeft' },   // ì•ì™¼ìª½
                    { pos: [1.1, 0.4, 1.4], name: 'frontRight' },   // ì•ì˜¤ë¥¸ìª½
                    { pos: [-1.1, 0.4, -1.4], name: 'rearLeft' },   // ë’¤ì™¼ìª½
                    { pos: [1.1, 0.4, -1.4], name: 'rearRight' }    // ë’¤ì˜¤ë¥¸ìª½
                ];
                
                this.wheels = {};
                
                wheelPositions.forEach(wheelData => {
                    const wheelGroup = new THREE.Group();
                    
                    // íƒ€ì´ì–´
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.castShadow = true;
                    wheelGroup.add(wheel);
                    
                    // íœ  ë¦¼
                    const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                    rim.rotation.z = Math.PI / 2;
                    rim.castShadow = true;
                    wheelGroup.add(rim);
                    
                    wheelGroup.position.set(wheelData.pos[0], wheelData.pos[1], wheelData.pos[2]);
                    this.wheels[wheelData.name] = wheelGroup;
                    this.mesh.add(wheelGroup);
                });
            }
            
            createCarDetails() {
                // í—¤ë“œë¼ì´íŠ¸
                const headlightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const headlightMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffffaa,
                    emissive: 0x444400
                });
                
                const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                leftHeadlight.position.set(-0.6, 0.4, 1.9);
                this.mesh.add(leftHeadlight);
                
                const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                rightHeadlight.position.set(0.6, 0.4, 1.9);
                this.mesh.add(rightHeadlight);
                
                // í…Œì¼ë¼ì´íŠ¸
                const taillightMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4444,
                    emissive: 0x440000
                });
                
                const leftTaillight = new THREE.Mesh(headlightGeometry, taillightMaterial);
                leftTaillight.position.set(-0.6, 0.4, -1.9);
                this.mesh.add(leftTaillight);
                
                const rightTaillight = new THREE.Mesh(headlightGeometry, taillightMaterial);
                rightTaillight.position.set(0.6, 0.4, -1.9);
                this.mesh.add(rightTaillight);
                
                // ìœˆë“œì‹¤ë“œ (ì•ìœ ë¦¬)
                const windshieldGeometry = new THREE.PlaneGeometry(1.4, 0.6);
                const windshieldMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.3
                });
                const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
                windshield.position.set(0, 0.8, 0.8);
                windshield.rotation.x = -0.3;
                this.mesh.add(windshield);
            }
            
            createPhysicsBody(x, y, z) {
                // CANNON.jsê°€ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ë¬¼ë¦¬ ë°”ë”” ì—†ì´ ì‹¤í–‰
                if (typeof CANNON === 'undefined' || !this.world) {
                    console.warn('ë¬¼ë¦¬ ì—”ì§„ ì—†ì´ ìë™ì°¨ ìƒì„±');
                    return null;
                }
                
                try {
                    // ìë™ì°¨ ë¬¼ë¦¬ ë°”ë”” ìƒì„± (ë” ì •í™•í•œ í¬ê¸°)
                    const carShape = new CANNON.Box(new CANNON.Vec3(0.9, 0.4, 2)); // í¬ê¸°ì˜ ì ˆë°˜
                    const carBody = new CANNON.Body({ 
                        mass: 150, // ìë™ì°¨ ì§ˆëŸ‰ (kg)
                        material: this.carMaterial 
                    });
                    carBody.addShape(carShape);
                    carBody.position.set(x, y, z);
                    
                    // ë¬¼ë¦¬ ì„¸ê³„ì— ì¶”ê°€
                    this.world.add(carBody);
                    
                    return carBody;
                } catch (error) {
                    console.error('ë¬¼ë¦¬ ë°”ë”” ìƒì„± ì˜¤ë¥˜:', error);
                    return null;
                }
            }
            
            // ì„¼ì„œ ë°ì´í„°ë¥¼ ìë™ì°¨ì— ì ìš©
            applySensorInput(speed, steering) {
                this.acceleration = speed;
                this.steering = steering;
                
                // ë¬¼ë¦¬ ë°”ë””ì— í˜ ì ìš©
                this.applyPhysicsForces();
            }
            
            applyPhysicsForces() {
                if (!this.physicsBody) return;
                
                // ì „ì§„/í›„ì§„ í˜ ì ìš©
                if (Math.abs(this.acceleration) > 0.1) {
                    const forwardForce = new CANNON.Vec3(0, 0, -this.acceleration * this.enginePower);
                    const worldForce = new CANNON.Vec3();
                    this.physicsBody.quaternion.vmult(forwardForce, worldForce);
                    this.physicsBody.applyForce(worldForce, this.physicsBody.position);
                }
                
                // ì¡°í–¥ í† í¬ ì ìš©
                if (Math.abs(this.steering) > 0.1) {
                    const torque = new CANNON.Vec3(0, this.steering * 800, 0);
                    this.physicsBody.applyTorque(torque);
                }
                
                // ì†ë„ ì œí•œ
                if (this.physicsBody.velocity.length() > this.maxSpeed) {
                    this.physicsBody.velocity.scale(this.maxSpeed / this.physicsBody.velocity.length(), this.physicsBody.velocity);
                }
                
                // ë°”í€´ íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                this.animateWheels();
            }
            
            animateWheels() {
                if (!this.wheels || !this.physicsBody) return;
                
                const speed = this.physicsBody.velocity.length();
                const rotationSpeed = speed * 0.1;
                
                // ëª¨ë“  ë°”í€´ íšŒì „
                Object.values(this.wheels).forEach(wheel => {
                    wheel.rotation.x += rotationSpeed;
                });
                
                // ì•ë°”í€´ ì¡°í–¥ (ìŠ¤í‹°ì–´ë§ íœ  íš¨ê³¼)
                if (this.wheels.frontLeft && this.wheels.frontRight) {
                    const steerAngle = this.steering * 0.3;
                    this.wheels.frontLeft.rotation.y = steerAngle;
                    this.wheels.frontRight.rotation.y = steerAngle;
                }
            }
            
            // ë¬¼ë¦¬ ë°”ë””ì™€ 3D ë©”ì‹œ ë™ê¸°í™”
            update() {
                if (this.physicsBody && this.mesh) {
                    // ìœ„ì¹˜ ë™ê¸°í™”
                    this.mesh.position.copy(this.physicsBody.position);
                    this.mesh.quaternion.copy(this.physicsBody.quaternion);
                    
                    // ë°”í€´ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
                    this.animateWheels();
                }
            }
            
            // ìë™ì°¨ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
            getPosition() {
                return this.physicsBody ? this.physicsBody.position : new CANNON.Vec3(0, 0, 0);
            }
            
            // ìë™ì°¨ ì†ë„ ê°€ì ¸ì˜¤ê¸° (km/h)
            getSpeed() {
                return this.physicsBody ? this.physicsBody.velocity.length() * 3.6 : 0;
            }
            
            // ìë™ì°¨ ë¦¬ì…‹
            reset(x, y, z) {
                if (this.physicsBody) {
                    this.physicsBody.position.set(x, y, z);
                    this.physicsBody.velocity.set(0, 0, 0);
                    this.physicsBody.angularVelocity.set(0, 0, 0);
                    this.physicsBody.quaternion.set(0, 0, 0, 1);
                }
            }
        }      
  
        // RacingGame í´ë˜ìŠ¤ êµ¬í˜„
        class RacingGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                
                // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // SessionSDK ì´ˆê¸°í™” - ë“€ì–¼ ê²Œì„ ì„¤ì •
                this.sdk = new SessionSDK({
                    gameId: 'racing-3d',
                    gameType: 'dual',
                    debug: true
                });
                
                // ê²Œì„ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ (ì‘ì—… 9)
                this.gameState = 'waiting'; // waiting, preparing, racing, paused, finished
                this.sessionCode = null;
                this.connectedSensors = new Set();
                this.gameStartTime = null;
                this.raceStartTime = null;
                this.countdownTimer = null;
                this.gameTimer = null;
                this.isPaused = false;
                
                // ë© ì¹´ìš´íŠ¸ ë° ìˆœìœ„ ì‹œìŠ¤í…œ (ì‘ì—… 10)
                this.checkpoints = [];
                this.lapDistance = 50; // í•œ ë©ì˜ ê±°ë¦¬ (ë¯¸í„°)
                this.totalLaps = 3; // ì´ ë© ìˆ˜
                this.raceFinished = false;
                
                // ë© ì¶”ì  ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                this.lapTracking = {
                    sensor1: {
                        currentLap: 0,
                        lastCheckpoint: -1,
                        lapStartTime: null,
                        lapTimes: [],
                        bestLapTime: Infinity,
                        rank: 1
                    },
                    sensor2: {
                        currentLap: 0,
                        lastCheckpoint: -1,
                        lapStartTime: null,
                        lapTimes: [],
                        bestLapTime: Infinity,
                        rank: 2
                    }
                };
                
                // í”Œë ˆì´ì–´ ë°ì´í„°
                this.players = {
                    sensor1: {
                        connected: false,
                        speed: 0,
                        lapCount: 0,
                        lapTime: 0,
                        totalTime: 0,
                        position: { x: 0, y: 0, z: 0 },
                        sensorData: { tiltX: 0, tiltY: 0, acceleration: 0 },
                        steering: 0
                    },
                    sensor2: {
                        connected: false,
                        speed: 0,
                        lapCount: 0,
                        lapTime: 0,
                        totalTime: 0,
                        position: { x: 0, y: 0, z: 0 },
                        sensorData: { tiltX: 0, tiltY: 0, acceleration: 0 },
                        steering: 0
                    }
                };
                
                // ì—°ê²° ìƒíƒœ ì¶”ì 
                this.connectionStatus = {
                    server: false,
                    sensor1: false,
                    sensor2: false
                };
                
                // DOM ìš”ì†Œ ì°¸ì¡°
                this.elements = {
                    sessionPanel: document.getElementById('sessionPanel'),
                    gameHUD: document.getElementById('gameHUD'),
                    controlPanel: document.getElementById('controlPanel'),
                    sessionCode: document.getElementById('sessionCode'),
                    qrContainer: document.getElementById('qrContainer')
                };
                
                // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì´ˆê¸°í™” (ì‘ì—… 15)
                this.keyboardTestMode = false;
                this.debugMode = false;
                this.keyStates = {};
                this.debugUpdateInterval = null;
                this.lastFrameTime = Date.now();
                
                this.setupEventListeners();
                this.updateConnectionUI();
                this.setup3DEngine();
                
                // ê²Œì„ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ì‘ì—… 17)
                this.initializeTestSystem();
                
                console.log('ğŸï¸ Racing Game ì´ˆê¸°í™” ì™„ë£Œ');
            }         
   
            setup3DEngine() {
                // Three.js ë Œë”ëŸ¬ ì„¤ì •
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: false
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB, 1); // í•˜ëŠ˜ìƒ‰ ë°°ê²½
                
                // í™”ë©´ ë¶„í• ì„ ìœ„í•œ ë“€ì–¼ ì¹´ë©”ë¼ ì‹œìŠ¤í…œ
                this.cameras = {
                    player1: new THREE.PerspectiveCamera(75, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000),
                    player2: new THREE.PerspectiveCamera(75, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000)
                };
                
                // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
                this.cameras.player1.position.set(-10, 5, 10);
                this.cameras.player1.lookAt(0, 0, 0);
                
                this.cameras.player2.position.set(10, 5, 10);
                this.cameras.player2.lookAt(0, 0, 0);
                
                // 3D ì”¬ ìƒì„±
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                // ì¡°ëª… ì„¤ì •
                this.setupLighting();
                
                // ë¬¼ë¦¬ ì—”ì§„ ì„¤ì •
                this.setupPhysicsEngine();
                
                // ê¸°ë³¸ í™˜ê²½ ìƒì„±
                this.createBasicEnvironment();
                
                console.log('âœ… 3D ë Œë”ë§ ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
            }       
     
            setupLighting() {
                // ì£¼ë³€ê´‘ (ì „ì²´ì ì¸ ë°ê¸°)
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // íƒœì–‘ê´‘ (ê·¸ë¦¼ì ìƒì„±)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 25);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 200;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
                
                // ë³´ì¡° ì¡°ëª… (ë¶€ë“œëŸ¬ìš´ ê·¸ë¦¼ì)
                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x362d1d, 0.3);
                this.scene.add(hemisphereLight);
            }
            
            setupPhysicsEngine() {
                // CANNON.js ë¡œë”© í™•ì¸ ë° ì—ëŸ¬ ì²˜ë¦¬
                if (typeof CANNON === 'undefined') {
                    console.error('âŒ CANNON.jsê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¬¼ë¦¬ ì—”ì§„ ì—†ì´ ì‹¤í–‰í•©ë‹ˆë‹¤.');
                    this.world = null;
                    this.physicsEnabled = false;
                    return;
                }
                
                try {
                    // Cannon.js ë¬¼ë¦¬ ì—”ì§„ ì„¤ì •
                    this.world = new CANNON.World();
                    this.physicsEnabled = true;
                    this.world.gravity.set(0, -9.82, 0); // ì¤‘ë ¥ ì„¤ì •
                    this.world.broadphase = new CANNON.NaiveBroadphase();
                    this.world.solver.iterations = 10;
                    
                    // ë¬¼ë¦¬ ì¬ì§ˆ ì„¤ì •
                    this.physicsMaterials = {
                        ground: new CANNON.Material('ground'),
                        car: new CANNON.Material('car'),
                        wall: new CANNON.Material('wall')
                    };
                    
                    // ì¬ì§ˆ ê°„ ì ‘ì´‰ ì„¤ì •
                    const groundCarContact = new CANNON.ContactMaterial(
                        this.physicsMaterials.ground,
                        this.physicsMaterials.car,
                        {
                            friction: 0.4,
                            restitution: 0.3
                        }
                    );
                    this.world.addContactMaterial(groundCarContact);
                    
                    const carWallContact = new CANNON.ContactMaterial(
                        this.physicsMaterials.car,
                        this.physicsMaterials.wall,
                        {
                            friction: 0.1,
                            restitution: 0.8
                        }
                    );
                    this.world.addContactMaterial(carWallContact);
                    
                    // ìë™ì°¨ ê°„ ì¶©ëŒ ì„¤ì • (ì‘ì—… 11)
                    const carCarContact = new CANNON.ContactMaterial(
                        this.physicsMaterials.car,
                        this.physicsMaterials.car,
                        {
                            friction: 0.3,
                            restitution: 0.6
                        }
                    );
                    this.world.addContactMaterial(carCarContact);
                    
                    // ì¶©ëŒ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (ì‘ì—… 11)
                    this.setupCollisionDetection();
                    
                    console.log('âœ… ë¬¼ë¦¬ ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('ë¬¼ë¦¬ ì—”ì§„ ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                    this.world = null;
                    this.physicsEnabled = false;
                }
            }
            
            // ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ ì„¤ì • (ì‘ì—… 11)
            setupCollisionDetection() {
                // ì¶©ëŒ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                this.world.addEventListener('collide', (event) => {
                    this.handleCollision(event);
                });
                
                console.log('âœ… ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ ì„¤ì • ì™„ë£Œ');
            }
            
            // ì¶©ëŒ ì²˜ë¦¬ ë©”ì„œë“œ (ì‘ì—… 11)
            handleCollision(event) {
                const { bodyA, bodyB } = event;
                
                // ìë™ì°¨ ê°„ ì¶©ëŒ ê°ì§€
                if (this.isCarCollision(bodyA, bodyB)) {
                    this.handleCarCollision(bodyA, bodyB);
                }
                
                // ìë™ì°¨ì™€ ë²½ ì¶©ëŒ ê°ì§€
                if (this.isCarWallCollision(bodyA, bodyB)) {
                    this.handleCarWallCollision(bodyA, bodyB);
                }
            }
            
            // ìë™ì°¨ ê°„ ì¶©ëŒ í™•ì¸ (ì‘ì—… 11)
            isCarCollision(bodyA, bodyB) {
                const carBodies = [
                    this.cars?.player1?.physicsBody,
                    this.cars?.player2?.physicsBody
                ].filter(body => body);
                
                return carBodies.includes(bodyA) && carBodies.includes(bodyB);
            }
            
            // ìë™ì°¨ì™€ ë²½ ì¶©ëŒ í™•ì¸ (ì‘ì—… 11)
            isCarWallCollision(bodyA, bodyB) {
                const carBodies = [
                    this.cars?.player1?.physicsBody,
                    this.cars?.player2?.physicsBody
                ].filter(body => body);
                
                const carBody = carBodies.find(body => body === bodyA || body === bodyB);
                const otherBody = carBody === bodyA ? bodyB : bodyA;
                
                return carBody && otherBody.material === this.physicsMaterials.wall;
            }
            
            // ìë™ì°¨ ê°„ ì¶©ëŒ ì²˜ë¦¬ (ì‘ì—… 11)
            handleCarCollision(bodyA, bodyB) {
                console.log('ğŸ’¥ ìë™ì°¨ ê°„ ì¶©ëŒ ë°œìƒ!');
                
                // ì¶©ëŒ ì‹œ ì†ë„ ê°ì†Œ
                const impactForce = 0.7; // ì¶©ëŒ ì‹œ ì†ë„ ìœ ì§€ ë¹„ìœ¨
                
                bodyA.velocity.scale(impactForce, bodyA.velocity);
                bodyB.velocity.scale(impactForce, bodyB.velocity);
                
                // ì¶©ëŒ ì‹œ ê°ì†ë„ë„ ê°ì†Œ
                bodyA.angularVelocity.scale(0.5, bodyA.angularVelocity);
                bodyB.angularVelocity.scale(0.5, bodyB.angularVelocity);
                
                // ì¶©ëŒ íš¨ê³¼ìŒì´ë‚˜ ì‹œê° íš¨ê³¼ë¥¼ ì—¬ê¸°ì— ì¶”ê°€í•  ìˆ˜ ìˆìŒ
                this.showCollisionEffect(bodyA.position, bodyB.position);
            }
            
            // ìë™ì°¨ì™€ ë²½ ì¶©ëŒ ì²˜ë¦¬ (ì‘ì—… 11)
            handleCarWallCollision(bodyA, bodyB) {
                const carBody = [bodyA, bodyB].find(body => 
                    body === this.cars?.player1?.physicsBody || 
                    body === this.cars?.player2?.physicsBody
                );
                
                if (carBody) {
                    console.log('ğŸ§± ë²½ ì¶©ëŒ ë°œìƒ!');
                    
                    // ë²½ ì¶©ëŒ ì‹œ ì†ë„ í¬ê²Œ ê°ì†Œ
                    const wallImpactForce = 0.3;
                    carBody.velocity.scale(wallImpactForce, carBody.velocity);
                    carBody.angularVelocity.scale(0.2, carBody.angularVelocity);
                    
                    // ì¶©ëŒ íš¨ê³¼ í‘œì‹œ
                    this.showWallCollisionEffect(carBody.position);
                }
            }
            
            // ì¶©ëŒ ì‹œê° íš¨ê³¼ (ì‘ì—… 11)
            showCollisionEffect(posA, posB) {
                // ì¶©ëŒ ì§€ì  ê³„ì‚°
                const collisionPoint = new THREE.Vector3(
                    (posA.x + posB.x) / 2,
                    (posA.y + posB.y) / 2 + 1,
                    (posA.z + posB.z) / 2
                );
                
                // ì¶©ëŒ íŒŒí‹°í´ íš¨ê³¼ ìƒì„±
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff4444,
                    transparent: true,
                    opacity: 0.8
                });
                
                for (let i = 0; i < 10; i++) {
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(collisionPoint);
                    particle.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    ));
                    
                    this.scene.add(particle);
                    
                    // íŒŒí‹°í´ ì• ë‹ˆë©”ì´ì…˜ ë° ì œê±°
                    setTimeout(() => {
                        this.scene.remove(particle);
                    }, 1000);
                }
            }
            
            // ë²½ ì¶©ëŒ ì‹œê° íš¨ê³¼ (ì‘ì—… 11)
            showWallCollisionEffect(position) {
                // ë²½ ì¶©ëŒ ìŠ¤íŒŒí¬ íš¨ê³¼
                const sparkGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                const sparkMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 1.0
                });
                
                for (let i = 0; i < 15; i++) {
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    spark.position.set(
                        position.x + (Math.random() - 0.5) * 1,
                        position.y + Math.random() * 1,
                        position.z + (Math.random() - 0.5) * 1
                    );
                    
                    this.scene.add(spark);
                    
                    // ìŠ¤íŒŒí¬ ì• ë‹ˆë©”ì´ì…˜
                    const animateSpark = () => {
                        spark.position.y += 0.1;
                        spark.material.opacity -= 0.02;
                        
                        if (spark.material.opacity > 0) {
                            requestAnimationFrame(animateSpark);
                        } else {
                            this.scene.remove(spark);
                        }
                    };
                    
                    animateSpark();
                }
            }   
         
            createBasicEnvironment() {
                // íŠ¸ë™ ìƒì„±
                const trackGeometry = new THREE.PlaneGeometry(100, 20);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const track = new THREE.Mesh(trackGeometry, trackMaterial);
                track.rotation.x = -Math.PI / 2;
                track.receiveShadow = true;
                this.scene.add(track);
                
                // íŠ¸ë™ ë¬¼ë¦¬ ë°”ë”” (ë¬¼ë¦¬ ì—”ì§„ì´ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ)
                if (this.physicsEnabled && this.world && typeof CANNON !== 'undefined') {
                    const trackShape = new CANNON.Plane();
                    const trackBody = new CANNON.Body({ 
                        mass: 0,
                        material: this.physicsMaterials.ground
                    });
                    trackBody.addShape(trackShape);
                    trackBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                    this.world.add(trackBody);
                }
                
                // íŠ¸ë™ ê²½ê³„ ë²½ ìƒì„±
                this.createTrackWalls();
                
                // ì²´í¬í¬ì¸íŠ¸ ì‹œìŠ¤í…œ ìƒì„± (ì‘ì—… 10)
                this.createCheckpoints();
                
                // ìë™ì°¨ ìƒì„±
                this.cars = {
                    player1: new Car(this.scene, this.world, 0xff0000, -5, 0.5, -2, this.physicsMaterials.car), // ë¹¨ê°„ìƒ‰
                    player2: new Car(this.scene, this.world, 0x0000ff, -5, 0.5, 2, this.physicsMaterials.car)   // íŒŒë€ìƒ‰
                };
                
                // í”Œë ˆì´ì–´ë³„ ë© ì¶”ì  ë°ì´í„° ì´ˆê¸°í™”
                this.initializeLapTracking();
                
                // ë Œë”ë§ ë£¨í”„ ì‹œì‘
                this.startRenderLoop();
            }
            
            createTrackWalls() {
                // íŠ¸ë™ ì–‘ìª½ ë²½ ìƒì„±
                const wallHeight = 2;
                const wallGeometry = new THREE.BoxGeometry(100, wallHeight, 0.5);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                
                // ì™¼ìª½ ë²½
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                leftWall.position.set(0, wallHeight/2, -10.25);
                leftWall.castShadow = true;
                this.scene.add(leftWall);
                
                // ì˜¤ë¥¸ìª½ ë²½
                const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
                rightWall.position.set(0, wallHeight/2, 10.25);
                rightWall.castShadow = true;
                this.scene.add(rightWall);
                
                // ë²½ ë¬¼ë¦¬ ë°”ë”” (ë¬¼ë¦¬ ì—”ì§„ì´ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ)
                if (this.physicsEnabled && this.world && typeof CANNON !== 'undefined') {
                    const wallShape = new CANNON.Box(new CANNON.Vec3(50, wallHeight/2, 0.25));
                    
                    const leftWallBody = new CANNON.Body({ 
                        mass: 0,
                        material: this.physicsMaterials.wall
                    });
                    leftWallBody.addShape(wallShape);
                    leftWallBody.position.set(0, wallHeight/2, -10.25);
                    this.world.add(leftWallBody);
                    
                    const rightWallBody = new CANNON.Body({ 
                        mass: 0,
                        material: this.physicsMaterials.wall
                    });
                    rightWallBody.addShape(wallShape);
                    rightWallBody.position.set(0, wallHeight/2, 10.25);
                    this.world.add(rightWallBody);
                }
            }
            
            // ì²´í¬í¬ì¸íŠ¸ ì‹œìŠ¤í…œ ìƒì„± (ì‘ì—… 10)
            createCheckpoints() {
                this.checkpoints = [];
                
                // ì‹œì‘/ê²°ìŠ¹ì„  (ì²´í¬í¬ì¸íŠ¸ 0)
                this.createCheckpoint(-45, 0, 0, 0xff00ff, 'ì‹œì‘/ê²°ìŠ¹ì„ ');
                
                // ì¤‘ê°„ ì²´í¬í¬ì¸íŠ¸ë“¤
                this.createCheckpoint(-25, 0, 0, 0x00ff00, 'ì²´í¬í¬ì¸íŠ¸ 1');
                this.createCheckpoint(0, 0, 0, 0x00ff00, 'ì²´í¬í¬ì¸íŠ¸ 2');
                this.createCheckpoint(25, 0, 0, 0x00ff00, 'ì²´í¬í¬ì¸íŠ¸ 3');
                this.createCheckpoint(45, 0, 0, 0x00ff00, 'ì²´í¬í¬ì¸íŠ¸ 4');
                
                console.log(`âœ… ${this.checkpoints.length}ê°œì˜ ì²´í¬í¬ì¸íŠ¸ ìƒì„± ì™„ë£Œ`);
            }
            
            // ê°œë³„ ì²´í¬í¬ì¸íŠ¸ ìƒì„±
            createCheckpoint(x, y, z, color, name) {
                // ì‹œê°ì  ì²´í¬í¬ì¸íŠ¸ ìƒì„±
                const checkpointGeometry = new THREE.PlaneGeometry(20, 3);
                const checkpointMaterial = new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial);
                checkpoint.position.set(x, y + 1.5, z);
                checkpoint.rotation.y = Math.PI / 2; // íŠ¸ë™ì„ ê°€ë¡œì§€ë¥´ë„ë¡ íšŒì „
                this.scene.add(checkpoint);
                
                // ì²´í¬í¬ì¸íŠ¸ ë°ì´í„° ì €ì¥
                this.checkpoints.push({
                    position: { x, y, z },
                    mesh: checkpoint,
                    name: name,
                    width: 20,
                    height: 3
                });
            }         
   
            // ê²Œì„ í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ ì‹œìŠ¤í…œ (ì‘ì—… 17)
            initializeTestSystem() {
                this.testResults = {
                    sensorConnection: false,
                    physicsEngine: false,
                    gameFlow: false,
                    rendering: false,
                    crossBrowser: false
                };
                
                this.testLog = [];
                this.performanceMetrics = {
                    frameRate: 0,
                    memoryUsage: 0,
                    physicsSteps: 0,
                    renderTime: 0
                };
                
                // í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œì€ ìˆ˜ë™ìœ¼ë¡œë§Œ ì‹¤í–‰ (F1 í‚¤ë¡œ ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™” ì‹œ)
                // ê¸°ë³¸ì ìœ¼ë¡œëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
                console.log('ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ (F1 í‚¤ë¡œ ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™” ê°€ëŠ¥)');
            }
            
            // ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ì„¼ì„œ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ ì œì™¸)
            startBasicTests() {
                console.log('ğŸ§ª ê¸°ë³¸ ê²Œì„ í…ŒìŠ¤íŠ¸ ì‹œì‘...');
                
                // 1. ë Œë”ë§ ì—”ì§„ í…ŒìŠ¤íŠ¸
                this.testRenderingEngine();
                
                // 2. ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸
                this.testPhysicsEngine();
                
                // 3. ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ (ê°€ìƒ ë°ì´í„°ë§Œ)
                setTimeout(() => this.testSensorDataProcessing(), 2000);
                
                // 4. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
                this.startPerformanceMonitoring();
                
                // 5. í¬ë¡œìŠ¤ ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬
                this.checkBrowserCompatibility();
            }
            
            // ìë™ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ë””ë²„ê·¸ ëª¨ë“œìš© - ì„¼ì„œ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ í¬í•¨)
            startAutomaticTests() {
                console.log('ğŸ§ª ì „ì²´ ê²Œì„ í…ŒìŠ¤íŠ¸ ì‹œì‘ (ë””ë²„ê·¸ ëª¨ë“œ)...');
                
                // 1. ë Œë”ë§ ì—”ì§„ í…ŒìŠ¤íŠ¸
                this.testRenderingEngine();
                
                // 2. ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸
                this.testPhysicsEngine();
                
                // 3. ì„¼ì„œ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸
                setTimeout(() => this.testSensorConnection(), 2000);
                
                // 4. ê²Œì„ í”Œë¡œìš° í…ŒìŠ¤íŠ¸
                setTimeout(() => this.testGameFlow(), 4000);
                
                // 5. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
                this.startPerformanceMonitoring();
                
                // 6. í¬ë¡œìŠ¤ ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬
                this.checkBrowserCompatibility();
            }
            
            // ë Œë”ë§ ì—”ì§„ í…ŒìŠ¤íŠ¸ (ì‘ì—… 17)
            testRenderingEngine() {
                try {
                    // WebGL ì§€ì› í™•ì¸
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        throw new Error('WebGLì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
                    }
                    
                    // Three.js ë Œë”ëŸ¬ í…ŒìŠ¤íŠ¸
                    if (!this.renderer || !this.scene || !this.cameras) {
                        throw new Error('3D ë Œë”ë§ ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨');
                    }
                    
                    // ë Œë”ë§ í…ŒìŠ¤íŠ¸
                    this.renderer.render(this.scene, this.cameras.player1);
                    
                    this.testResults.rendering = true;
                    this.logTest('âœ… ë Œë”ë§ ì—”ì§„ í…ŒìŠ¤íŠ¸ í†µê³¼');
                    
                } catch (error) {
                    this.testResults.rendering = false;
                    this.logTest('âŒ ë Œë”ë§ ì—”ì§„ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ' + error.message);
                    console.error('ë Œë”ë§ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            // ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸ (ì‘ì—… 17)
            testPhysicsEngine() {
                try {
                    // Cannon.js ë¬¼ë¦¬ ì—”ì§„ í™•ì¸
                    if (!this.world || !CANNON) {
                        throw new Error('ë¬¼ë¦¬ ì—”ì§„ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                    }
                    
                    // í…ŒìŠ¤íŠ¸ ë¬¼ì²´ ìƒì„±
                    const testShape = new CANNON.Sphere(1);
                    const testBody = new CANNON.Body({ mass: 1 });
                    testBody.addShape(testShape);
                    testBody.position.set(0, 10, 0);
                    
                    this.world.add(testBody);
                    
                    // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸
                    this.world.step(1/60);
                    
                    // ì¤‘ë ¥ ì‘ìš© í™•ì¸
                    if (testBody.position.y < 10) {
                        this.testResults.physicsEngine = true;
                        this.logTest('âœ… ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸ í†µê³¼');
                    } else {
                        throw new Error('ì¤‘ë ¥ ì‹œë®¬ë ˆì´ì…˜ì´ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
                    }
                    
                    // í…ŒìŠ¤íŠ¸ ë¬¼ì²´ ì œê±°
                    this.world.remove(testBody);
                    
                } catch (error) {
                    this.testResults.physicsEngine = false;
                    this.logTest('âŒ ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ' + error.message);
                    console.error('ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            // ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ (ê°€ìƒ ë°ì´í„°ë§Œ, ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ ì—†ìŒ)
            testSensorDataProcessing() {
                try {
                    // SessionSDK í™•ì¸
                    if (!this.sdk) {
                        throw new Error('SessionSDKê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                    }
                    
                    // ê°€ìƒ ì„¼ì„œ ë°ì´í„° ìƒì„± (ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ ì—†ì´)
                    const mockOrientation = {
                        alpha: 0,
                        beta: -20, // ì•ìœ¼ë¡œ ê¸°ìš¸ê¸° (ê°€ì†)
                        gamma: 15  // ìš°ì¸¡ ê¸°ìš¸ê¸° (ìš°íšŒì „)
                    };
                    
                    const mockAcceleration = {
                        x: 0,
                        y: 0,
                        z: 2
                    };
                    
                    // ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸
                    const processedData = this.processSensorData(mockOrientation, mockAcceleration);
                    
                    if (processedData && processedData.steering !== undefined && processedData.speed !== undefined) {
                        this.testResults.sensorConnection = true;
                        this.logTest('âœ… ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ í†µê³¼');
                        this.logTest(`   - ì¡°í–¥: ${processedData.steering.toFixed(2)}, ì†ë„: ${processedData.speed.toFixed(2)}`);
                    } else {
                        throw new Error('ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ê²°ê³¼ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
                    }
                    
                } catch (error) {
                    this.testResults.sensorConnection = false;
                    this.logTest('âŒ ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ' + error.message);
                    console.error('ì„¼ì„œ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            // ì„¼ì„œ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸ (ë””ë²„ê·¸ ëª¨ë“œ ì „ìš©)
            testSensorConnection() {
                try {
                    // SessionSDK í™•ì¸
                    if (!this.sdk) {
                        throw new Error('SessionSDKê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                    }
                    
                    // ê°€ìƒ ì„¼ì„œ ë°ì´í„° ìƒì„±
                    const mockSensorData = {
                        sensorId: 'test-sensor',
                        data: {
                            orientation: {
                                alpha: 0,
                                beta: -20, // ì•ìœ¼ë¡œ ê¸°ìš¸ê¸° (ê°€ì†)
                                gamma: 15  // ìš°ì¸¡ ê¸°ìš¸ê¸° (ìš°íšŒì „)
                            },
                            acceleration: {
                                x: 0,
                                y: 0,
                                z: 2
                            }
                        }
                    };
                    
                    // ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸
                    const processedData = this.processSensorData(mockSensorData.data.orientation, mockSensorData.data.acceleration);
                    
                    if (processedData && processedData.steering !== undefined && processedData.speed !== undefined) {
                        this.testResults.sensorConnection = true;
                        this.logTest('âœ… ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ í†µê³¼');
                        this.logTest(`   - ì¡°í–¥: ${processedData.steering.toFixed(2)}, ì†ë„: ${processedData.speed.toFixed(2)}`);
                    } else {
                        throw new Error('ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ê²°ê³¼ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
                    }
                    
                } catch (error) {
                    this.testResults.sensorConnection = false;
                    this.logTest('âŒ ì„¼ì„œ ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ' + error.message);
                    console.error('ì„¼ì„œ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            // ê²Œì„ í”Œë¡œìš° í…ŒìŠ¤íŠ¸ (ë””ë²„ê·¸ ëª¨ë“œ ì „ìš©)
            testGameFlow() {
                try {
                    // ê²Œì„ ìƒíƒœ ì „í™˜ í…ŒìŠ¤íŠ¸
                    const initialState = this.gameState;
                    
                    // ê°€ìƒ ì„¼ì„œ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œ ì„¼ì„œ ID ì‚¬ìš©)
                    this.handleSensorConnected('sensor1');
                    this.handleSensorConnected('sensor2');
                    
                    // ê²Œì„ ì‹œì‘ í…ŒìŠ¤íŠ¸
                    if (this.connectedSensors.size >= 2) {
                        this.startCountdown(); // ì˜¬ë°”ë¥¸ ë©”ì„œë“œëª… ì‚¬ìš©
                        
                        // ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ê²Œì„ ìƒíƒœ í™•ì¸
                        setTimeout(() => {
                            if (this.gameState === 'racing' || this.gameState === 'preparing') {
                                this.testResults.gameFlow = true;
                                this.logTest('âœ… ê²Œì„ í”Œë¡œìš° í…ŒìŠ¤íŠ¸ í†µê³¼');
                            } else {
                                throw new Error('ê²Œì„ ìƒíƒœ ì „í™˜ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
                            }
                        }, 1000);
                    } else {
                        throw new Error('ì„¼ì„œ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ ì‹¤íŒ¨');
                    }
                    
                } catch (error) {
                    this.testResults.gameFlow = false;
                    this.logTest('âŒ ê²Œì„ í”Œë¡œìš° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ' + error.message);
                    console.error('ê²Œì„ í”Œë¡œìš° í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            // í¬ë¡œìŠ¤ ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬ (ì‘ì—… 17)
            checkBrowserCompatibility() {
                try {
                    const compatibility = {
                        webgl: !!window.WebGLRenderingContext,
                        deviceOrientation: 'DeviceOrientationEvent' in window,
                        requestAnimationFrame: !!window.requestAnimationFrame,
                        localStorage: !!window.localStorage,
                        websocket: !!window.WebSocket,
                        canvas: !!document.createElement('canvas').getContext
                    };
                    
                    const unsupported = Object.entries(compatibility)
                        .filter(([key, value]) => !value)
                        .map(([key]) => key);
                    
                    if (unsupported.length === 0) {
                        this.testResults.crossBrowser = true;
                        this.logTest('âœ… ë¸Œë¼ìš°ì € í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸ í†µê³¼');
                    } else {
                        this.testResults.crossBrowser = false;
                        this.logTest('âš ï¸ ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ê²½ê³ : ' + unsupported.join(', ') + ' ë¯¸ì§€ì›');
                    }
                    
                    // ë¸Œë¼ìš°ì € ì •ë³´ ë¡œê¹…
                    this.logTest(`ğŸ“± ë¸Œë¼ìš°ì €: ${navigator.userAgent.split(' ').pop()}`);
                    this.logTest(`ğŸ–¥ï¸ í™”ë©´: ${window.innerWidth}x${window.innerHeight}`);
                    this.logTest(`ğŸ“Š í”½ì…€ ë¹„ìœ¨: ${window.devicePixelRatio}`);
                    
                } catch (error) {
                    this.testResults.crossBrowser = false;
                    this.logTest('âŒ ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬ ì‹¤íŒ¨: ' + error.message);
                    console.error('ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬ ì˜¤ë¥˜:', error);
                }
            }
            
            // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ (ì‘ì—… 17)
            startPerformanceMonitoring() {
                let frameCount = 0;
                let lastTime = performance.now();
                
                const monitorPerformance = () => {
                    const currentTime = performance.now();
                    frameCount++;
                    
                    // 1ì´ˆë§ˆë‹¤ ì„±ëŠ¥ ì¸¡ì •
                    if (currentTime - lastTime >= 1000) {
                        this.performanceMetrics.frameRate = Math.round(frameCount * 1000 / (currentTime - lastTime));
                        
                        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (Chromeì—ì„œë§Œ ì§€ì›)
                        if (performance.memory) {
                            this.performanceMetrics.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1048576); // MB
                        }
                        
                        // ì„±ëŠ¥ ê²½ê³  ì²´í¬
                        if (this.performanceMetrics.frameRate < 30) {
                            this.logTest(`âš ï¸ ë‚®ì€ í”„ë ˆì„ ë ˆì´íŠ¸: ${this.performanceMetrics.frameRate} FPS`);
                        }
                        
                        if (this.performanceMetrics.memoryUsage > 100) {
                            this.logTest(`âš ï¸ ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ${this.performanceMetrics.memoryUsage} MB`);
                        }
                        
                        frameCount = 0;
                        lastTime = currentTime;
                    }
                    
                    requestAnimationFrame(monitorPerformance);
                };
                
                requestAnimationFrame(monitorPerformance);
                this.logTest('ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘');
            }
            
            // í…ŒìŠ¤íŠ¸ ë¡œê·¸ ê¸°ë¡ (ì‘ì—… 17)
            logTest(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.testLog.push(logEntry);
                console.log(logEntry);
                
                // í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ í™”ë©´ì— í‘œì‹œ (ë””ë²„ê·¸ ëª¨ë“œì¼ ë•Œ)
                if (this.debugMode) {
                    this.displayTestResults();
                }
            }
            
            // í…ŒìŠ¤íŠ¸ ê²°ê³¼ í‘œì‹œ (ì‘ì—… 17)
            displayTestResults() {
                // ê¸°ì¡´ í…ŒìŠ¤íŠ¸ ê²°ê³¼ íŒ¨ë„ ì œê±°
                const existingPanel = document.getElementById('testResultsPanel');
                if (existingPanel) {
                    existingPanel.remove();
                }
                
                // í…ŒìŠ¤íŠ¸ ê²°ê³¼ íŒ¨ë„ ìƒì„±
                const panel = document.createElement('div');
                panel.id = 'testResultsPanel';
                panel.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    width: 350px;
                    max-height: 400px;
                    background: rgba(30, 41, 59, 0.95);
                    border: 1px solid var(--border);
                    border-radius: 0.75rem;
                    padding: 1rem;
                    backdrop-filter: blur(12px);
                    z-index: 1000;
                    font-family: 'Courier New', monospace;
                    font-size: 0.8rem;
                    overflow-y: auto;
                    color: var(--text-primary);
                `;
                
                // í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½
                const summary = Object.entries(this.testResults)
                    .map(([test, passed]) => `${passed ? 'âœ…' : 'âŒ'} ${test}`)
                    .join('<br>');
                
                // ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤
                const metrics = `
                    ğŸ“Š FPS: ${this.performanceMetrics.frameRate}<br>
                    ğŸ’¾ ë©”ëª¨ë¦¬: ${this.performanceMetrics.memoryUsage} MB
                `;
                
                // ìµœê·¼ ë¡œê·¸ (ìµœëŒ€ 10ê°œ)
                const recentLogs = this.testLog.slice(-10).join('<br>');
                
                panel.innerHTML = `
                    <h3 style="margin-bottom: 0.5rem; color: var(--primary);">ğŸ§ª í…ŒìŠ¤íŠ¸ ê²°ê³¼</h3>
                    <div style="margin-bottom: 0.5rem;">${summary}</div>
                    <div style="margin-bottom: 0.5rem; border-top: 1px solid var(--border); padding-top: 0.5rem;">${metrics}</div>
                    <div style="border-top: 1px solid var(--border); padding-top: 0.5rem; font-size: 0.7rem;">${recentLogs}</div>
                `;
                
                document.body.appendChild(panel);
            }
            
            // ì—ëŸ¬ ì²˜ë¦¬ ê°œì„  (ì‘ì—… 17)
            handleGameError(error, context = '') {
                const errorMessage = `ê²Œì„ ì˜¤ë¥˜ ${context}: ${error.message}`;
                console.error(errorMessage, error);
                this.logTest(`âŒ ${errorMessage}`);
                
                // ì‚¬ìš©ìì—ê²Œ ì—ëŸ¬ ì•Œë¦¼
                this.showErrorNotification(errorMessage);
                
                // ê²Œì„ ìƒíƒœë¥¼ ì•ˆì „í•œ ìƒíƒœë¡œ ë³µêµ¬
                this.recoverFromError();
            }
            
            // ì—ëŸ¬ ì•Œë¦¼ í‘œì‹œ (ì‘ì—… 17)
            showErrorNotification(message) {
                // ê¸°ì¡´ ì—ëŸ¬ ì•Œë¦¼ ì œê±°
                const existingError = document.getElementById('errorNotification');
                if (existingError) {
                    existingError.remove();
                }
                
                // ì—ëŸ¬ ì•Œë¦¼ ìƒì„±
                const notification = document.createElement('div');
                notification.id = 'errorNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(239, 68, 68, 0.95);
                    color: white;
                    padding: 1rem 2rem;
                    border-radius: 0.5rem;
                    z-index: 2000;
                    font-weight: 600;
                    text-align: center;
                    max-width: 400px;
                    border: 2px solid var(--error);
                `;
                
                notification.innerHTML = `
                    <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">âš ï¸ ì˜¤ë¥˜ ë°œìƒ</div>
                    <div style="margin-bottom: 1rem;">${message}</div>
                    <button onclick="this.parentElement.remove()" style="
                        background: white;
                        color: var(--error);
                        border: none;
                        padding: 0.5rem 1rem;
                        border-radius: 0.25rem;
                        cursor: pointer;
                        font-weight: 600;
                    ">í™•ì¸</button>
                `;
                
                document.body.appendChild(notification);
                
                // 5ì´ˆ í›„ ìë™ ì œê±°
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 5000);
            }
            
            // ì—ëŸ¬ ë³µêµ¬ (ì‘ì—… 17)
            recoverFromError() {
                try {
                    // ê²Œì„ì„ ëŒ€ê¸° ìƒíƒœë¡œ ë³µêµ¬
                    this.gameState = 'waiting';
                    
                    // íƒ€ì´ë¨¸ ì •ë¦¬
                    this.clearAllTimers();
                    
                    // UI ìƒíƒœ ë³µêµ¬
                    this.elements.sessionPanel.classList.remove('hidden');
                    this.elements.gameHUD.classList.add('hidden');
                    this.elements.controlPanel.classList.add('hidden');
                    
                    // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
                    this.updateConnectionUI();
                    
                    this.logTest('ğŸ”„ ì—ëŸ¬ ë³µêµ¬ ì™„ë£Œ - ëŒ€ê¸° ìƒíƒœë¡œ ë³µêµ¬');
                    
                } catch (recoveryError) {
                    console.error('ì—ëŸ¬ ë³µêµ¬ ì‹¤íŒ¨:', recoveryError);
                    this.logTest('âŒ ì—ëŸ¬ ë³µêµ¬ ì‹¤íŒ¨');
                }
            }          
  
            // í”Œë ˆì´ì–´ë³„ ë© ì¶”ì  ë°ì´í„° ì´ˆê¸°í™” (ì‘ì—… 10)
            initializeLapTracking() {
                this.lapTracking = {
                    sensor1: {
                        currentLap: 0,
                        lastCheckpoint: -1,
                        lapStartTime: null,
                        lapTimes: [],
                        bestLapTime: Infinity,
                        rank: 1
                    },
                    sensor2: {
                        currentLap: 0,
                        lastCheckpoint: -1,
                        lapStartTime: null,
                        lapTimes: [],
                        bestLapTime: Infinity,
                        rank: 2
                    }
                };
                
                // ê²½ì£¼ ì™„ë£Œ ìƒíƒœ ì´ˆê¸°í™”
                this.raceFinished = false;
                
                console.log('âœ… ë© ì¶”ì  ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
            }
        
            setupEventListeners() {
                // SessionSDK ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                this.sdk.on('connected', (event) => {
                    const data = event.detail || event;
                    console.log('âœ… ì„œë²„ ì—°ê²° ì™„ë£Œ, ì„¸ì…˜ ìƒì„± ì¤‘...');
                    this.connectionStatus.server = true;
                    this.updateConnectionUI();
                    
                    this.createSession();
                });
                
                this.sdk.on('disconnected', (event) => {
                    const data = event.detail || event;
                    console.log('âŒ ì„œë²„ ì—°ê²° ëŠê¹€');
                    this.connectionStatus.server = false;
                    this.updateConnectionUI();
                });
                
                this.sdk.on('session-created', (event) => {
                    const data = event.detail || event;
                    console.log('âœ… ì„¸ì…˜ ìƒì„± ì™„ë£Œ:', data.sessionCode);
                    this.sessionCode = data.sessionCode;
                    this.elements.sessionCode.textContent = data.sessionCode;
                    this.generateQRCode(data.sessionCode);
                });
                
                this.sdk.on('sensor-connected', (event) => {
                    const data = event.detail || event;
                    this.handleSensorConnected(data.sensorId);
                });
                
                this.sdk.on('sensor-disconnected', (event) => {
                    const data = event.detail || event;
                    this.handleSensorDisconnected(data.sensorId);
                });
                
                this.sdk.on('sensor-data', (event) => {
                    const data = event.detail || event;
                    this.handleSensorData(data);
                });
                
                // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ì´ë²¤íŠ¸ (ê°œë°œìš©)
                document.addEventListener('keydown', (event) => {
                    this.handleKeyboardInput(event);
                });
                
                // ì°½ í¬ê¸° ë³€ê²½ ì´ë²¤íŠ¸
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }  
          
            // ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ë° ìë™ì°¨ ì¡°ì‘ (ì‘ì—… 8ì˜ í•µì‹¬ ê¸°ëŠ¥)
            handleSensorData(sensorData) {
                const { sensorId, data } = sensorData;
                
                if (!data || !data.orientation) {
                    console.warn('ì„¼ì„œ ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤:', sensorData);
                    return;
                }
                
                // ì„¼ì„œ ë°ì´í„° íŒŒì‹±
                const { orientation, acceleration } = data;
                const { alpha, beta, gamma } = orientation;
                
                // ê¸°ìš¸ê¸° ë°ì´í„°ë¥¼ ìë™ì°¨ ì¡°ì‘ìœ¼ë¡œ ë³€í™˜
                const processedData = this.processSensorData(orientation, acceleration);
                
                // í”Œë ˆì´ì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
                if (this.players[sensorId]) {
                    this.players[sensorId].sensorData = {
                        tiltX: gamma,  // ì¢Œìš° ê¸°ìš¸ê¸°
                        tiltY: beta,   // ì•ë’¤ ê¸°ìš¸ê¸°
                        acceleration: acceleration ? acceleration.z : 0
                    };
                    
                    // ì¡°ì‘ ë°ì´í„° ì ìš©
                    this.players[sensorId].steering = processedData.steering;
                    this.players[sensorId].speed = processedData.speed;
                    
                    // ì‹¤ì‹œê°„ ìë™ì°¨ ì›€ì§ì„ ë°˜ì˜
                    this.applySensorToCarMovement(sensorId, processedData);
                    
                    // HUD ì—…ë°ì´íŠ¸
                    this.updateHUD();
                }
            }
            
            // ì„¼ì„œ ë°ì´í„°ë¥¼ ìë™ì°¨ ì¡°ì‘ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•µì‹¬ ë¡œì§ (ì‘ì—… 17 ê°œì„ )
            processSensorData(orientation, acceleration) {
                try {
                    // ì…ë ¥ ë°ì´í„° ê²€ì¦
                    if (!orientation || typeof orientation !== 'object') {
                        console.warn('ìœ íš¨í•˜ì§€ ì•Šì€ orientation ë°ì´í„°:', orientation);
                        return { steering: 0, speed: 0, rawData: null };
                    }
                    
                    const { alpha = 0, beta = 0, gamma = 0 } = orientation;
                    
                    // NaN ê°’ ì²´í¬ ë° ê¸°ë³¸ê°’ ì„¤ì •
                    const safeGamma = isNaN(gamma) ? 0 : gamma;
                    const safeBeta = isNaN(beta) ? 0 : beta;
                    const safeAlpha = isNaN(alpha) ? 0 : alpha;
                    
                    // ì¢Œìš° ê¸°ìš¸ê¸° â†’ í•¸ë“¤ ì¡°ì‘ ë§¤í•‘ (-90Â° ~ +90Â°)
                    let steering = 0;
                    if (Math.abs(safeGamma) > 5) { // ë°ë“œì¡´ ì„¤ì • (5ë„)
                        steering = Math.max(-1, Math.min(1, safeGamma / 45)); // -45Â° ~ +45Â° ë²”ìœ„ë¡œ ì •ê·œí™”
                    }
                    
                    // ì•ë’¤ ê¸°ìš¸ê¸° â†’ ê°€ì†/ë¸Œë ˆì´í¬ ë§¤í•‘ (-180Â° ~ +180Â°)
                    let speed = 0;
                    if (safeBeta < -15) {
                        // ì•ìœ¼ë¡œ ê¸°ìš¸ê¸° â†’ ê°€ì† (15ë„ ì´ìƒ)
                        speed = Math.min(1, Math.abs(safeBeta + 15) / 30); // ìµœëŒ€ 45ë„ê¹Œì§€
                    } else if (safeBeta > 15) {
                        // ë’¤ë¡œ ê¸°ìš¸ê¸° â†’ ë¸Œë ˆì´í¬/í›„ì§„ (15ë„ ì´ìƒ)
                        speed = -Math.min(0.5, (safeBeta - 15) / 30); // ë¸Œë ˆì´í¬ëŠ” ì ˆë°˜ ê°•ë„
                    }
                    
                    // ê°€ì†ë„ ë°ì´í„° í™œìš© (ì„ íƒì )
                    if (acceleration && typeof acceleration === 'object' && !isNaN(acceleration.z)) {
                        const accelBoost = Math.max(0, acceleration.z / 10); // ê°€ì†ë„ ë³´ì •
                        speed += accelBoost * 0.2; // 20% ë³´ì •
                    }
                    
                    // ì„¼ì„œ ê°ë„ ì¡°ì • ë° ë°ì´í„° í•„í„°ë§
                    steering = this.applySensorFiltering(steering, 'steering');
                    speed = this.applySensorFiltering(speed, 'speed');
                    
                    // ìµœì¢… ê°’ ë²”ìœ„ ì œí•œ
                    steering = Math.max(-1, Math.min(1, steering));
                    speed = Math.max(-1, Math.min(1, speed));
                    
                    return {
                        steering: steering,
                        speed: speed,
                        rawData: { alpha: safeAlpha, beta: safeBeta, gamma: safeGamma }
                    };
                    
                } catch (error) {
                    console.error('ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                    this.handleGameError(error, 'ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬');
                    return { steering: 0, speed: 0, rawData: null };
                }
            }
            
            // ì„¼ì„œ ë°ì´í„° í•„í„°ë§ (ë…¸ì´ì¦ˆ ì œê±° ë° ë¶€ë“œëŸ¬ìš´ ì „í™˜)
            applySensorFiltering(value, type) {
                // ì´ì „ ê°’ì´ ì—†ìœ¼ë©´ í˜„ì¬ ê°’ ì‚¬ìš©
                if (!this.previousSensorValues) {
                    this.previousSensorValues = { steering: 0, speed: 0 };
                }
                
                const previousValue = this.previousSensorValues[type] || 0;
                
                // ë¡œìš°íŒ¨ìŠ¤ í•„í„° ì ìš© (ë¶€ë“œëŸ¬ìš´ ì „í™˜)
                const smoothingFactor = 0.7; // 0.7 = 70% ì´ì „ê°’, 30% ìƒˆê°’
                const filteredValue = previousValue * smoothingFactor + value * (1 - smoothingFactor);
                
                // ë°ë“œì¡´ ì ìš©
                const deadzone = type === 'steering' ? 0.05 : 0.1;
                const finalValue = Math.abs(filteredValue) < deadzone ? 0 : filteredValue;
                
                // ì´ì „ ê°’ ì €ì¥
                this.previousSensorValues[type] = finalValue;
                
                return finalValue;
            }
            
            // ì‹¤ì‹œê°„ìœ¼ë¡œ ìë™ì°¨ ì›€ì§ì„ì— ë°˜ì˜ (ì‘ì—… 17 ì•ˆì „ì„± ê°œì„ )
            applySensorToCarMovement(sensorId, processedData) {
                try {
                    if (this.gameState !== 'racing' || !this.cars) return;
                    
                    const carKey = sensorId === 'sensor1' ? 'player1' : 'player2';
                    const car = this.cars[carKey];
                    
                    if (car && typeof car.applySensorInput === 'function') {
                        // Car í´ë˜ìŠ¤ì˜ applySensorInput ë©”ì„œë“œ í˜¸ì¶œ
                        car.applySensorInput(processedData.speed, processedData.steering);
                    }
                } catch (error) {
                    console.error('ìë™ì°¨ ì›€ì§ì„ ì ìš© ì˜¤ë¥˜:', error);
                    this.handleGameError(error, 'ìë™ì°¨ ì œì–´');
                }
            }        
    
            // ì„¼ì„œ ì—°ê²° ì²˜ë¦¬ (ì‘ì—… 14 ê°œì„ )
            handleSensorConnected(sensorId) {
                this.connectedSensors.add(sensorId);
                this.connectionStatus[sensorId] = true;
                
                // í”Œë ˆì´ì–´ ê°ì²´ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ì—ë§Œ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
                if (this.players[sensorId]) {
                    this.players[sensorId].connected = true;
                }
                
                console.log(`âœ… ${sensorId} ì„¼ì„œ ì—°ê²°ë¨`);
                this.updateConnectionUI();
                
                // ì¬ì—°ê²° ëŒ€ê¸° ë©”ì‹œì§€ ìˆ¨ê¹€
                this.hideReconnectionMessage();
                
                // ê²Œì„ ìƒíƒœì— ë”°ë¥¸ ì²˜ë¦¬
                if (this.gameState === 'paused' && this.connectedSensors.size >= 2) {
                    // ì¼ì‹œì •ì§€ ìƒíƒœì—ì„œ ëª¨ë“  ì„¼ì„œê°€ ì¬ì—°ê²°ë˜ë©´ ê²Œì„ ì¬ê°œ
                    this.resumeGameAfterReconnection();
                } else if (this.gameState === 'waiting' && this.connectedSensors.size >= 2) {
                    // ëŒ€ê¸° ìƒíƒœì—ì„œ ë‘ ì„¼ì„œ ëª¨ë‘ ì—°ê²°ë˜ë©´ ê²Œì„ ì‹œì‘ ì¤€ë¹„
                    this.startGamePreparation();
                }
                
                // ì¬ì—°ê²° ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
                this.showReconnectionSuccess(sensorId);
            }
            
            // ì¬ì—°ê²° í›„ ê²Œì„ ì¬ê°œ (ì‘ì—… 14)
            resumeGameAfterReconnection() {
                console.log('ğŸ”„ ì„¼ì„œ ì¬ì—°ê²° ì™„ë£Œ, ê²Œì„ ì¬ê°œ');
                
                // ì¼ì‹œì •ì§€ ë²„íŠ¼ ìƒíƒœ ë³µì›
                const pauseResumeBtn = document.getElementById('pauseResumeBtn');
                if (pauseResumeBtn) {
                    pauseResumeBtn.innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';
                    pauseResumeBtn.disabled = false;
                }
                
                // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ê²Œì„ ì¬ê°œ
                this.startReconnectionCountdown();
            }
            
            // ì¬ì—°ê²° ì¹´ìš´íŠ¸ë‹¤ìš´ (ì‘ì—… 14)
            startReconnectionCountdown() {
                let countdown = 3;
                
                const countdownElement = document.createElement('div');
                countdownElement.className = 'countdown';
                countdownElement.id = 'reconnectionCountdown';
                countdownElement.style.color = 'var(--success)';
                document.body.appendChild(countdownElement);
                
                const showCountdown = (number) => {
                    if (number > 0) {
                        countdownElement.textContent = number;
                    } else {
                        countdownElement.textContent = 'ì¬ê°œ!';
                    }
                    countdownElement.style.animation = 'none';
                    countdownElement.offsetHeight; // ê°•ì œ ë¦¬í”Œë¡œìš°
                    countdownElement.style.animation = 'countdownPulse 1s ease-in-out';
                };
                
                showCountdown(countdown);
                
                const countdownInterval = setInterval(() => {
                    countdown--;
                    if (countdown >= 0) {
                        showCountdown(countdown);
                    } else {
                        clearInterval(countdownInterval);
                        countdownElement.remove();
                        this.resumeGame();
                    }
                }, 1000);
            }
            
            // ì¬ì—°ê²° ì„±ê³µ ë©”ì‹œì§€ (ì‘ì—… 14)
            showReconnectionSuccess(sensorId) {
                const playerName = sensorId === 'sensor1' ? 'í”Œë ˆì´ì–´ 1' : 'í”Œë ˆì´ì–´ 2';
                
                // ì„±ê³µ ë©”ì‹œì§€ íŒ¨ë„ ìƒì„±
                const successPanel = document.createElement('div');
                successPanel.className = 'ui-panel';
                successPanel.style.cssText = `
                    top: 20%;
                    left: 50%;
                    transform: translateX(-50%);
                    text-align: center;
                    min-width: 300px;
                    z-index: 200;
                    background: rgba(16, 185, 129, 0.95);
                    border: 2px solid var(--success);
                `;
                
                successPanel.innerHTML = `
                    <div style="color: white;">
                        <h4 style="margin-bottom: 0.5rem;">âœ… ì¬ì—°ê²° ì„±ê³µ!</h4>
                        <div>${playerName} ì„¼ì„œê°€ ë‹¤ì‹œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤</div>
                    </div>
                `;
                
                document.body.appendChild(successPanel);
                
                // 2ì´ˆ í›„ ìë™ ì œê±°
                setTimeout(() => {
                    successPanel.remove();
                }, 2000);
            }
            
            // ì„¼ì„œ ì—°ê²° í•´ì œ ì²˜ë¦¬ (ì‘ì—… 14 ê°œì„ )
            handleSensorDisconnected(sensorId) {
                this.connectedSensors.delete(sensorId);
                this.connectionStatus[sensorId] = false;
                this.players[sensorId].connected = false;
                
                console.log(`âŒ ${sensorId} ì„¼ì„œ ì—°ê²° í•´ì œë¨`);
                this.updateConnectionUI();
                
                // ê²Œì„ ì¤‘ì´ë©´ ì¼ì‹œì •ì§€ ë° ì¬ì—°ê²° ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
                if (this.gameState === 'racing') {
                    this.pauseGameForReconnection(sensorId);
                } else if (this.gameState === 'preparing') {
                    // ì¤€ë¹„ ì¤‘ì´ë©´ ëŒ€ê¸° ìƒíƒœë¡œ ë³€ê²½
                    this.gameState = 'waiting';
                    this.updateGameStatus();
                }
                
                // ì¬ì—°ê²° ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
                this.showReconnectionMessage(sensorId);
            }
            
            // ì¬ì—°ê²°ì„ ìœ„í•œ ê²Œì„ ì¼ì‹œì •ì§€ (ì‘ì—… 14)
            pauseGameForReconnection(sensorId) {
                if (this.gameState === 'racing') {
                    this.pauseGame();
                    
                    // ì¼ì‹œì •ì§€ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                    const pauseResumeBtn = document.getElementById('pauseResumeBtn');
                    if (pauseResumeBtn) {
                        pauseResumeBtn.innerHTML = 'ğŸ“¡ ì¬ì—°ê²° ëŒ€ê¸°';
                        pauseResumeBtn.disabled = true;
                    }
                    
                    console.log(`â¸ï¸ ${sensorId} ì„¼ì„œ ì—°ê²° ëŠê¹€ìœ¼ë¡œ ê²Œì„ ì¼ì‹œì •ì§€`);
                }
            }
            
            // ì¬ì—°ê²° ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ (ì‘ì—… 14)
            showReconnectionMessage(sensorId) {
                // ê¸°ì¡´ ì¬ì—°ê²° ë©”ì‹œì§€ ì œê±°
                this.hideReconnectionMessage();
                
                const reconnectionPanel = document.createElement('div');
                reconnectionPanel.className = 'ui-panel';
                reconnectionPanel.id = 'reconnectionPanel';
                reconnectionPanel.style.cssText = `
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                    min-width: 400px;
                    z-index: 250;
                    background: rgba(239, 68, 68, 0.95);
                    border: 2px solid var(--error);
                `;
                
                const playerName = sensorId === 'sensor1' ? 'í”Œë ˆì´ì–´ 1' : 'í”Œë ˆì´ì–´ 2';
                
                reconnectionPanel.innerHTML = `
                    <div style="color: white;">
                        <h3 style="margin-bottom: 1rem;">ğŸ“¡ ì„¼ì„œ ì—°ê²° ëŠê¹€</h3>
                        <div style="font-size: 1.2rem; margin-bottom: 1rem;">
                            <strong>${playerName}</strong>ì˜ ì„¼ì„œ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤
                        </div>
                        <div style="margin-bottom: 1.5rem; opacity: 0.9;">
                            ëª¨ë°”ì¼ ê¸°ê¸°ë¥¼ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì—°ê²°í•´ì£¼ì„¸ìš”
                        </div>
                        <div class="reconnection-spinner" style="margin: 1rem auto; width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div style="font-size: 0.9rem; opacity: 0.8;">
                            ì¬ì—°ê²°ë˜ë©´ ìë™ìœ¼ë¡œ ê²Œì„ì´ ì¬ê°œë©ë‹ˆë‹¤
                        </div>
                    </div>
                `;
                
                document.body.appendChild(reconnectionPanel);
                
                // ìŠ¤í”¼ë„ˆ ì• ë‹ˆë©”ì´ì…˜ CSS ì¶”ê°€
                if (!document.getElementById('reconnectionSpinnerStyle')) {
                    const style = document.createElement('style');
                    style.id = 'reconnectionSpinnerStyle';
                    style.textContent = `
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                console.log(`ğŸ“¡ ${sensorId} ì¬ì—°ê²° ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ`);
            }
            
            // ì¬ì—°ê²° ëŒ€ê¸° ë©”ì‹œì§€ ìˆ¨ê¹€ (ì‘ì—… 14)
            hideReconnectionMessage() {
                const reconnectionPanel = document.getElementById('reconnectionPanel');
                if (reconnectionPanel) {
                    reconnectionPanel.remove();
                }
            }
            
            // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ê¸°ëŠ¥ (ì‘ì—… 15 ê°œì„ )
            handleKeyboardInput(event) {
                const key = event.key.toLowerCase();
                
                // ë””ë²„ê·¸ ëª¨ë“œ í† ê¸€ (F1 í‚¤)
                if (key === 'f1') {
                    event.preventDefault();
                    this.toggleDebugMode();
                    return;
                }
                
                // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ í† ê¸€ (F2 í‚¤)
                if (key === 'f2') {
                    event.preventDefault();
                    this.toggleKeyboardTestMode();
                    return;
                }
                
                // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ í‚¤ë³´ë“œ ì…ë ¥ ë¬´ì‹œ
                if (!this.keyboardTestMode) return;
                
                // ê²Œì„ì´ ì§„í–‰ ì¤‘ì´ ì•„ë‹ˆë©´ í‚¤ë³´ë“œ ì…ë ¥ ë¬´ì‹œ
                if (this.gameState !== 'racing' && this.gameState !== 'preparing') return;
                
                // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
                this.processKeyboardInput(key, event);
            }
            
            // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬ (ì‘ì—… 15)
            processKeyboardInput(key, event) {
                event.preventDefault();
                
                // í‚¤ ìƒíƒœ ì¶”ì 
                if (!this.keyStates) {
                    this.keyStates = {};
                }
                
                this.keyStates[key] = true;
                
                // ì—°ì† ì…ë ¥ ì²˜ë¦¬ë¥¼ ìœ„í•œ í‚¤ ì—… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                const handleKeyUp = (upEvent) => {
                    if (upEvent.key.toLowerCase() === key) {
                        this.keyStates[key] = false;
                        document.removeEventListener('keyup', handleKeyUp);
                    }
                };
                document.addEventListener('keyup', handleKeyUp);
                
                // í‚¤ë³´ë“œ ì¡°ì‘ ì ìš©
                this.applyKeyboardControls();
            }
            
            // í‚¤ë³´ë“œ ì¡°ì‘ ì ìš© (ì‘ì—… 15)
            applyKeyboardControls() {
                if (!this.keyStates) return;
                
                // í”Œë ˆì´ì–´ 1 ì¡°ì‘ (WASD)
                let player1Speed = 0;
                let player1Steering = 0;
                
                if (this.keyStates['w']) player1Speed += 1;
                if (this.keyStates['s']) player1Speed -= 0.5;
                if (this.keyStates['a']) player1Steering -= 1;
                if (this.keyStates['d']) player1Steering += 1;
                
                // í”Œë ˆì´ì–´ 2 ì¡°ì‘ (í™”ì‚´í‘œ í‚¤)
                let player2Speed = 0;
                let player2Steering = 0;
                
                if (this.keyStates['arrowup']) player2Speed += 1;
                if (this.keyStates['arrowdown']) player2Speed -= 0.5;
                if (this.keyStates['arrowleft']) player2Steering -= 1;
                if (this.keyStates['arrowright']) player2Steering += 1;
                
                // ìë™ì°¨ì— í‚¤ë³´ë“œ ì…ë ¥ ì ìš©
                if (this.cars) {
                    if (this.cars.player1) {
                        this.cars.player1.applySensorInput(player1Speed, player1Steering);
                    }
                    if (this.cars.player2) {
                        this.cars.player2.applySensorInput(player2Speed, player2Steering);
                    }
                }
                
                // í”Œë ˆì´ì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
                this.players.sensor1.speed = player1Speed;
                this.players.sensor1.steering = player1Steering;
                this.players.sensor2.speed = player2Speed;
                this.players.sensor2.steering = player2Steering;
                
                // HUD ì—…ë°ì´íŠ¸
                this.updateHUD();
            }
            
            // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ í† ê¸€ (ì‘ì—… 15)
            toggleKeyboardTestMode() {
                this.keyboardTestMode = !this.keyboardTestMode;
                
                console.log(`âŒ¨ï¸ í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ${this.keyboardTestMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
                
                // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ UI í‘œì‹œ
                this.showKeyboardTestModeUI();
                
                // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ ë¹„í™œì„±í™” ì‹œ í‚¤ ìƒíƒœ ì´ˆê¸°í™”
                if (!this.keyboardTestMode) {
                    this.keyStates = {};
                }
            }
            
            // í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ UI í‘œì‹œ (ì‘ì—… 15)
            showKeyboardTestModeUI() {
                // ê¸°ì¡´ UI ì œê±°
                const existingUI = document.getElementById('keyboardTestUI');
                if (existingUI) {
                    existingUI.remove();
                }
                
                if (!this.keyboardTestMode) return;
                
                const keyboardUI = document.createElement('div');
                keyboardUI.id = 'keyboardTestUI';
                keyboardUI.style.cssText = `
                    position: fixed;
                    top: 1rem;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(139, 92, 246, 0.95);
                    color: white;
                    padding: 0.75rem 1.5rem;
                    border-radius: 0.5rem;
                    font-size: 0.9rem;
                    font-weight: 600;
                    z-index: 150;
                    border: 2px solid var(--secondary);
                    backdrop-filter: blur(8px);
                `;
                
                keyboardUI.innerHTML = `
                    âŒ¨ï¸ í‚¤ë³´ë“œ í…ŒìŠ¤íŠ¸ ëª¨ë“œ í™œì„±í™”
                    <div style="font-size: 0.8rem; margin-top: 0.25rem; opacity: 0.9;">
                        í”Œë ˆì´ì–´ 1: WASD | í”Œë ˆì´ì–´ 2: í™”ì‚´í‘œ í‚¤ | F2: í† ê¸€ | F1: ë””ë²„ê·¸
                    </div>
                `;
                
                document.body.appendChild(keyboardUI);
            }
            
            // ë””ë²„ê·¸ ëª¨ë“œ í† ê¸€ (ì‘ì—… 15)
            toggleDebugMode() {
                this.debugMode = !this.debugMode;
                
                console.log(`ğŸ› ë””ë²„ê·¸ ëª¨ë“œ: ${this.debugMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
                
                if (this.debugMode) {
                    // ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™” ì‹œ ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹œì‘
                    console.log('ğŸ§ª ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™” - ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹œì‘');
                    this.startAutomaticTests();
                } else {
                    // ë””ë²„ê·¸ ëª¨ë“œ ë¹„í™œì„±í™” ì‹œ í…ŒìŠ¤íŠ¸ ì •ë¦¬
                    this.cleanupDebugMode();
                }
                
                // ë””ë²„ê·¸ ì •ë³´ UI í‘œì‹œ/ìˆ¨ê¹€
                this.showDebugUI();
            }
            
            // ë””ë²„ê·¸ ëª¨ë“œ ì •ë¦¬
            cleanupDebugMode() {
                // ë””ë²„ê·¸ ì—…ë°ì´íŠ¸ ì¸í„°ë²Œ ì •ë¦¬
                if (this.debugUpdateInterval) {
                    clearInterval(this.debugUpdateInterval);
                    this.debugUpdateInterval = null;
                }
                
                // í…ŒìŠ¤íŠ¸ ê²°ê³¼ íŒ¨ë„ ì œê±°
                const testResultsPanel = document.getElementById('testResultsPanel');
                if (testResultsPanel) {
                    testResultsPanel.remove();
                }
                
                console.log('ğŸ§¹ ë””ë²„ê·¸ ëª¨ë“œ ì •ë¦¬ ì™„ë£Œ');
            }
            
            // ë””ë²„ê·¸ UI í‘œì‹œ (ì‘ì—… 15)
            showDebugUI() {
                // ê¸°ì¡´ ë””ë²„ê·¸ UI ì œê±°
                const existingDebugUI = document.getElementById('debugUI');
                if (existingDebugUI) {
                    existingDebugUI.remove();
                }
                
                if (!this.debugMode) return;
                
                const debugUI = document.createElement('div');
                debugUI.id = 'debugUI';
                debugUI.style.cssText = `
                    position: fixed;
                    bottom: 1rem;
                    right: 1rem;
                    background: rgba(0, 0, 0, 0.8);
                    color: #00ff00;
                    padding: 1rem;
                    border-radius: 0.5rem;
                    font-family: 'Courier New', monospace;
                    font-size: 0.8rem;
                    z-index: 150;
                    min-width: 250px;
                    border: 1px solid #00ff00;
                `;
                
                document.body.appendChild(debugUI);
                
                // ë””ë²„ê·¸ ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œì‘
                this.startDebugInfoUpdate();
            }
            
            // ë””ë²„ê·¸ ì •ë³´ ì—…ë°ì´íŠ¸ (ì‘ì—… 15)
            startDebugInfoUpdate() {
                if (this.debugUpdateInterval) {
                    clearInterval(this.debugUpdateInterval);
                }
                
                this.debugUpdateInterval = setInterval(() => {
                    const debugUI = document.getElementById('debugUI');
                    if (!debugUI || !this.debugMode) {
                        clearInterval(this.debugUpdateInterval);
                        return;
                    }
                    
                    const debugInfo = this.getDebugInfo();
                    debugUI.innerHTML = `
                        <div style="color: #00ff00; font-weight: bold; margin-bottom: 0.5rem;">ğŸ› DEBUG INFO</div>
                        <div>ê²Œì„ ìƒíƒœ: ${debugInfo.gameState}</div>
                        <div>ì—°ê²°ëœ ì„¼ì„œ: ${debugInfo.connectedSensors}</div>
                        <div>í‚¤ë³´ë“œ ëª¨ë“œ: ${debugInfo.keyboardMode}</div>
                        <div>FPS: ${debugInfo.fps}</div>
                        <div style="margin-top: 0.5rem; color: #ffff00;">í”Œë ˆì´ì–´ 1:</div>
                        <div>  ìœ„ì¹˜: ${debugInfo.player1.position}</div>
                        <div>  ì†ë„: ${debugInfo.player1.speed} km/h</div>
                        <div>  ì¡°í–¥: ${debugInfo.player1.steering}</div>
                        <div style="margin-top: 0.5rem; color: #ffff00;">í”Œë ˆì´ì–´ 2:</div>
                        <div>  ìœ„ì¹˜: ${debugInfo.player2.position}</div>
                        <div>  ì†ë„: ${debugInfo.player2.speed} km/h</div>
                        <div>  ì¡°í–¥: ${debugInfo.player2.steering}</div>
                    `;
                }, 100);
            }
            
            // ë””ë²„ê·¸ ì •ë³´ ìˆ˜ì§‘ (ì‘ì—… 15)
            getDebugInfo() {
                const fps = this.lastFrameTime ? Math.round(1000 / (Date.now() - this.lastFrameTime)) : 0;
                this.lastFrameTime = Date.now();
                
                return {
                    gameState: this.gameState,
                    connectedSensors: this.connectedSensors.size,
                    keyboardMode: this.keyboardTestMode ? 'ON' : 'OFF',
                    fps: fps,
                    player1: {
                        position: this.cars?.player1 ? 
                            `(${this.cars.player1.getPosition().x.toFixed(1)}, ${this.cars.player1.getPosition().z.toFixed(1)})` : 
                            'N/A',
                        speed: this.cars?.player1 ? this.cars.player1.getSpeed().toFixed(1) : '0',
                        steering: this.players.sensor1.steering.toFixed(2)
                    },
                    player2: {
                        position: this.cars?.player2 ? 
                            `(${this.cars.player2.getPosition().x.toFixed(1)}, ${this.cars.player2.getPosition().z.toFixed(1)})` : 
                            'N/A',
                        speed: this.cars?.player2 ? this.cars.player2.getSpeed().toFixed(1) : '0',
                        steering: this.players.sensor2.steering.toFixed(2)
                    }
                };
            } 
           
            startGamePreparation() {
                // ì„¸ì…˜ íŒ¨ë„ ìˆ¨ê¸°ê³  ê²Œì„ HUD í‘œì‹œ
                this.elements.sessionPanel.classList.add('hidden');
                this.elements.gameHUD.classList.remove('hidden');
                this.elements.controlPanel.classList.remove('hidden');
                
                // ê²Œì„ ìƒíƒœë¥¼ ì¤€ë¹„ ìƒíƒœë¡œ ë³€ê²½
                this.gameState = 'preparing';
                
                // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                this.startCountdown();
                
                console.log('ğŸ ê²Œì„ ì¤€ë¹„ ì‹œì‘!');
            }
            
            // ê²Œì„ ì‹œì‘ ì¹´ìš´íŠ¸ë‹¤ìš´ êµ¬í˜„ (ì‘ì—… 9)
            startCountdown() {
                let countdown = 3;
                this.gameState = 'preparing';
                
                // ì¹´ìš´íŠ¸ë‹¤ìš´ UI ìš”ì†Œ ìƒì„±
                const countdownElement = document.createElement('div');
                countdownElement.className = 'countdown';
                countdownElement.id = 'countdownDisplay';
                document.body.appendChild(countdownElement);
                
                const showCountdown = (number) => {
                    countdownElement.textContent = number;
                    countdownElement.style.animation = 'none';
                    // ê°•ì œ ë¦¬í”Œë¡œìš°
                    countdownElement.offsetHeight;
                    countdownElement.style.animation = 'countdownPulse 1s ease-in-out';
                };
                
                // 3, 2, 1 ì¹´ìš´íŠ¸ë‹¤ìš´
                showCountdown(countdown);
                
                this.countdownTimer = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        showCountdown(countdown);
                    } else {
                        // GO! í‘œì‹œ
                        countdownElement.textContent = 'GO!';
                        countdownElement.style.color = '#10b981'; // ì´ˆë¡ìƒ‰
                        countdownElement.style.animation = 'countdownPulse 1s ease-in-out';
                        
                        // 1ì´ˆ í›„ ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ ë° ê²Œì„ ì‹œì‘
                        setTimeout(() => {
                            this.finishCountdown();
                        }, 1000);
                        
                        clearInterval(this.countdownTimer);
                    }
                }, 1000);
                
                console.log('â±ï¸ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘!');
            }
            
            finishCountdown() {
                // ì¹´ìš´íŠ¸ë‹¤ìš´ UI ì œê±°
                const countdownElement = document.getElementById('countdownDisplay');
                if (countdownElement) {
                    countdownElement.remove();
                }
                
                // ê²Œì„ ìƒíƒœë¥¼ racingìœ¼ë¡œ ë³€ê²½
                this.gameState = 'racing';
                this.raceStartTime = Date.now();
                
                // ê²Œì„ íƒ€ì´ë¨¸ ì‹œì‘
                this.startGameTimer();
                
                console.log('ğŸ ê²½ì£¼ ì‹œì‘!');
            }
            
            // ê²Œì„ íƒ€ì´ë¨¸ ì‹œì‘
            startGameTimer() {
                this.gameTimer = setInterval(() => {
                    if (this.gameState === 'racing' && !this.isPaused) {
                        const currentTime = Date.now();
                        const elapsedTime = (currentTime - this.raceStartTime) / 1000;
                        
                        // í”Œë ˆì´ì–´ë³„ ì‹œê°„ ì—…ë°ì´íŠ¸
                        Object.keys(this.players).forEach(playerId => {
                            if (this.players[playerId].connected) {
                                this.players[playerId].totalTime = elapsedTime;
                            }
                        });
                        
                        // HUD ì—…ë°ì´íŠ¸
                        this.updateHUD();
                    }
                }, 100); // 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
            }
            
            // ê²Œì„ ì¼ì‹œì •ì§€ ë° ì¬ê°œ ê¸°ëŠ¥ (ì‘ì—… 9)
            pauseGame() {
                if (this.gameState === 'racing') {
                    this.gameState = 'paused';
                    this.isPaused = true;
                    
                    // íƒ€ì´ë¨¸ ì¼ì‹œì •ì§€
                    if (this.gameTimer) {
                        clearInterval(this.gameTimer);
                        this.gameTimer = null;
                    }
                    
                    console.log('â¸ï¸ ê²Œì„ ì¼ì‹œì •ì§€');
                    this.updateGameStatus();
                }
            }
            
            resumeGame() {
                if (this.gameState === 'paused') {
                    this.gameState = 'racing';
                    this.isPaused = false;
                    
                    // íƒ€ì´ë¨¸ ì¬ì‹œì‘
                    this.startGameTimer();
                    
                    console.log('â–¶ï¸ ê²Œì„ ì¬ê°œ');
                    this.updateGameStatus();
                }
            }
            
            // ê²Œì„ ì¬ì‹œì‘ (ì‘ì—… 13 ê°œì„ )
            resetGame() {
                console.log('ğŸ”„ ê²Œì„ ì¬ì‹œì‘ ì‹œì‘...');
                
                // ê²°ê³¼ íŒ¨ë„ ì œê±°
                this.removeResultPanels();
                
                // ê¸°ì¡´ íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
                this.clearAllTimers();
                
                // ê²Œì„ ìƒíƒœë§Œ ì´ˆê¸°í™” (ì„¸ì…˜ê³¼ ì„¼ì„œ ì—°ê²°ì€ ìœ ì§€)
                this.resetGameStateOnly();
                
                // ìë™ì°¨ ìœ„ì¹˜ ë¦¬ì…‹
                this.resetCarPositions();
                
                // UI ì—…ë°ì´íŠ¸
                this.updateHUD();
                this.updateGameStatus();
                
                // ì„¼ì„œê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ë°”ë¡œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                if (this.connectedSensors.size >= 2) {
                    this.startCountdown();
                } else {
                    console.log('âš ï¸ ì„¼ì„œ ì¬ì—°ê²° ëŒ€ê¸° ì¤‘...');
                    this.gameState = 'waiting';
                    this.updateGameStatus();
                }
                
                console.log('âœ… ê²Œì„ ì¬ì‹œì‘ ì™„ë£Œ (ì„¸ì…˜ ìœ ì§€)');
            }
            
            // ê²°ê³¼ íŒ¨ë„ ì œê±° (ì‘ì—… 13)
            removeResultPanels() {
                const existingPanels = document.querySelectorAll('.ui-panel');
                existingPanels.forEach(panel => {
                    if (panel.innerHTML.includes('ê²½ì£¼ ì™„ë£Œ') || panel.innerHTML.includes('ìš°ìŠ¹ì')) {
                        panel.remove();
                    }
                });
            }
            
            // ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬ (ì‘ì—… 13)
            clearAllTimers() {
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                }
                if (this.gameTimer) {
                    clearInterval(this.gameTimer);
                    this.gameTimer = null;
                }
                
                // ì¹´ìš´íŠ¸ë‹¤ìš´ UI ì œê±°
                const countdownElement = document.getElementById('countdownDisplay');
                if (countdownElement) {
                    countdownElement.remove();
                }
            }
            
            // ê²Œì„ ìƒíƒœë§Œ ì´ˆê¸°í™” (ì„¸ì…˜ ìœ ì§€) (ì‘ì—… 13)
            resetGameStateOnly() {
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.gameState = 'preparing';
                this.isPaused = false;
                this.raceStartTime = null;
                this.raceFinished = false;
                
                // í”Œë ˆì´ì–´ë³„ ìƒíƒœ ì¶”ì  ë°ì´í„° ì´ˆê¸°í™”
                Object.keys(this.players).forEach(playerId => {
                    this.players[playerId].speed = 0;
                    this.players[playerId].steering = 0;
                    this.players[playerId].lapCount = 0;
                    this.players[playerId].lapTime = 0;
                    this.players[playerId].totalTime = 0;
                    this.players[playerId].position = { x: 0, y: 0, z: 0 };
                    this.players[playerId].sensorData = { tiltX: 0, tiltY: 0, acceleration: 0 };
                });
                
                // ë© ì¶”ì  ë°ì´í„° ì´ˆê¸°í™”
                this.initializeLapTracking();
                
                // ì„¼ì„œ ë°ì´í„° í•„í„°ë§ ì´ˆê¸°í™”
                this.previousSensorValues = { steering: 0, speed: 0 };
                
                // ì¼ì‹œì •ì§€ ë²„íŠ¼ ìƒíƒœ ë¦¬ì…‹
                const pauseResumeBtn = document.getElementById('pauseResumeBtn');
                if (pauseResumeBtn) {
                    pauseResumeBtn.innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';
                }
            }
            
            // ìë™ì°¨ ìœ„ì¹˜ ë¦¬ì…‹ (ì‘ì—… 13)
            resetCarPositions() {
                if (this.cars) {
                    // ì‹œì‘ ìœ„ì¹˜ë¡œ ë¦¬ì…‹ (ì²´í¬í¬ì¸íŠ¸ 0 ê·¼ì²˜)
                    this.cars.player1.reset(-45, 0.5, -2);
                    this.cars.player2.reset(-45, 0.5, 2);
                    
                    console.log('ğŸï¸ ìë™ì°¨ ìœ„ì¹˜ ë¦¬ì…‹ ì™„ë£Œ');
                }
            }
            
            // ê²Œì„ ì™„ì „ ì¢…ë£Œ ë° ì„¸ì…˜ ì •ë¦¬ (ì‘ì—… 13)
            terminateGame() {
                console.log('ğŸ›‘ ê²Œì„ ì™„ì „ ì¢…ë£Œ ì‹œì‘...');
                
                // ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
                this.clearAllTimers();
                
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.gameState = 'waiting';
                this.raceFinished = true;
                
                // ì„¸ì…˜ ì •ë¦¬
                this.cleanupSession();
                
                // ë©”ëª¨ë¦¬ í•´ì œ
                this.cleanupMemory();
                
                console.log('âœ… ê²Œì„ ì™„ì „ ì¢…ë£Œ ì™„ë£Œ');
            }
            
            // ì„¸ì…˜ ì •ë¦¬ (ì‘ì—… 13)
            cleanupSession() {
                try {
                    // ì„¼ì„œ ì—°ê²° í•´ì œ
                    this.connectedSensors.clear();
                    
                    // ì—°ê²° ìƒíƒœ ì´ˆê¸°í™”
                    this.connectionStatus = {
                        server: false,
                        sensor1: false,
                        sensor2: false
                    };
                    
                    // SessionSDK ì •ë¦¬ (í•„ìš”í•œ ê²½ìš°)
                    if (this.sdk && typeof this.sdk.disconnect === 'function') {
                        this.sdk.disconnect();
                    }
                    
                    console.log('ğŸ§¹ ì„¸ì…˜ ì •ë¦¬ ì™„ë£Œ');
                } catch (error) {
                    console.warn('ì„¸ì…˜ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                }
            }
            
            // ë©”ëª¨ë¦¬ í•´ì œ (ì‘ì—… 13)
            cleanupMemory() {
                try {
                    // 3D ê°ì²´ ì •ë¦¬
                    if (this.scene) {
                        // ì²´í¬í¬ì¸íŠ¸ ë©”ì‹œ ì œê±°
                        this.checkpoints.forEach(checkpoint => {
                            if (checkpoint.mesh) {
                                this.scene.remove(checkpoint.mesh);
                            }
                        });
                        
                        // ìë™ì°¨ ë©”ì‹œ ì œê±°
                        if (this.cars) {
                            Object.values(this.cars).forEach(car => {
                                if (car.mesh) {
                                    this.scene.remove(car.mesh);
                                }
                            });
                        }
                    }
                    
                    // ë¬¼ë¦¬ ë°”ë”” ì •ë¦¬
                    if (this.world && this.cars) {
                        Object.values(this.cars).forEach(car => {
                            if (car.physicsBody) {
                                this.world.remove(car.physicsBody);
                            }
                        });
                    }
                    
                    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
                    window.removeEventListener('resize', this.resizeCanvas);
                    
                    console.log('ğŸ§¹ ë©”ëª¨ë¦¬ í•´ì œ ì™„ë£Œ');
                } catch (error) {
                    console.warn('ë©”ëª¨ë¦¬ í•´ì œ ì¤‘ ì˜¤ë¥˜:', error);
                }
            }
            
            // í—ˆë¸Œë¡œ ëŒì•„ê°€ê¸° (ì‘ì—… 13)
            returnToHub() {
                console.log('ğŸ  í—ˆë¸Œë¡œ ëŒì•„ê°€ê¸°...');
                
                // ê²Œì„ ì™„ì „ ì¢…ë£Œ
                this.terminateGame();
                
                // í˜ì´ì§€ ì´ë™
                window.location.href = '/';
            }
            
            updateConnectionUI() {
                // ì„œë²„ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
                const server1Status = document.getElementById('server1Status');
                const server2Status = document.getElementById('server2Status');
                
                if (server1Status) {
                    server1Status.classList.toggle('connected', this.connectionStatus.server);
                }
                if (server2Status) {
                    server2Status.classList.toggle('connected', this.connectionStatus.server);
                }
                
                // ì„¼ì„œ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
                const sensor1Status = document.getElementById('sensor1Status');
                const sensor2Status = document.getElementById('sensor2Status');
                
                if (sensor1Status) {
                    sensor1Status.classList.toggle('connected', this.connectionStatus.sensor1);
                }
                if (sensor2Status) {
                    sensor2Status.classList.toggle('connected', this.connectionStatus.sensor2);
                }
                
                // ê²Œì„ ìƒíƒœ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                this.updateGameStatus();
            }
            
            updateGameStatus() {
                const gameStatus = document.getElementById('gameStatus');
                if (!gameStatus) return;
                
                let statusText = '';
                
                switch (this.gameState) {
                    case 'waiting':
                        if (this.connectedSensors.size === 0) {
                            statusText = 'ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...';
                        } else if (this.connectedSensors.size === 1) {
                            statusText = 'ë‘ ë²ˆì§¸ ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...';
                        } else {
                            statusText = 'ê²Œì„ ì‹œì‘ ì¤€ë¹„ ì™„ë£Œ!';
                        }
                        break;
                    case 'preparing':
                        statusText = 'ê²Œì„ ì‹œì‘ ì¹´ìš´íŠ¸ë‹¤ìš´...';
                        break;
                    case 'racing':
                        const elapsedTime = this.raceStartTime ? 
                            ((Date.now() - this.raceStartTime) / 1000).toFixed(1) : '0.0';
                        statusText = `ê²½ì£¼ ì§„í–‰ ì¤‘ (${elapsedTime}ì´ˆ)`;
                        break;
                    case 'paused':
                        statusText = 'ê²Œì„ ì¼ì‹œì •ì§€ - ì„¼ì„œ ì¬ì—°ê²° ëŒ€ê¸° ì¤‘';
                        break;
                    case 'finished':
                        statusText = 'ê²½ì£¼ ì™„ë£Œ!';
                        break;
                }
                
                gameStatus.textContent = statusText;
                gameStatus.classList.toggle('hidden', this.gameState === 'waiting');
            }  
          
            updateHUD() {
                // í”Œë ˆì´ì–´ 1 HUD ì—…ë°ì´íŠ¸
                const player1Speed = document.getElementById('player1Speed');
                const player1Lap = document.getElementById('player1Lap');
                const player1Time = document.getElementById('player1Time');
                
                if (player1Speed && this.cars && this.cars.player1) {
                    player1Speed.textContent = `${this.cars.player1.getSpeed().toFixed(1)} km/h`;
                }
                if (player1Lap && this.lapTracking) {
                    const lapData = this.lapTracking.sensor1;
                    player1Lap.textContent = `${lapData.currentLap}/${this.totalLaps}`;
                    
                    // ìˆœìœ„ í‘œì‹œ ì¶”ê°€ (ì‘ì—… 10)
                    if (lapData.rank) {
                        player1Lap.textContent += ` (${lapData.rank}ìœ„)`;
                    }
                }
                if (player1Time) {
                    // í˜„ì¬ ë© íƒ€ì„ ë˜ëŠ” ì´ ì‹œê°„ í‘œì‹œ
                    if (this.lapTracking && this.lapTracking.sensor1.lapStartTime && this.gameState === 'racing') {
                        const currentLapTime = (Date.now() - this.lapTracking.sensor1.lapStartTime) / 1000;
                        player1Time.textContent = `${currentLapTime.toFixed(2)}s`;
                    } else {
                        player1Time.textContent = `${this.players.sensor1.totalTime.toFixed(2)}s`;
                    }
                }
                
                // í”Œë ˆì´ì–´ 2 HUD ì—…ë°ì´íŠ¸
                const player2Speed = document.getElementById('player2Speed');
                const player2Lap = document.getElementById('player2Lap');
                const player2Time = document.getElementById('player2Time');
                
                if (player2Speed && this.cars && this.cars.player2) {
                    player2Speed.textContent = `${this.cars.player2.getSpeed().toFixed(1)} km/h`;
                }
                if (player2Lap && this.lapTracking) {
                    const lapData = this.lapTracking.sensor2;
                    player2Lap.textContent = `${lapData.currentLap}/${this.totalLaps}`;
                    
                    // ìˆœìœ„ í‘œì‹œ ì¶”ê°€ (ì‘ì—… 10)
                    if (lapData.rank) {
                        player2Lap.textContent += ` (${lapData.rank}ìœ„)`;
                    }
                }
                if (player2Time) {
                    // í˜„ì¬ ë© íƒ€ì„ ë˜ëŠ” ì´ ì‹œê°„ í‘œì‹œ
                    if (this.lapTracking && this.lapTracking.sensor2.lapStartTime && this.gameState === 'racing') {
                        const currentLapTime = (Date.now() - this.lapTracking.sensor2.lapStartTime) / 1000;
                        player2Time.textContent = `${currentLapTime.toFixed(2)}s`;
                    } else {
                        player2Time.textContent = `${this.players.sensor2.totalTime.toFixed(2)}s`;
                    }
                }
            }
            
            startRenderLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì—…ë°ì´íŠ¸
                    this.world.step(1/60);
                    
                    // ìë™ì°¨ ì—…ë°ì´íŠ¸
                    if (this.cars) {
                        this.cars.player1.update();
                        this.cars.player2.update();
                        
                        // í”Œë ˆì´ì–´ë³„ ìƒíƒœ ì¶”ì  ì—…ë°ì´íŠ¸ (ì‘ì—… 9)
                        this.updatePlayerStates();
                        
                        // íŠ¸ë™ ì´íƒˆ ê°ì§€ (ì‘ì—… 11)
                        this.checkTrackBoundaries();
                        
                        // íŠ¸ë™ ì´íƒˆ ê°ì§€ (ì‘ì—… 11)
                        this.checkTrackBoundaries();
                    }
                    
                    // ì¹´ë©”ë¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    this.updateCameras();
                    
                    // í™”ë©´ ë¶„í•  ë Œë”ë§
                    this.renderSplitScreen();
                };
                
                animate();
            }
            
            // í”Œë ˆì´ì–´ë³„ ìƒíƒœ ì¶”ì  (ì‘ì—… 9 + 10)
            updatePlayerStates() {
                if (this.gameState !== 'racing' || !this.cars) return;
                
                // í”Œë ˆì´ì–´ 1 ìƒíƒœ ì—…ë°ì´íŠ¸ (ì‘ì—… 17 ì•ˆì „ì„± ê°œì„ )
                if (this.cars && this.cars.player1) {
                    const car1Pos = this.cars.player1.getPosition();
                    const car1Speed = this.cars.player1.getSpeed();
                    
                    this.players.sensor1.position = {
                        x: car1Pos.x,
                        y: car1Pos.y,
                        z: car1Pos.z
                    };
                    this.players.sensor1.speed = car1Speed;
                    
                    // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ ê°ì§€ (ì‘ì—… 10)
                    this.checkCheckpointPassing('sensor1', car1Pos);
                }
                
                // í”Œë ˆì´ì–´ 2 ìƒíƒœ ì—…ë°ì´íŠ¸
                if (this.cars.player2) {
                    const car2Pos = this.cars.player2.getPosition();
                    const car2Speed = this.cars.player2.getSpeed();
                    
                    this.players.sensor2.position = {
                        x: car2Pos.x,
                        y: car2Pos.y,
                        z: car2Pos.z
                    };
                    this.players.sensor2.speed = car2Speed;
                    
                    // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ ê°ì§€ (ì‘ì—… 10)
                    this.checkCheckpointPassing('sensor2', car2Pos);
                }
                
                // ì‹¤ì‹œê°„ ìˆœìœ„ ê³„ì‚° ë° í‘œì‹œ (ì‘ì—… 10)
                this.updateRankings();
            }
            
            // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ ê°ì§€ ë¡œì§ (ì‘ì—… 10)
            checkCheckpointPassing(playerId, carPosition) {
                if (!this.lapTracking || !this.checkpoints.length) return;
                
                const playerLapData = this.lapTracking[playerId];
                const currentTime = Date.now();
                
                // ê° ì²´í¬í¬ì¸íŠ¸ì™€ì˜ ê±°ë¦¬ í™•ì¸
                this.checkpoints.forEach((checkpoint, index) => {
                    const distance = Math.sqrt(
                        Math.pow(carPosition.x - checkpoint.position.x, 2) + 
                        Math.pow(carPosition.z - checkpoint.position.z, 2)
                    );
                    
                    // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ íŒì • (ê±°ë¦¬ 8ë¯¸í„° ì´ë‚´)
                    if (distance < 8) {
                        // ìˆœì„œëŒ€ë¡œ ì²´í¬í¬ì¸íŠ¸ë¥¼ í†µê³¼í•˜ëŠ”ì§€ í™•ì¸
                        const expectedCheckpoint = (playerLapData.lastCheckpoint + 1) % this.checkpoints.length;
                        
                        if (index === expectedCheckpoint) {
                            this.handleCheckpointPassed(playerId, checkpoint, index, currentTime);
                        }
                    }
                });
            }
            
            // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ ì²˜ë¦¬ (ì‘ì—… 10)
            handleCheckpointPassed(playerId, checkpoint, checkpointIndex, currentTime) {
                const playerLapData = this.lapTracking[playerId];
                
                playerLapData.lastCheckpoint = checkpointIndex;
                
                console.log(`${playerId} ì²´í¬í¬ì¸íŠ¸ ${checkpointIndex} (${checkpoint.name}) í†µê³¼!`);
                
                // ì‹œì‘/ê²°ìŠ¹ì„  í†µê³¼ ì²˜ë¦¬
                if (checkpointIndex === 0) {
                    if (playerLapData.currentLap === 0) {
                        // ì²« ë²ˆì§¸ ë© ì‹œì‘
                        this.startNewLap(playerId, currentTime);
                    } else {
                        // ë© ì™„ë£Œ
                        this.completeLap(playerId, currentTime);
                    }
                }
            }
            
            // ìƒˆ ë© ì‹œì‘ (ì‘ì—… 10)
            startNewLap(playerId, currentTime) {
                const playerLapData = this.lapTracking[playerId];
                
                playerLapData.currentLap = 1;
                playerLapData.lapStartTime = currentTime;
                playerLapData.lastCheckpoint = -1; // ì²´í¬í¬ì¸íŠ¸ ë¦¬ì…‹
                
                // í”Œë ˆì´ì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
                this.players[playerId].lapCount = playerLapData.currentLap;
                
                console.log(`ğŸ ${playerId} ì²« ë²ˆì§¸ ë© ì‹œì‘!`);
            }
            
            // ë© ì™„ì£¼ íŒì • ë° ì¹´ìš´íŠ¸ ì¦ê°€ (ì‘ì—… 10)
            completeLap(playerId, currentTime) {
                const playerLapData = this.lapTracking[playerId];
                
                if (playerLapData.lapStartTime) {
                    // ë© íƒ€ì„ ê³„ì‚°
                    const lapTime = (currentTime - playerLapData.lapStartTime) / 1000;
                    playerLapData.lapTimes.push(lapTime);
                    
                    // ìµœê³  ë© íƒ€ì„ ì—…ë°ì´íŠ¸
                    if (lapTime < playerLapData.bestLapTime) {
                        playerLapData.bestLapTime = lapTime;
                    }
                    
                    // ë© ì¹´ìš´íŠ¸ ì¦ê°€
                    playerLapData.currentLap++;
                    playerLapData.lastCheckpoint = -1; // ì²´í¬í¬ì¸íŠ¸ ë¦¬ì…‹
                    
                    // í”Œë ˆì´ì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
                    this.players[playerId].lapCount = playerLapData.currentLap;
                    this.players[playerId].lapTime = lapTime;
                    
                    console.log(`ğŸ† ${playerId} ë© ${playerLapData.currentLap - 1} ì™„ë£Œ! ì‹œê°„: ${lapTime.toFixed(2)}ì´ˆ`);
                    
                    // ê²½ì£¼ ì™„ë£Œ í™•ì¸ (3ë© ì™„ì£¼)
                    if (playerLapData.currentLap > this.totalLaps) {
                        this.handleRaceFinish(playerId);
                    } else {
                        // ë‹¤ìŒ ë© ì‹œì‘
                        playerLapData.lapStartTime = currentTime;
                    }
                }
            }
            
            // ê²½ì£¼ ì™„ë£Œ ì²˜ë¦¬ (ì‘ì—… 12 ê°œì„ )
            handleRaceFinish(playerId) {
                if (!this.raceFinished) {
                    this.raceFinished = true;
                    this.gameState = 'finished';
                    
                    // ê²Œì„ íƒ€ì´ë¨¸ ì •ì§€
                    if (this.gameTimer) {
                        clearInterval(this.gameTimer);
                        this.gameTimer = null;
                    }
                    
                    // ìµœì¢… ìˆœìœ„ ê³„ì‚°
                    this.calculateFinalRankings();
                    
                    // ìµœê³  ê¸°ë¡ ì €ì¥
                    this.savePersonalBests();
                    
                    console.log(`ğŸ ${playerId} ê²½ì£¼ ì™„ë£Œ! ìš°ìŠ¹ì!`);
                    
                    // ê²°ê³¼ í‘œì‹œ (ì•½ê°„ì˜ ì§€ì—° í›„)
                    setTimeout(() => {
                        this.showRaceResults();
                    }, 1000);
                }
            }
            
            // ìµœì¢… ìˆœìœ„ ê³„ì‚° (ì‘ì—… 12)
            calculateFinalRankings() {
                const players = ['sensor1', 'sensor2'];
                
                // ì™„ì£¼í•œ ë© ìˆ˜ì™€ ì´ ì‹œê°„ìœ¼ë¡œ ìˆœìœ„ ê²°ì •
                players.sort((a, b) => {
                    const playerA = this.lapTracking[a];
                    const playerB = this.lapTracking[b];
                    
                    // ì™„ì£¼í•œ ë© ìˆ˜ë¡œ ë¨¼ì € ë¹„êµ
                    if (playerA.currentLap !== playerB.currentLap) {
                        return playerB.currentLap - playerA.currentLap;
                    }
                    
                    // ë© ìˆ˜ê°€ ê°™ìœ¼ë©´ ì´ ì‹œê°„ìœ¼ë¡œ ë¹„êµ
                    const totalTimeA = playerA.lapTimes.reduce((sum, time) => sum + time, 0);
                    const totalTimeB = playerB.lapTimes.reduce((sum, time) => sum + time, 0);
                    
                    return totalTimeA - totalTimeB;
                });
                
                // ìµœì¢… ìˆœìœ„ ì—…ë°ì´íŠ¸
                players.forEach((playerId, index) => {
                    this.lapTracking[playerId].finalRank = index + 1;
                });
                
                console.log('ğŸ† ìµœì¢… ìˆœìœ„ ê³„ì‚° ì™„ë£Œ');
            }
            
            // ìµœê³  ê¸°ë¡ ì €ì¥ (ì‘ì—… 12)
            savePersonalBests() {
                try {
                    const currentBests = JSON.parse(localStorage.getItem('racing3d_records') || '{}');
                    
                    ['sensor1', 'sensor2'].forEach((playerId, index) => {
                        const playerData = this.lapTracking[playerId];
                        const playerKey = `player${index + 1}`;
                        
                        if (!currentBests[playerKey]) {
                            currentBests[playerKey] = {
                                bestLapTime: Infinity,
                                bestRaceTime: Infinity,
                                totalRaces: 0,
                                wins: 0
                            };
                        }
                        
                        const playerBests = currentBests[playerKey];
                        
                        // ìµœê³  ë© íƒ€ì„ ì—…ë°ì´íŠ¸
                        if (playerData.bestLapTime < playerBests.bestLapTime) {
                            playerBests.bestLapTime = playerData.bestLapTime;
                        }
                        
                        // ìµœê³  ë ˆì´ìŠ¤ íƒ€ì„ ì—…ë°ì´íŠ¸ (3ë© ì™„ì£¼í•œ ê²½ìš°)
                        if (playerData.currentLap > this.totalLaps) {
                            const raceTime = playerData.lapTimes.reduce((sum, time) => sum + time, 0);
                            if (raceTime < playerBests.bestRaceTime) {
                                playerBests.bestRaceTime = raceTime;
                            }
                        }
                        
                        // ì´ ê²½ì£¼ ìˆ˜ ì¦ê°€
                        playerBests.totalRaces++;
                        
                        // ìŠ¹ë¦¬ ìˆ˜ ì—…ë°ì´íŠ¸
                        if (playerData.finalRank === 1) {
                            playerBests.wins++;
                        }
                    });
                    
                    localStorage.setItem('racing3d_records', JSON.stringify(currentBests));
                    console.log('ğŸ’¾ ìµœê³  ê¸°ë¡ ì €ì¥ ì™„ë£Œ');
                } catch (error) {
                    console.warn('ìµœê³  ê¸°ë¡ ì €ì¥ ì‹¤íŒ¨:', error);
                }
            }
            
            // ì‹¤ì‹œê°„ ìˆœìœ„ ê³„ì‚° ë° í‘œì‹œ (ì‘ì—… 10)
            updateRankings() {
                const players = ['sensor1', 'sensor2'];
                
                // ë© ìˆ˜ì™€ ì²´í¬í¬ì¸íŠ¸ ì§„í–‰ë„ë¡œ ìˆœìœ„ ê³„ì‚°
                players.sort((a, b) => {
                    const playerA = this.lapTracking[a];
                    const playerB = this.lapTracking[b];
                    
                    // ë© ìˆ˜ê°€ ë‹¤ë¥´ë©´ ë© ìˆ˜ë¡œ ë¹„êµ
                    if (playerA.currentLap !== playerB.currentLap) {
                        return playerB.currentLap - playerA.currentLap;
                    }
                    
                    // ë© ìˆ˜ê°€ ê°™ìœ¼ë©´ ì²´í¬í¬ì¸íŠ¸ ì§„í–‰ë„ë¡œ ë¹„êµ
                    if (playerA.lastCheckpoint !== playerB.lastCheckpoint) {
                        return playerB.lastCheckpoint - playerA.lastCheckpoint;
                    }
                    
                    // ëª¨ë“  ê²ƒì´ ê°™ìœ¼ë©´ ìœ„ì¹˜ë¡œ ë¹„êµ (x ì¢Œí‘œ ê¸°ì¤€)
                    const posA = this.players[a].position;
                    const posB = this.players[b].position;
                    return posB.x - posA.x;
                });
                
                // ìˆœìœ„ ì—…ë°ì´íŠ¸
                players.forEach((playerId, index) => {
                    this.lapTracking[playerId].rank = index + 1;
                });
            }
            
            // íŠ¸ë™ ì´íƒˆ ê°ì§€ (ì‘ì—… 11)
            checkTrackBoundaries() {
                if (!this.cars || this.gameState !== 'racing') return;
                
                const trackWidth = 10; // íŠ¸ë™ í­ì˜ ì ˆë°˜
                const trackLength = 50; // íŠ¸ë™ ê¸¸ì´ì˜ ì ˆë°˜
                
                // í”Œë ˆì´ì–´ 1 íŠ¸ë™ ì´íƒˆ í™•ì¸
                if (this.cars.player1) {
                    const pos1 = this.cars.player1.getPosition();
                    if (this.isOutOfBounds(pos1, trackWidth, trackLength)) {
                        this.handleTrackExit('player1', pos1);
                    }
                }
                
                // í”Œë ˆì´ì–´ 2 íŠ¸ë™ ì´íƒˆ í™•ì¸
                if (this.cars.player2) {
                    const pos2 = this.cars.player2.getPosition();
                    if (this.isOutOfBounds(pos2, trackWidth, trackLength)) {
                        this.handleTrackExit('player2', pos2);
                    }
                }
            }
            
            // íŠ¸ë™ ê²½ê³„ í™•ì¸ (ì‘ì—… 11)
            isOutOfBounds(position, trackWidth, trackLength) {
                return Math.abs(position.z) > trackWidth || 
                       Math.abs(position.x) > trackLength ||
                       position.y < -2; // íŠ¸ë™ ì•„ë˜ë¡œ ë–¨ì–´ì§„ ê²½ìš°
            }
            
            // íŠ¸ë™ ì´íƒˆ ì²˜ë¦¬ (ì‘ì—… 11)
            handleTrackExit(playerId, position) {
                console.log(`ğŸš¨ ${playerId} íŠ¸ë™ ì´íƒˆ ê°ì§€!`);
                
                // ìë™ì°¨ ë¦¬ì…‹ ìœ„ì¹˜ ê³„ì‚°
                const resetPosition = this.calculateResetPosition(position);
                
                // ìë™ì°¨ ë¦¬ì…‹
                if (playerId === 'player1' && this.cars.player1) {
                    this.resetCarToTrack(this.cars.player1, resetPosition);
                } else if (playerId === 'player2' && this.cars.player2) {
                    this.resetCarToTrack(this.cars.player2, resetPosition);
                }
                
                // í˜ë„í‹° ì ìš© (ì†ë„ ê°ì†Œ)
                this.applyTrackExitPenalty(playerId);
            }
            
            // ë¦¬ì…‹ ìœ„ì¹˜ ê³„ì‚° (ì‘ì—… 11)
            calculateResetPosition(currentPosition) {
                // ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ ìœ„ì¹˜ë¡œ ë¦¬ì…‹
                const trackWidth = 8;
                const trackLength = 45;
                
                let resetX = Math.max(-trackLength, Math.min(trackLength, currentPosition.x));
                let resetZ = Math.max(-trackWidth, Math.min(trackWidth, currentPosition.z));
                
                // íŠ¸ë™ ì¤‘ì•™ìœ¼ë¡œ ì•½ê°„ ì´ë™
                if (Math.abs(resetZ) > trackWidth * 0.8) {
                    resetZ = resetZ > 0 ? trackWidth * 0.7 : -trackWidth * 0.7;
                }
                
                return {
                    x: resetX,
                    y: 0.5,
                    z: resetZ
                };
            }
            
            // ìë™ì°¨ë¥¼ íŠ¸ë™ìœ¼ë¡œ ë¦¬ì…‹ (ì‘ì—… 11)
            resetCarToTrack(car, resetPosition) {
                if (car && car.physicsBody) {
                    // ìœ„ì¹˜ ë¦¬ì…‹
                    car.physicsBody.position.set(resetPosition.x, resetPosition.y, resetPosition.z);
                    
                    // ì†ë„ ë° íšŒì „ ì´ˆê¸°í™”
                    car.physicsBody.velocity.set(0, 0, 0);
                    car.physicsBody.angularVelocity.set(0, 0, 0);
                    
                    // ìë™ì°¨ ë°©í–¥ì„ íŠ¸ë™ ë°©í–¥ìœ¼ë¡œ ì¡°ì •
                    car.physicsBody.quaternion.set(0, 0, 0, 1);
                    
                    console.log(`ğŸ”„ ìë™ì°¨ íŠ¸ë™ìœ¼ë¡œ ë¦¬ì…‹: (${resetPosition.x.toFixed(1)}, ${resetPosition.y.toFixed(1)}, ${resetPosition.z.toFixed(1)})`);
                }
            }
            
            // íŠ¸ë™ ì´íƒˆ í˜ë„í‹° ì ìš© (ì‘ì—… 11)
            applyTrackExitPenalty(playerId) {
                // ë© íƒ€ì„ì— í˜ë„í‹° ì¶”ê°€ (2ì´ˆ)
                if (this.lapTracking && this.lapTracking[playerId === 'player1' ? 'sensor1' : 'sensor2']) {
                    const sensorId = playerId === 'player1' ? 'sensor1' : 'sensor2';
                    const lapData = this.lapTracking[sensorId];
                    
                    if (lapData.lapStartTime) {
                        // í˜ë„í‹° ì‹œê°„ ì¶”ê°€
                        lapData.lapStartTime -= 2000; // 2ì´ˆ í˜ë„í‹°
                        console.log(`â±ï¸ ${playerId} íŠ¸ë™ ì´íƒˆ í˜ë„í‹°: +2ì´ˆ`);
                    }
                }
            }
            
            updateCameras() {
                if (!this.cameras || !this.cars) return;
                
                // í”Œë ˆì´ì–´ 1 ì¹´ë©”ë¼ (ìë™ì°¨ ë’¤ì—ì„œ ë”°ë¼ê°€ê¸°)
                if (this.cars.player1 && this.cars.player1.mesh) {
                    const car1Pos = this.cars.player1.mesh.position;
                    const car1Rot = this.cars.player1.mesh.rotation;
                    
                    // ì¹´ë©”ë¼ë¥¼ ìë™ì°¨ ë’¤ìª½ 5ë¯¸í„°, ìœ„ìª½ 3ë¯¸í„°ì— ë°°ì¹˜
                    const offset = new THREE.Vector3(0, 3, 5);
                    offset.applyEuler(car1Rot);
                    
                    this.cameras.player1.position.copy(car1Pos).add(offset);
                    this.cameras.player1.lookAt(car1Pos);
                }
                
                // í”Œë ˆì´ì–´ 2 ì¹´ë©”ë¼ (ìë™ì°¨ ë’¤ì—ì„œ ë”°ë¼ê°€ê¸°)
                if (this.cars.player2 && this.cars.player2.mesh) {
                    const car2Pos = this.cars.player2.mesh.position;
                    const car2Rot = this.cars.player2.mesh.rotation;
                    
                    // ì¹´ë©”ë¼ë¥¼ ìë™ì°¨ ë’¤ìª½ 5ë¯¸í„°, ìœ„ìª½ 3ë¯¸í„°ì— ë°°ì¹˜
                    const offset = new THREE.Vector3(0, 3, 5);
                    offset.applyEuler(car2Rot);
                    
                    this.cameras.player2.position.copy(car2Pos).add(offset);
                    this.cameras.player2.lookAt(car2Pos);
                }
            }
            
            renderSplitScreen() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // ì™¼ìª½ í™”ë©´ (í”Œë ˆì´ì–´ 1)
                this.renderer.setViewport(0, 0, width / 2, height);
                this.renderer.setScissor(0, 0, width / 2, height);
                this.renderer.setScissorTest(true);
                this.renderer.render(this.scene, this.cameras.player1);
                
                // ì˜¤ë¥¸ìª½ í™”ë©´ (í”Œë ˆì´ì–´ 2)
                this.renderer.setViewport(width / 2, 0, width / 2, height);
                this.renderer.setScissor(width / 2, 0, width / 2, height);
                this.renderer.render(this.scene, this.cameras.player2);
                
                // ìŠ¤í¬ë¦° í…ŒìŠ¤íŠ¸ ë¹„í™œì„±í™”
                this.renderer.setScissorTest(false);
            }   
         
            resizeCanvas() {
                if (this.renderer) {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    // ì¹´ë©”ë¼ ë¹„ìœ¨ ì—…ë°ì´íŠ¸
                    const aspect = (window.innerWidth / 2) / window.innerHeight;
                    this.cameras.player1.aspect = aspect;
                    this.cameras.player1.updateProjectionMatrix();
                    
                    this.cameras.player2.aspect = aspect;
                    this.cameras.player2.updateProjectionMatrix();
                }
            }
            
            createSession() {
                this.sdk.createSession();
            }
            
            generateQRCode(sessionCode) {
                const qrContainer = this.elements.qrContainer;
                
                // QR ì½”ë“œ ìƒì„± URL
                const baseUrl = window.location.origin;
                const qrUrl = `${baseUrl}/sensor?code=${sessionCode}`;
                
                // QRCode ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© (í´ë°± ì²˜ë¦¬ í¬í•¨)
                if (typeof QRCode !== 'undefined') {
                    qrContainer.innerHTML = '';
                    QRCode.toCanvas(qrContainer, qrUrl, {
                        width: 200,
                        height: 200,
                        margin: 2
                    }, (error) => {
                        if (error) {
                            console.error('QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨:', error);
                            this.generateQRCodeFallback(sessionCode, qrContainer);
                        }
                    });
                } else {
                    // í´ë°±: ì™¸ë¶€ QR ì½”ë“œ API ì‚¬ìš©
                    this.generateQRCodeFallback(sessionCode, qrContainer);
                }
            }
            
            generateQRCodeFallback(sessionCode, container) {
                const baseUrl = window.location.origin;
                const qrUrl = `${baseUrl}/sensor?code=${sessionCode}`;
                const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qrUrl)}`;
                
                container.innerHTML = `<img src="${qrApiUrl}" alt="QR Code" style="width: 200px; height: 200px;">`;
            }
            
            // ê²½ì£¼ ê²°ê³¼ í‘œì‹œ (ì‘ì—… 12 ê°œì„ )
            showRaceResults() {
                // ê²°ê³¼ íŒ¨ë„ ìƒì„±
                const resultsPanel = document.createElement('div');
                resultsPanel.className = 'ui-panel';
                resultsPanel.style.cssText = `
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                    min-width: 600px;
                    max-width: 800px;
                    z-index: 300;
                    max-height: 80vh;
                    overflow-y: auto;
                `;
                
                // ê²°ê³¼ ë‚´ìš© ìƒì„±
                const sensor1Data = this.lapTracking.sensor1;
                const sensor2Data = this.lapTracking.sensor2;
                
                const winner = (sensor1Data.finalRank || sensor1Data.rank) === 1 ? 'sensor1' : 'sensor2';
                const winnerName = winner === 'sensor1' ? 'í”Œë ˆì´ì–´ 1' : 'í”Œë ˆì´ì–´ 2';
                
                // ìµœê³  ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
                const personalBests = this.getPersonalBests();
                
                // ê²½ì£¼ í†µê³„ ê³„ì‚°
                const raceStats = this.calculateRaceStatistics();
                
                resultsPanel.innerHTML = `
                    <h2 style="color: var(--primary); margin-bottom: 1rem;">ğŸ ê²½ì£¼ ì™„ë£Œ!</h2>
                    <h3 style="color: var(--success); margin-bottom: 2rem;">ğŸ† ìš°ìŠ¹ì: ${winnerName}</h3>
                    
                    <!-- ê²½ì£¼ ê²°ê³¼ -->
                    <div style="display: flex; gap: 2rem; justify-content: center; margin-bottom: 2rem;">
                        ${this.generatePlayerResultCard('í”Œë ˆì´ì–´ 1', sensor1Data, personalBests.player1, 1)}
                        ${this.generatePlayerResultCard('í”Œë ˆì´ì–´ 2', sensor2Data, personalBests.player2, 2)}
                    </div>
                    
                    <!-- ê²½ì£¼ í†µê³„ -->
                    <div style="margin-bottom: 2rem; padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 0.5rem;">
                        <h4 style="color: var(--primary); margin-bottom: 1rem;">ğŸ“Š ê²½ì£¼ í†µê³„</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <div>ì´ ê²½ì£¼ ì‹œê°„: ${raceStats.totalRaceTime.toFixed(2)}ì´ˆ</div>
                            <div>í‰ê·  ì†ë„: ${raceStats.averageSpeed.toFixed(1)} km/h</div>
                            <div>ìµœê³  ì†ë„: ${raceStats.maxSpeed.toFixed(1)} km/h</div>
                            <div>ì´ ê±°ë¦¬: ${(this.totalLaps * this.lapDistance).toFixed(0)}m</div>
                        </div>
                    </div>
                    
                    <!-- ê°œì¸ ìµœê³  ê¸°ë¡ -->
                    <div style="margin-bottom: 2rem; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem;">
                        <h4 style="color: var(--secondary); margin-bottom: 1rem;">ğŸ… ê°œì¸ ìµœê³  ê¸°ë¡</h4>
                        <div style="display: flex; gap: 2rem; justify-content: center;">
                            <div style="text-align: center; color: var(--text-secondary); font-size: 0.9rem;">
                                <div style="font-weight: 600; color: var(--primary);">í”Œë ˆì´ì–´ 1</div>
                                <div>ìµœê³  ë©: ${personalBests.player1.bestLapTime === Infinity ? 'N/A' : personalBests.player1.bestLapTime.toFixed(2)}ì´ˆ</div>
                                <div>ìµœê³  ë ˆì´ìŠ¤: ${personalBests.player1.bestRaceTime === Infinity ? 'N/A' : personalBests.player1.bestRaceTime.toFixed(2)}ì´ˆ</div>
                                <div>ìŠ¹ë¥ : ${personalBests.player1.totalRaces > 0 ? ((personalBests.player1.wins / personalBests.player1.totalRaces) * 100).toFixed(1) : 0}%</div>
                            </div>
                            <div style="text-align: center; color: var(--text-secondary); font-size: 0.9rem;">
                                <div style="font-weight: 600; color: var(--primary);">í”Œë ˆì´ì–´ 2</div>
                                <div>ìµœê³  ë©: ${personalBests.player2.bestLapTime === Infinity ? 'N/A' : personalBests.player2.bestLapTime.toFixed(2)}ì´ˆ</div>
                                <div>ìµœê³  ë ˆì´ìŠ¤: ${personalBests.player2.bestRaceTime === Infinity ? 'N/A' : personalBests.player2.bestRaceTime.toFixed(2)}ì´ˆ</div>
                                <div>ìŠ¹ë¥ : ${personalBests.player2.totalRaces > 0 ? ((personalBests.player2.wins / personalBests.player2.totalRaces) * 100).toFixed(1) : 0}%</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; justify-content: center;">
                        <button class="btn btn-primary" onclick="game.resetGame(); this.parentElement.parentElement.remove();">ğŸ”„ ë‹¤ì‹œ ê²½ì£¼</button>
                        <button class="btn btn-secondary" onclick="game.clearRecords(); this.parentElement.parentElement.remove(); game.showRaceResults();">ğŸ—‘ï¸ ê¸°ë¡ ì´ˆê¸°í™”</button>
                        <button class="btn btn-secondary" onclick="game.returnToHub()">ğŸ  í—ˆë¸Œë¡œ ëŒì•„ê°€ê¸°</button>
                    </div>
                `;
                
                document.body.appendChild(resultsPanel);
                
                console.log('ğŸ† ê²½ì£¼ ê²°ê³¼ í‘œì‹œ ì™„ë£Œ');
            }
            
            // í”Œë ˆì´ì–´ ê²°ê³¼ ì¹´ë“œ ìƒì„± (ì‘ì—… 12)
            generatePlayerResultCard(playerName, playerData, personalBest, playerNum) {
                const isWinner = (playerData.finalRank || playerData.rank) === 1;
                const completedLaps = Math.min(playerData.currentLap - 1, this.totalLaps);
                const totalRaceTime = playerData.lapTimes.reduce((sum, time) => sum + time, 0);
                
                return `
                    <div style="text-align: center; padding: 1rem; border-radius: 0.5rem; ${isWinner ? 'background: rgba(16, 185, 129, 0.1); border: 2px solid var(--success);' : 'background: rgba(71, 85, 105, 0.1);'}">
                        <h4 style="color: var(--primary); margin-bottom: 1rem;">
                            ${isWinner ? 'ğŸ¥‡' : 'ğŸ¥ˆ'} ${playerName}
                        </h4>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">
                            <div style="margin-bottom: 0.5rem;">
                                <strong>ìµœì¢… ìˆœìœ„:</strong> ${playerData.finalRank || playerData.rank}ìœ„
                            </div>
                            <div style="margin-bottom: 0.5rem;">
                                <strong>ì™„ì£¼ ë©:</strong> ${completedLaps}/${this.totalLaps}
                            </div>
                            <div style="margin-bottom: 0.5rem;">
                                <strong>ì´ ì‹œê°„:</strong> ${totalRaceTime > 0 ? totalRaceTime.toFixed(2) : 'N/A'}ì´ˆ
                            </div>
                            <div style="margin-bottom: 0.5rem;">
                                <strong>ìµœê³  ë©:</strong> ${playerData.bestLapTime === Infinity ? 'N/A' : playerData.bestLapTime.toFixed(2)}ì´ˆ
                            </div>
                            <div style="margin-bottom: 0.5rem;">
                                <strong>í‰ê·  ë©:</strong> ${playerData.lapTimes.length > 0 ? (playerData.lapTimes.reduce((a, b) => a + b, 0) / playerData.lapTimes.length).toFixed(2) : 'N/A'}ì´ˆ
                            </div>
                            ${playerData.bestLapTime < personalBest.bestLapTime ? '<div style="color: var(--success); font-weight: 600;">ğŸ‰ ìƒˆë¡œìš´ ìµœê³  ë© ê¸°ë¡!</div>' : ''}
                            ${completedLaps === this.totalLaps && totalRaceTime < personalBest.bestRaceTime ? '<div style="color: var(--success); font-weight: 600;">ğŸ‰ ìƒˆë¡œìš´ ìµœê³  ë ˆì´ìŠ¤ ê¸°ë¡!</div>' : ''}
                        </div>
                    </div>
                `;
            }
            
            // ê²½ì£¼ í†µê³„ ê³„ì‚° (ì‘ì—… 12)
            calculateRaceStatistics() {
                const allLapTimes = [
                    ...this.lapTracking.sensor1.lapTimes,
                    ...this.lapTracking.sensor2.lapTimes
                ];
                
                const totalRaceTime = this.raceStartTime ? (Date.now() - this.raceStartTime) / 1000 : 0;
                
                // í‰ê·  ì†ë„ ê³„ì‚° (ëŒ€ëµì )
                const totalDistance = this.totalLaps * this.lapDistance * 2; // ë‘ í”Œë ˆì´ì–´
                const averageSpeed = totalRaceTime > 0 ? (totalDistance / totalRaceTime) * 3.6 : 0;
                
                return {
                    totalRaceTime,
                    averageSpeed,
                    maxSpeed: Math.max(
                        this.cars?.player1?.getSpeed() || 0,
                        this.cars?.player2?.getSpeed() || 0
                    ),
                    totalLaps: allLapTimes.length,
                    fastestLap: allLapTimes.length > 0 ? Math.min(...allLapTimes) : 0
                };
            }
            
            // ê°œì¸ ìµœê³  ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (ì‘ì—… 12)
            getPersonalBests() {
                try {
                    const records = JSON.parse(localStorage.getItem('racing3d_records') || '{}');
                    return {
                        player1: records.player1 || {
                            bestLapTime: Infinity,
                            bestRaceTime: Infinity,
                            totalRaces: 0,
                            wins: 0
                        },
                        player2: records.player2 || {
                            bestLapTime: Infinity,
                            bestRaceTime: Infinity,
                            totalRaces: 0,
                            wins: 0
                        }
                    };
                } catch (error) {
                    console.warn('ê°œì¸ ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                    return {
                        player1: { bestLapTime: Infinity, bestRaceTime: Infinity, totalRaces: 0, wins: 0 },
                        player2: { bestLapTime: Infinity, bestRaceTime: Infinity, totalRaces: 0, wins: 0 }
                    };
                }
            }
            
            // ê¸°ë¡ ì´ˆê¸°í™” (ì‘ì—… 12)
            clearRecords() {
                try {
                    localStorage.removeItem('racing3d_records');
                    console.log('ğŸ—‘ï¸ ëª¨ë“  ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
                    alert('ëª¨ë“  ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } catch (error) {
                    console.warn('ê¸°ë¡ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                }
            }
            
            // ì¼ì‹œì •ì§€/ì¬ê°œ í† ê¸€ ë©”ì„œë“œ (ì‘ì—… 9)
            togglePauseResume() {
                const pauseResumeBtn = document.getElementById('pauseResumeBtn');
                
                if (this.gameState === 'racing') {
                    this.pauseGame();
                    if (pauseResumeBtn) {
                        pauseResumeBtn.innerHTML = 'â–¶ï¸ ì¬ê°œ';
                    }
                } else if (this.gameState === 'paused') {
                    this.resumeGame();
                    if (pauseResumeBtn) {
                        pauseResumeBtn.innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';
                    }
                }
            }
        }
        
        // ê²Œì„ ì‹œì‘
        const game = new RacingGame();
    </script>
</body>
</html>